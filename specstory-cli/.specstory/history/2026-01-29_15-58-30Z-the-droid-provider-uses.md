<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-01-29 15:58:30Z

<!-- Claude Code Session c93331df-f87a-4883-8499-7754db8bafe7 (2026-01-29 15:58:30Z) -->

_**User (2026-01-29 15:58:30Z)**_

The Droid provider uses a 1 sec poll for its watcher while the Claude, Codex and Gemini providers use fsnotify event based watching. The latter is the preferred approach. We need to change the Droid provider to use fsnotify for watching.

---

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:58:35Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to change the Droid provider from using a 1-second polling approach to using fsnotify event-based watching, similar to how the Claude, Codex, and Gemini providers work.

Let me explore the codebase to understand:
1. How the Droid provider currently implements watching with polling
2. How other providers (Claude, Codex, Gemini) implement fsnotify-based watching
3. What patterns and code can be reused

I should launch Explore agents to investigate these areas. Since this involves understanding multiple provider implementations, I'll use multiple agents to explore in parallel.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:58:36Z)**_

I'll explore the codebase to understand the current implementations. Let me launch explore agents to investigate the Droid provider's polling approach and how other providers use fsnotify.

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:58:39Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Explore Droid provider watcher
```
Perfect! Now I have a comprehensive understanding of the Droid provider's file watching implementation. Let me compile all the findings:

## Droid Provider File Watching Implementation Report

Based on my exploration of the codebase, here's a detailed analysis of how the Droid provider implements file watching with a 1-second poll:

### 1. Watcher Implementation and Polling Mechanism

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go`

The watcher uses a time-based ticker mechanism:

```go
const droidWatchInterval = 1 * time.Second

func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	state := &watchState{lastProcessed: make(map[string]int64)}
	if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
		return err
	}

	ticker := time.NewTicker(droidWatchInterval)  // 1-second poll interval
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:  // Fires every 1 second
			if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
				slog.Debug("droidcli: scan failed", "error", err)
			}
		}
	}
}
```

**Key characteristics:**
- Uses `time.NewTicker(1 * time.Second)` for polling
- Context-aware: stops when `ctx.Done()` signals
- Runs `scanAndProcessSessions()` on each tick
- Initial scan before entering the loop
- Logs errors but doesn't exit on scan failures

### 2. How the Watcher is Started and Stopped

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider.go`

**Function:** `ExecAgentAndWatch()` (lines 135-159)

```go
func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	if sessionCallback == nil {
		return ExecuteDroid(customCommand, resumeSessionID)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	watchErr := make(chan error, 1)
	go func() {
		watchErr <- watchSessions(ctx, projectPath, debugRaw, sessionCallback)
	}()

	err := ExecuteDroid(customCommand, resumeSessionID)
	cancel()  // Stop the watcher

	if werr := <-watchErr; werr != nil && !errors.Is(werr, context.Canceled) {
		slog.Warn("droidcli: watcher stopped with error", "error", werr)
	}

	if err != nil {
		return fmt.Errorf("factory droid CLI execution failed: %w", err)
	}
	return nil
}
```

**Function:** `WatchAgent()` (lines 161-166)

```go
func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	if sessionCallback == nil {
		return fmt.Errorf("session callback is required")
	}
	return watchSessions(ctx, projectPath, debugRaw, sessionCallback)
}
```

**Startup/Shutdown mechanism:**
- Started: Goroutine spawned in `ExecAgentAndWatch()` or called directly in `WatchAgent()`
- Context-based cancellation propagates to stop the ticker
- `defer cancel()` ensures cleanup when the command completes
- Error from watcher read from channel after cancellation

### 3. What Files/Directories it Watches

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/path_utils.go`

The watcher monitors:

```go
const (
	factoryRootDir     = ".factory"
	factorySessionsDir = "sessions"
)

func resolveSessionsDir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("droidcli: cannot resolve home dir: %w", err)
	}
	dir := filepath.Join(home, factoryRootDir, factorySessionsDir)
	return dir, nil
}

func listSessionFiles() ([]sessionFile, error) {
	dir, err := resolveSessionsDir()
	if err != nil {
		return nil, err
	}
	files := make([]sessionFile, 0, 64)
	walker := func(path string, d fs.DirEntry, walkErr error) error {
		if walkErr != nil {
			return nil
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(d.Name()) != ".jsonl" {
			return nil
		}
		info, err := d.Info()
		if err != nil {
			return nil
		}
		files = append(files, sessionFile{
			Path:     path,
			ModTime:  info.ModTime().UnixNano(),
			FileName: d.Name(),
		})
		return nil
	}
	if err := filepath.WalkDir(dir, walker); err != nil {
		if os.IsNotExist(err) {
			return []sessionFile{}, nil
		}
		return nil, fmt.Errorf("droidcli: unable to read sessions dir: %w", err)
	}
	sort.Slice(files, func(i, j int) bool {
		return files[i].ModTime > files[j].ModTime
	})
	return files, nil
}
```

**Watched location:** `~/.factory/sessions/`

**File criteria:**
- Only `.jsonl` files
- Files stored recursively (walk all subdirectories)
- Sorted by modification time (most recent first)
- Returns empty list if directory doesn't exist (not an error)

### 4. How it Processes Changes When Detected

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/watcher.go` (lines 43-69)

```go
type watchState struct {
	lastProcessed map[string]int64
}

func scanAndProcessSessions(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) error {
	files, err := listSessionFiles()  // Poll all .jsonl files
	if err != nil {
		return err
	}

	for _, file := range files {
		// Skip if already processed and file hasn't changed
		if last, ok := state.lastProcessed[file.Path]; ok && last >= file.ModTime {
			continue
		}
		
		// Skip if file doesn't mention the target project
		if projectPath != "" && !sessionMentionsProject(file.Path, projectPath) {
			continue
		}
		
		// Parse the session file
		session, err := parseFactorySession(file.Path)
		if err != nil {
			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
			continue
		}
		
		// Convert to standardized format
		chat := convertToAgentSession(session, projectPath, debugRaw)
		if chat == nil {
			continue
		}
		
		// Update state with new modification time
		state.lastProcessed[file.Path] = file.ModTime
		
		// Dispatch session in goroutine with panic recovery
		dispatchSession(sessionCallback, chat)
	}
	return nil
}

func dispatchSession(sessionCallback func(*spi.AgentChatSession), session *spi.AgentChatSession) {
	if sessionCallback == nil || session == nil {
		return
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				slog.Error("droidcli: session callback panicked", "panic", r)
			}
		}()
		sessionCallback(session)
	}()
}
```

**Processing flow:**

1. **Detection:** On each 1-second tick, list all `.jsonl` files in `~/.factory/sessions/`
2. **Change detection:** Compare file modification time (`ModTime`) against `lastProcessed` map
3. **Project filtering:** Skip files that don't mention the target project path
4. **Parsing:** Parse JSONL file via `parseFactorySession()` 
5. **Conversion:** Convert Factory Droid format to standardized `spi.AgentChatSession`
6. **State update:** Store the new `ModTime` in `lastProcessed` map
7. **Dispatch:** Call session callback asynchronously in a goroutine with panic recovery

**State management:**
- `watchState.lastProcessed` tracks file path → modification time
- Only reprocesses files when `ModTime` is newer than last known time
- Prevents duplicate processing of unchanged files

---

### Summary Table

| Aspect | Details |
|--------|---------|
| **Poll Interval** | 1 second (`time.NewTicker(1 * time.Second)`) |
| **Watched Directory** | `~/.factory/sessions/` |
| **File Pattern** | `*.jsonl` files (recursively) |
| **Change Detection** | File modification time comparison |
| **State Tracking** | In-memory map: filepath → last ModTime (int64 nanoseconds) |
| **Processing** | Asynchronous via goroutine with panic recovery |
| **Stop Mechanism** | Context cancellation via `ctx.Done()` |
| **Project Filtering** | Checks if session file mentions the project path |
agentId: acfd902 (for resuming to continue this agent's work if needed)
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:58:41Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Explore fsnotify watcher patterns
```
Excellent! Now I have all the information needed. Let me compile a comprehensive exploration report of the fsnotify-based file watching implementations across the providers.

## File Watching Implementation Exploration Report

I've thoroughly explored the fsnotify-based file watching implementations across the SpecStory CLI codebase. Here's a comprehensive analysis of patterns you can reuse:

### Overview

The codebase implements file watching across **5 provider packages**:
1. **Claude Code** (`pkg/providers/claudecode/`)
2. **Codex CLI** (`pkg/providers/codexcli/`)
3. **Gemini CLI** (`pkg/providers/geminicli/`)
4. **Cursor CLI** (`pkg/providers/cursorcli/`) - Uses polling instead of fsnotify
5. **Droid CLI** (`pkg/providers/droidcli/`) - Uses polling instead of fsnotify

---

## 1. Watcher Setup and Initialization

### Claude Code Pattern (Most Sophisticated)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/watcher.go`

**Key Functions**:
- `WatchForProjectDir()` - Entry point that handles initial setup
- `startProjectWatcher(claudeProjectDir)` - Core watcher implementation
- `WatchForClaudeSetup()` - Waits for ~/.claude directory creation

**Initialization Pattern**:

```go
// Package-level context and synchronization
var (
	watcherCtx      context.Context
	watcherCancel   context.CancelFunc
	watcherWg       sync.WaitGroup
	watcherCallback func(*spi.AgentChatSession)
	watcherDebugRaw bool
	watcherMutex    sync.RWMutex
)

func init() {
	watcherCtx, watcherCancel = context.WithCancel(context.Background())
}

// Create and setup fsnotify watcher
watcher, err := fsnotify.NewWatcher()
if err != nil {
	return fmt.Errorf("failed to create file watcher: %v", err)
}

// Increment wait group before starting goroutine
watcherWg.Add(1)

// Start watching in a goroutine with proper cleanup
go func() {
	defer watcherWg.Done()
	defer func() {
		_ = watcher.Close()
	}()
	// ... event handling loop
}()
```

**Why this pattern works**:
- Global context allows graceful shutdown from anywhere
- WaitGroup ensures all goroutines complete before exit
- Deferred cleanup guarantees watcher closes even on panic

### Codex CLI Pattern (Hierarchical Directory Watching)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/watcher.go`

**Key Innovation**: Watches directory hierarchy (YYYY/MM/DD structure) to handle date changes across days, months, and years

```go
// Watches sessions root for year directories
if err := addWatch(sessionsRoot); err != nil {
	return err
}

// Scan for existing year directories and watch them
entries, err := os.ReadDir(sessionsRoot)
for _, entry := range entries {
	if entry.IsDir() && len(entry.Name()) == 4 {
		yearDir := filepath.Join(sessionsRoot, entry.Name())
		watchYearDir(yearDir)
	}
}

// Helper to prevent duplicate watches
watchedDirs := make(map[string]bool)
var watchedDirsMutex sync.Mutex

addWatch := func(dir string) error {
	watchedDirsMutex.Lock()
	defer watchedDirsMutex.Unlock()
	
	if watchedDirs[dir] {
		return nil // Already watching
	}
	
	if err := watcher.Add(dir); err != nil {
		return err
	}
	watchedDirs[dir] = true
	return nil
}
```

### Gemini CLI Pattern (Pre-directory Existence Polling)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/watcher.go`

**Key Innovation**: Polls before watching to handle cases where directories don't exist yet

```go
// Exponential backoff polling for directory readiness
const (
	initialBackoff = 1 * time.Second
	maxBackoff     = 30 * time.Second
)

func waitForDirectory(ctx context.Context, dir string, label string) error {
	backoff := initialBackoff
	for {
		info, err := os.Stat(dir)
		if err == nil && info.IsDir() {
			return nil
		}
		
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(backoff):
			if backoff < maxBackoff {
				backoff *= 2
				if backoff > maxBackoff {
					backoff = maxBackoff
				}
			}
		}
	}
}
```

### Cursor CLI Pattern (Polling Instead of fsnotify)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher.go`

**Key Innovation**: Uses polling for SQLite databases (fsnotify doesn't work well with SQLite WAL mode)

```go
type CursorWatcher struct {
	projectPath     string
	hashDir         string
	pollInterval    time.Duration // 5 * time.Second
	ctx             context.Context
	cancel          context.CancelFunc
	wg              sync.WaitGroup
	lastCounts      map[string]int  // Track record counts per session
	knownSessions   map[string]bool // Sessions existing at startup
	resumedSession  string
	sessionCallback func(*spi.AgentChatSession)
	debugRaw        bool
	mu              sync.RWMutex
}

func (w *CursorWatcher) watchLoop() {
	defer w.wg.Done()
	
	ticker := time.NewTicker(w.pollInterval)
	defer ticker.Stop()
	
	w.checkForChanges() // Initial check
	
	for {
		select {
		case <-w.ctx.Done():
			return
		case <-ticker.C:
			w.checkForChanges()
		}
	}
}
```

---

## 2. Event Handling Patterns

### Claude Code: JSONL File Events

```go
// Watch for file events
for {
	select {
	case <-watcherCtx.Done():
		slog.Info("Context cancelled, stopping watcher")
		return
	case event, ok := <-watcher.Events:
		if !ok {
			return
		}
		
		// Only process JSONL files
		if !strings.HasSuffix(event.Name, ".jsonl") {
			continue
		}
		
		if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) {
			continue
		}
		
		// Handle different event types
		switch {
		case event.Has(fsnotify.Create):
			slog.Info("New JSONL file created", "file", event.Name)
			scanJSONLFiles(claudeProjectDir, event.Name)
		case event.Has(fsnotify.Write):
			slog.Info("JSONL file modified", "file", event.Name)
			scanJSONLFiles(claudeProjectDir, event.Name)
		}
		
	case err, ok := <-watcher.Errors:
		if !ok {
			return
		}
		log.UserError("Watcher error: %v", err)
	}
}
```

### Codex CLI: Hierarchical Directory Events

```go
case event, ok := <-watcher.Events:
	if !ok {
		return
	}
	
	// Check if this is a JSONL file (in a day directory)
	if strings.HasSuffix(eventPath, ".jsonl") {
		switch {
		case event.Has(fsnotify.Create), event.Has(fsnotify.Write):
			slog.Info("JSONL file event", "operation", event.Op.String(), "file", eventPath)
			ScanCodexSessions(projectPath, parentDir, &eventPath)
		case event.Has(fsnotify.Remove):
			slog.Info("JSONL file removed", "file", eventPath)
			ScanCodexSessions(projectPath, parentDir, nil)
		}
		continue
	}
	
	// Check if this is a directory creation (hierarchical watching)
	if event.Has(fsnotify.Create) {
		switch dirType(eventPath, sessionsRoot) {
		case "year":
			watchYearDir(eventPath)
		case "month":
			watchMonthDir(eventPath)
		case "day":
			watchDayDir(eventPath)
		}
	}
```

### Gemini CLI: Multi-file Session Handling

```go
func processSessionChange(filePath string) {
	// Extract short session ID from filename to find related files
	filename := filepath.Base(filePath)
	shortID := extractSessionIDFromFilename(filename)
	
	// Find all files for this session to merge them
	chatsDir := filepath.Dir(filePath)
	entries, err := os.ReadDir(chatsDir)
	
	// Collect all files that match this session's short ID
	var sessionFiles []string
	for _, entry := range entries {
		if !entry.IsDir() && extractSessionIDFromFilename(entry.Name()) == shortID {
			sessionFiles = append(sessionFiles, filepath.Join(chatsDir, entry.Name()))
		}
	}
	
	// Merge all files for this session
	mergedSession, err := parseAndMergeSessionFiles(shortID, sessionFiles)
	agentSession := convertToAgentChatSession(mergedSession, getWatcherWorkspaceRoot(), getWatcherDebugRaw())
	triggerCallback(agentSession)
}
```

---

## 3. Debouncing and Rate Limiting Patterns

### Claude Code: Event-Driven (No Debouncing)
- Processes events immediately as they arrive
- Single file scanning per event
- No artificial delays

### Codex CLI: Event-Driven (No Debouncing)
- Handles Create, Write, and Remove events separately
- No aggregation - each event triggers a scan
- Efficient because scans are limited to affected directory

### Cursor CLI: Polling with Change Detection
```go
// hasSessionChanged checks if a session database has new records
func (w *CursorWatcher) hasSessionChanged(sessionID string, fileInfo os.FileInfo, dbPath string) bool {
	w.mu.Lock()
	defer w.mu.Unlock()
	
	// Count total records in the blobs table
	var count int
	err = db.QueryRow("SELECT COUNT(*) FROM blobs").Scan(&count)
	
	// Check if record count changed
	lastCount, countExists := w.lastCounts[sessionID]
	w.lastCounts[sessionID] = count
	
	if !countExists {
		// First time seeing this session - only process if it has content
		return count > 0
	}
	
	if count > lastCount {
		return true // Records added
	}
	
	return false
}
```

### Gemini CLI: Polling with Backoff
```go
backoff := initialBackoff
for {
	info, err := os.Stat(dir)
	if err == nil && info.IsDir() {
		return nil
	}
	
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-time.After(backoff):
		if backoff < maxBackoff {
			backoff *= 2
			if backoff > maxBackoff {
				backoff = maxBackoff
			}
		}
	}
}
```

---

## 4. Error Handling Patterns

### Claude Code: User-Friendly Error Logging

```go
// Graceful degradation - continue on watcher errors
case err, ok := <-watcher.Errors:
	if !ok {
		slog.Info("startProjectWatcher: Watcher errors channel closed")
		return
	}
	log.UserWarn("Watcher error: %v", err)
	slog.Error("startProjectWatcher: Watcher error", "error", err)
```

### Directory Monitoring Error Recovery

```go
// If project directory doesn't exist yet, watch parent directory
if _, err := os.Stat(claudeProjectDir); err == nil {
	// Directory exists, proceed
} else {
	// Cannot access, watch parent
	parentDir := filepath.Dir(claudeProjectDir)
	
	if err := watcher.Add(parentDir); err != nil {
		log.UserError("Error watching parent directory: %v", err)
		return
	}
	
	// Wait for project directory to be created
	for waitingForCreation {
		select {
		case <-watcherCtx.Done():
			return
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}
			if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), projectName) {
				_ = watcher.Remove(parentDir) // OK if this fails
				waitingForCreation = false
			}
		}
	}
}
```

### Cursor CLI: Resilient Database Access

```go
// Open database with read-only mode
db, err := sql.Open("sqlite", dbPath+"?mode=ro")
if err != nil {
	slog.Error("Failed to open database", "sessionId", sessionID, "error", err)
	return false
}
defer func() {
	if err := db.Close(); err != nil {
		slog.Debug("Failed to close database", "error", err)
	}
}()

// Enable WAL mode for non-blocking reads
if _, err := db.Exec("PRAGMA journal_mode=WAL"); err != nil {
	slog.Debug("Failed to enable WAL mode in watcher", "error", err)
}
```

---

## 5. Watcher Cleanup Patterns

### Standard Pattern (All Providers)

```go
// Graceful shutdown function
func StopWatcher() {
	slog.Info("StopWatcher: Signaling watcher to stop")
	watcherCancel() // Signal all goroutines to stop
	slog.Info("StopWatcher: Waiting for watcher goroutine to finish")
	watcherWg.Wait() // Block until all complete
	slog.Info("StopWatcher: Watcher stopped")
}
```

### Deferred Cleanup in Goroutines

```go
go func() {
	defer watcherWg.Done()
	
	// Defer cleanup happens last (LIFO order)
	defer func() {
		slog.Info("Goroutine exiting, closing watcher")
		_ = watcher.Close() // Best effort cleanup
	}()
	
	// ... event handling loop
}()
```

### Context-Based Cancellation

```go
// All watchers respect context cancellation
watcherCtx, watcherCancel = context.WithCancel(context.Background())

// In event loop:
select {
case <-watcherCtx.Done():
	slog.Info("Context cancelled, stopping watcher")
	return
case event, ok := <-watcher.Events:
	// ... process event
}
```

### Cursor CLI: Callback Synchronization

```go
// Stop gracefully stops the watcher
func (w *CursorWatcher) Stop() {
	slog.Info("Stopping Cursor watcher")
	
	// Perform one final check before stopping
	w.checkForChanges()
	
	// Now stop the watcher goroutines
	w.cancel()
	w.wg.Wait()
	
	// Wait for any pending callback goroutines to complete
	slog.Info("Waiting for pending callbacks to complete")
	w.callbackWg.Wait()
	
	slog.Info("Cursor watcher stopped")
}
```

---

## 6. Callback Handling and Thread Safety

### Thread-Safe Callback Management

```go
var (
	watcherCallback func(*spi.AgentChatSession)
	watcherDebugRaw bool
	watcherMutex    sync.RWMutex
)

// Thread-safe setter
func SetWatcherCallback(callback func(*spi.AgentChatSession)) {
	watcherMutex.Lock()
	defer watcherMutex.Unlock()
	watcherCallback = callback
	slog.Info("SetWatcherCallback: Callback set", "isNil", callback == nil)
}

// Thread-safe getter
func getWatcherCallback() func(*spi.AgentChatSession) {
	watcherMutex.RLock()
	defer watcherMutex.RUnlock()
	return watcherCallback
}
```

### Non-Blocking Callback Invocation

```go
// Get the session callback
callback := getWatcherCallback()
if callback == nil {
	slog.Error("ScanJSONLFiles: No callback provided")
	return
}

// Call in goroutine to avoid blocking watcher
go func(s *spi.AgentChatSession) {
	defer func() {
		if r := recover(); r != nil {
			slog.Error("ScanJSONLFiles: Callback panicked", "panic", r)
		}
	}()
	callback(s)
}(agentSession)
```

### Gemini CLI: Helper Function Pattern

```go
func triggerCallback(agentSession *spi.AgentChatSession) {
	watcherMutex.RLock()
	cb := watcherCallback
	watcherMutex.RUnlock()
	
	if cb != nil && agentSession != nil {
		cb(agentSession)
	}
}
```

---

## 7. File Filtering Patterns

### Suffix-Based Filtering
```go
// Only process JSONL files
if !strings.HasSuffix(event.Name, ".jsonl") {
	continue
}
```

### Multiple Format Support (Gemini)
```go
if strings.HasSuffix(event.Name, ".json") && 
   (event.Has(fsnotify.Write) || event.Has(fsnotify.Create)) {
	processSessionChange(event.Name)
}
```

### Extension-Based Filtering
```go
if filepath.Ext(entry.Name()) != ".jsonl" {
	continue
}
```

---

## 8. Real-World Implementation Examples

### Provider Integration Pattern

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider.go`

```go
// ExecAgentAndWatch - Execute and watch pattern
func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	// Set up the callback
	SetWatcherCallback(sessionCallback)
	defer ClearWatcherCallback()
	
	SetWatcherDebugRaw(debugRaw)
	
	// Start watching in background
	if err := WatchForProjectDir(); err != nil {
		slog.Error("Failed to start project directory watcher", "error", err)
	}
	
	// Execute agent (blocking)
	err := ExecuteClaude(customCommand, resumeSessionID)
	
	// Stop the watcher goroutine before returning
	StopWatcher()
	
	return err
}

// WatchAgent - Watch without executing pattern
func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	SetWatcherCallback(sessionCallback)
	defer ClearWatcherCallback()
	
	SetWatcherDebugRaw(debugRaw)
	
	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
	if err != nil {
		return err
	}
	
	if err := startProjectWatcher(claudeProjectDir); err != nil {
		return err
	}
	
	// Block until context is cancelled
	<-ctx.Done()
	
	StopWatcher()
	return ctx.Err()
}
```

---

## Summary of Reusable Patterns

**✓ Watcher Setup**:
- Global context + WaitGroup pattern
- Goroutine-per-watcher with deferred cleanup
- Check directory existence before watching

**✓ Event Handling**:
- Filter by file suffix or extension
- Separate Create vs Write handling
- Short-circuit on irrelevant events

**✓ Debouncing**:
- Event-driven for file watching
- Polling with change detection for databases
- Exponential backoff for pre-existence polling

**✓ Error Handling**:
- Non-fatal watcher errors logged but not propagated
- Parent directory fallback when target doesn't exist
- WAL mode handling for SQLite

**✓ Cleanup**:
- Context cancellation signal
- WaitGroup for coordination
- Callback goroutine tracking (Cursor CLI pattern)

**✓ Thread Safety**:
- RWMutex for shared state
- Callback invoked in separate goroutine
- Deferred recovery from panics

---

## File Paths for Reference

1. **Claude Code (Most Complete)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/watcher.go`
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider.go`

2. **Codex CLI (Hierarchical)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/watcher.go`
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/provider.go`

3. **Gemini CLI (Pre-polling)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/watcher.go`

4. **Cursor CLI (Polling for SQLite)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher.go`

5. **Droid CLI (Simple Polling)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go`
agentId: a95069b (for resuming to continue this agent's work if needed)
```
</details></tool-use>

_**Agent - sidechain (2026-01-29 15:58:41Z)**_

Explore the Droid provider implementation to understand how it currently implements file watching with a 1-second poll. Look for:
1. The watcher implementation and polling mechanism
2. How the watcher is started and stopped
3. What files/directories it watches
4. How it processes changes when detected

Search in pkg/providers/droid/ or similar locations. Provide file paths, function names, and relevant code snippets.

_**Agent - sidechain (2026-01-29 15:58:41Z)**_

Explore how the Claude Code, Codex, or Gemini providers implement fsnotify-based file watching. Look for:
1. The watcher setup and initialization
2. Event handling patterns (write events, etc.)
3. How they handle debouncing or rate limiting
4. Error handling patterns
5. How watchers are cleaned up

Search in pkg/providers/claudecode/, pkg/providers/codex/, pkg/providers/gemini/ or similar locations. Provide file paths, function names, and relevant code patterns that could be reused.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:43Z)**_

I'll explore the Droid provider implementation to understand the file watching mechanism. Let me start by finding the relevant files.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:43Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `pkg/providers/droid/**/*.go`
```
No files found
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:43Z)**_

I'll search for the fsnotify-based file watching implementations across the provider packages. Let me start by exploring the directory structure and then examining the relevant files.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:44Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find droid-related directories

`find /Users/sean/Source/SpecStory/getspecstory/specstory-cli -type d -name "*droid*" | head -20`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:44Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `pkg/providers/*/watcher.go`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:44Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find provider directories

`find /Users/sean/Source/SpecStory/getspecstory/specstory-cli -type d -name "providers" | head -20`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:44Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `pkg/providers/*/*.go`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/claude_code_exec_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/jsonl_parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/jsonl_parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/path_utils_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/blob_parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/blob_parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/cursor_cli_exec_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/dag_sort.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/dag_sort_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/path_utils_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/sqlite_reader.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/sqlite_reader_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/json_parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/json_parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/path_utils_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/claude_code_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/jsonl_debug.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/codex_cli_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/cursor_cli_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/gemini_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/droid_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/types.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/markdown_tools.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:44Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `./` pattern `pkg/providers/**/*.go`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/claude_code_exec_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/jsonl_parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/jsonl_parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/path_utils_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/blob_parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/blob_parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/cursor_cli_exec_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/dag_sort.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/dag_sort_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/path_utils_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/sqlite_reader.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/sqlite_reader_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/json_parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/json_parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/path_utils_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/markdown_tools.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/claude_code_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/jsonl_debug.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/codex_cli_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/cursor_cli_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/gemini_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/droid_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/types.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/markdown_tools.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

Good! The Droid provider is in `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/`. Let me now examine the watcher implementation and related files:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

Perfect! I can see there are watcher.go files in multiple providers. Let me examine each one along with their related provider files to understand the fsnotify implementations.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/watcher.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"time"
     8→
     9→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    10→)
    11→
    12→const droidWatchInterval = 1 * time.Second
    13→
    14→type watchState struct {
    15→	lastProcessed map[string]int64
    16→}
    17→
    18→func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
    19→	if sessionCallback == nil {
    20→		return fmt.Errorf("session callback is required")
    21→	}
    22→
    23→	state := &watchState{lastProcessed: make(map[string]int64)}
    24→	if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    25→		return err
    26→	}
    27→
    28→	ticker := time.NewTicker(droidWatchInterval)
    29→	defer ticker.Stop()
    30→
    31→	for {
    32→		select {
    33→		case <-ctx.Done():
    34→			return ctx.Err()
    35→		case <-ticker.C:
    36→			if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    37→				slog.Debug("droidcli: scan failed", "error", err)
    38→			}
    39→		}
    40→	}
    41→}
    42→
    43→func scanAndProcessSessions(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) error {
    44→	files, err := listSessionFiles()
    45→	if err != nil {
    46→		return err
    47→	}
    48→
    49→	for _, file := range files {
    50→		if last, ok := state.lastProcessed[file.Path]; ok && last >= file.ModTime {
    51→			continue
    52→		}
    53→		if projectPath != "" && !sessionMentionsProject(file.Path, projectPath) {
    54→			continue
    55→		}
    56→		session, err := parseFactorySession(file.Path)
    57→		if err != nil {
    58→			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
    59→			continue
    60→		}
    61→		chat := convertToAgentSession(session, projectPath, debugRaw)
    62→		if chat == nil {
    63→			continue
    64→		}
    65→		state.lastProcessed[file.Path] = file.ModTime
    66→		dispatchSession(sessionCallback, chat)
    67→	}
    68→	return nil
    69→}
    70→
    71→func dispatchSession(sessionCallback func(*spi.AgentChatSession), session *spi.AgentChatSession) {
    72→	if sessionCallback == nil || session == nil {
    73→		return
    74→	}
    75→	go func() {
    76→		defer func() {
    77→			if r := recover(); r != nil {
    78→				slog.Error("droidcli: session callback panicked", "panic", r)
    79→			}
    80→		}()
    81→		sessionCallback(session)
    82→	}()
    83→}
    84→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/claudecode/watcher.go`
```
     1→package claudecode
     2→
     3→import (
     4→	"context"
     5→	"encoding/json"
     6→	"fmt"
     7→	"log/slog"
     8→	"os"
     9→	"path/filepath"
    10→	"strings"
    11→	"sync"
    12→	"time"
    13→
    14→	"github.com/fsnotify/fsnotify"
    15→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    17→)
    18→
    19→var (
    20→	watcherCtx      context.Context
    21→	watcherCancel   context.CancelFunc
    22→	watcherWg       sync.WaitGroup
    23→	watcherCallback func(*spi.AgentChatSession) // Callback for session updates
    24→	watcherDebugRaw bool                        // Whether to write debug raw data files
    25→	watcherMutex    sync.RWMutex                // Protects watcherCallback and watcherDebugRaw
    26→)
    27→
    28→func init() {
    29→	watcherCtx, watcherCancel = context.WithCancel(context.Background())
    30→}
    31→
    32→// SetWatcherCallback sets the callback function for session updates
    33→func SetWatcherCallback(callback func(*spi.AgentChatSession)) {
    34→	watcherMutex.Lock()
    35→	defer watcherMutex.Unlock()
    36→	watcherCallback = callback
    37→	slog.Info("SetWatcherCallback: Callback set", "isNil", callback == nil)
    38→}
    39→
    40→// ClearWatcherCallback clears the callback function
    41→func ClearWatcherCallback() {
    42→	watcherMutex.Lock()
    43→	defer watcherMutex.Unlock()
    44→	watcherCallback = nil
    45→	slog.Info("ClearWatcherCallback: Callback cleared")
    46→}
    47→
    48→// SetWatcherDebugRaw sets whether to write debug raw data files
    49→func SetWatcherDebugRaw(debugRaw bool) {
    50→	watcherMutex.Lock()
    51→	defer watcherMutex.Unlock()
    52→	watcherDebugRaw = debugRaw
    53→	slog.Debug("SetWatcherDebugRaw: Debug raw set", "debugRaw", debugRaw)
    54→}
    55→
    56→// getWatcherDebugRaw returns the current debug raw setting (thread-safe)
    57→func getWatcherDebugRaw() bool {
    58→	watcherMutex.RLock()
    59→	defer watcherMutex.RUnlock()
    60→	return watcherDebugRaw
    61→}
    62→
    63→// getWatcherCallback returns the current callback function (thread-safe)
    64→func getWatcherCallback() func(*spi.AgentChatSession) {
    65→	watcherMutex.RLock()
    66→	defer watcherMutex.RUnlock()
    67→	return watcherCallback
    68→}
    69→
    70→// StopWatcher gracefully stops the watcher goroutine
    71→func StopWatcher() {
    72→	slog.Info("StopWatcher: Signaling watcher to stop")
    73→	watcherCancel()
    74→	slog.Info("StopWatcher: Waiting for watcher goroutine to finish")
    75→	watcherWg.Wait()
    76→	slog.Info("StopWatcher: Watcher stopped")
    77→}
    78→
    79→// WatchForProjectDir watches for a project directory that matches the current working directory
    80→func WatchForProjectDir() error {
    81→	slog.Info("WatchForProjectDir: Determining project directory to monitor")
    82→	claudeProjectDir, err := GetClaudeCodeProjectDir("")
    83→	if err != nil {
    84→		slog.Error("WatchForProjectDir: Failed to get project directory", "error", err)
    85→		// Check if error is specifically about missing Claude projects directory
    86→		if strings.Contains(err.Error(), "claude projects directory not found") {
    87→			slog.Error("WatchForProjectDir: Claude projects directory not found while starting setup watcher")
    88→			// Start watching for Claude directory creation
    89→			return WatchForClaudeSetup()
    90→		}
    91→		return fmt.Errorf("failed to get project directory: %v", err)
    92→	}
    93→
    94→	slog.Info("WatchForProjectDir: Project directory found", "directory", claudeProjectDir)
    95→	return startProjectWatcher(claudeProjectDir)
    96→}
    97→
    98→// startProjectWatcher starts watching a specific project directory
    99→func startProjectWatcher(claudeProjectDir string) error {
   100→	slog.Info("startProjectWatcher: Creating file watcher", "directory", claudeProjectDir)
   101→
   102→	// Create a new watcher
   103→	watcher, err := fsnotify.NewWatcher()
   104→	if err != nil {
   105→		return fmt.Errorf("failed to create file watcher: %v", err)
   106→	}
   107→
   108→	// Increment wait group before starting goroutine
   109→	watcherWg.Add(1)
   110→
   111→	// Start watching in a goroutine
   112→	go func() {
   113→		// Decrement wait group when done
   114→		defer watcherWg.Done()
   115→
   116→		// Log when goroutine starts
   117→		slog.Info("startProjectWatcher: Goroutine started")
   118→
   119→		// Defer cleanup
   120→		defer func() {
   121→			slog.Info("startProjectWatcher: Goroutine exiting, closing watcher")
   122→			_ = watcher.Close() // Best effort cleanup; errors here are not recoverable
   123→		}()
   124→
   125→		// Check if project directory already exists
   126→		if _, err := os.Stat(claudeProjectDir); err == nil {
   127→			slog.Info("startProjectWatcher: Project directory exists", "directory", claudeProjectDir)
   128→			// Claude Code triggers file system events when it starts writing, so we'll catch the session on the first write event.
   129→			slog.Info("startProjectWatcher: Waiting for JSONL file system events")
   130→		} else {
   131→			// Project directory doesn't exist yet, watch parent directory (or other error)
   132→			parentDir := filepath.Dir(claudeProjectDir)
   133→			projectName := filepath.Base(claudeProjectDir)
   134→			slog.Warn("startProjectWatcher: Cannot access project directory, watching parent",
   135→				"error", err,
   136→				"parentDir", parentDir,
   137→				"projectName", projectName)
   138→
   139→			// Add parent directory to watcher
   140→			if err := watcher.Add(parentDir); err != nil {
   141→				log.UserError("Error watching parent directory: %v", err)
   142→				slog.Error("startProjectWatcher: Failed to watch parent directory", "error", err)
   143→				return
   144→			}
   145→
   146→			// Wait for project directory to be created
   147→			waitingForCreation := true
   148→			slog.Info("startProjectWatcher: Now watching for events in parent directory")
   149→			for waitingForCreation {
   150→				select {
   151→				case <-watcherCtx.Done():
   152→					slog.Info("startProjectWatcher: Context cancelled while waiting for directory creation")
   153→					return
   154→				case event, ok := <-watcher.Events:
   155→					if !ok {
   156→						slog.Info("startProjectWatcher: Watcher events channel closed")
   157→						return
   158→					}
   159→					slog.Info("startProjectWatcher: Parent directory event",
   160→						"operation", event.Op.String(),
   161→						"path", event.Name,
   162→						"lookingFor", projectName)
   163→					eventBaseName := filepath.Base(event.Name)
   164→					slog.Info("startProjectWatcher: Event basename comparison",
   165→						"basename", eventBaseName,
   166→						"comparingWith", projectName,
   167→						"equalFold", strings.EqualFold(eventBaseName, projectName))
   168→					if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), projectName) {
   169→						slog.Info("startProjectWatcher: Detected project directory creation",
   170→							"path", event.Name)
   171→						slog.Info("startProjectWatcher: Initial scan disabled; waiting for JSONL events")
   172→						// Use the actual created directory name from the event
   173→						claudeProjectDir = filepath.Join(parentDir, filepath.Base(event.Name))
   174→						// Remove parent directory and continue to watch project directory
   175→						_ = watcher.Remove(parentDir) // OK if this fails; we're moving to project dir
   176→						waitingForCreation = false
   177→					}
   178→				case err, ok := <-watcher.Errors:
   179→					if !ok {
   180→						slog.Info("startProjectWatcher: Watcher errors channel closed")
   181→						return
   182→					}
   183→					log.UserWarn("Watcher error while waiting for project directory: %v", err)
   184→					slog.Error("startProjectWatcher: Watcher error", "error", err)
   185→				}
   186→			}
   187→		}
   188→
   189→		// Add the project directory to the watcher
   190→		// Re-stat to get the actual directory name with correct case
   191→		actualProjectDir := claudeProjectDir
   192→		if entries, err := os.ReadDir(filepath.Dir(claudeProjectDir)); err == nil {
   193→			baseName := filepath.Base(claudeProjectDir)
   194→			for _, entry := range entries {
   195→				if strings.EqualFold(entry.Name(), baseName) {
   196→					actualProjectDir = filepath.Join(filepath.Dir(claudeProjectDir), entry.Name())
   197→					break
   198→				}
   199→			}
   200→		}
   201→		slog.Info("startProjectWatcher: Now monitoring project directory for changes",
   202→			"directory", actualProjectDir)
   203→		if err := watcher.Add(actualProjectDir); err != nil {
   204→			log.UserWarn("Error watching project directory: %v", err)
   205→			slog.Error("startProjectWatcher: Failed to monitor directory", "error", err)
   206→			return
   207→		}
   208→		slog.Info("startProjectWatcher: Successfully monitoring project directory for future changes")
   209→
   210→		// Watch for file events
   211→		for {
   212→			select {
   213→			case <-watcherCtx.Done():
   214→				slog.Info("startProjectWatcher: Context cancelled, stopping watcher")
   215→				return
   216→			case event, ok := <-watcher.Events:
   217→				if !ok {
   218→					return
   219→				}
   220→
   221→				// Only process JSONL files
   222→				if !strings.HasSuffix(event.Name, ".jsonl") {
   223→					continue
   224→				}
   225→
   226→				if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) {
   227→					continue
   228→				}
   229→
   230→				// Handle different event types
   231→				switch {
   232→				case event.Has(fsnotify.Create):
   233→					slog.Info("New JSONL file created", "file", event.Name)
   234→					scanJSONLFiles(claudeProjectDir, event.Name)
   235→				case event.Has(fsnotify.Write):
   236→					slog.Info("JSONL file modified", "file", event.Name)
   237→					slog.Info("Triggering scan due to file modification")
   238→					scanJSONLFiles(claudeProjectDir, event.Name)
   239→				}
   240→
   241→			case err, ok := <-watcher.Errors:
   242→				if !ok {
   243→					return
   244→				}
   245→				log.UserError("Watcher error: %v", err)
   246→			}
   247→		}
   248→	}()
   249→
   250→	return nil
   251→}
   252→
   253→// scanJSONLFiles scans JSONL files and optionally filters processing to a specific changed file
   254→func scanJSONLFiles(claudeProjectDir string, changedFile ...string) {
   255→	// Ensure logs are flushed even if we panic
   256→	defer func() {
   257→		if r := recover(); r != nil {
   258→			log.UserWarn("PANIC in ScanJSONLFiles: %v", r)
   259→			slog.Error("ScanJSONLFiles: PANIC recovered", "panic", r)
   260→		}
   261→	}()
   262→
   263→	slog.Info("ScanJSONLFiles: === START SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   264→	var targetFile string
   265→	if len(changedFile) > 0 && changedFile[0] != "" {
   266→		targetFile = changedFile[0]
   267→		slog.Info("ScanJSONLFiles: Scanning JSONL files with changed file",
   268→			"directory", claudeProjectDir,
   269→			"changedFile", targetFile)
   270→	} else {
   271→		slog.Info("ScanJSONLFiles: Scanning JSONL files", "directory", claudeProjectDir)
   272→	}
   273→	// Parse files and create history files:
   274→	parser := NewJSONLParser()
   275→	var targetSessionUuid string
   276→
   277→	// Set the target file for conditional debug output
   278→	if targetFile != "" {
   279→		SetDebugTargetFile(targetFile)
   280→		defer ClearDebugTargetFile()
   281→
   282→		sessionID, err := extractSessionIDFromFile(targetFile)
   283→		if err != nil {
   284→			slog.Warn("ScanJSONLFiles: Failed to extract session ID from file",
   285→				"file", targetFile,
   286→				"error", err)
   287→			slog.Info("ScanJSONLFiles: Skipping scan due to file read error", "file", targetFile)
   288→			return
   289→		}
   290→		if sessionID == "" {
   291→			slog.Info("ScanJSONLFiles: Skipping scan; session ID not present yet", "file", targetFile)
   292→			return
   293→		}
   294→		targetSessionUuid = sessionID
   295→		slog.Info("ScanJSONLFiles: Extracted session ID from changed file",
   296→			"sessionUuid", targetSessionUuid,
   297→			"file", targetFile)
   298→	}
   299→
   300→	var parseErr error
   301→	if targetSessionUuid != "" {
   302→		parseErr = parser.ParseProjectSessionsForSession(claudeProjectDir, true, targetSessionUuid)
   303→	} else {
   304→		parseErr = parser.ParseProjectSessions(claudeProjectDir, true)
   305→	}
   306→	if parseErr != nil {
   307→		log.UserWarn("Error parsing project sessions: %v", parseErr)
   308→		slog.Error("ScanJSONLFiles: Error parsing project sessions", "error", parseErr)
   309→		return
   310→	}
   311→
   312→	// Process JSONL sessions (isAutosave = true, silent = false for autosave)
   313→	slog.Info("ScanJSONLFiles: Processing sessions",
   314→		"sessionCount", len(parser.Sessions),
   315→		"targetSessionUuid", targetSessionUuid)
   316→
   317→	// Get the session callback
   318→	callback := getWatcherCallback()
   319→	if callback == nil {
   320→		slog.Error("ScanJSONLFiles: No callback provided - this should not happen")
   321→		return
   322→	}
   323→
   324→	slog.Info("ScanJSONLFiles: Processing sessions with callback")
   325→	// Process sessions and call the callback for each
   326→	for _, session := range parser.Sessions {
   327→		// Skip empty sessions
   328→		if len(session.Records) == 0 {
   329→			continue
   330→		}
   331→
   332→		// Skip if we're targeting a specific session and this isn't it
   333→		if targetSessionUuid != "" && session.SessionUuid != targetSessionUuid {
   334→			continue
   335→		}
   336→
   337→		// Convert to AgentChatSession (workspaceRoot extracted from records' cwd field)
   338→		agentSession := convertToAgentChatSession(session, "", getWatcherDebugRaw())
   339→		if agentSession != nil {
   340→			slog.Info("ScanJSONLFiles: Calling callback for session", "sessionId", agentSession.SessionID)
   341→			// Call the callback in a goroutine to avoid blocking
   342→			go func(s *spi.AgentChatSession) {
   343→				defer func() {
   344→					if r := recover(); r != nil {
   345→						slog.Error("ScanJSONLFiles: Callback panicked", "panic", r)
   346→					}
   347→				}()
   348→				callback(s)
   349→			}(agentSession)
   350→		}
   351→	}
   352→	slog.Info("ScanJSONLFiles: Processing complete")
   353→	slog.Info("ScanJSONLFiles: === END SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   354→}
   355→
   356→// WatchForClaudeSetup watches for the creation of Claude directories
   357→func WatchForClaudeSetup() error {
   358→	slog.Info("WatchForClaudeSetup: Starting Claude directory setup watcher")
   359→	homeDir, err := os.UserHomeDir()
   360→	if err != nil {
   361→		return fmt.Errorf("failed to get user home directory: %v", err)
   362→	}
   363→
   364→	claudeDir := filepath.Join(homeDir, ".claude")
   365→	projectsDir := filepath.Join(claudeDir, "projects")
   366→	slog.Info("WatchForClaudeSetup: Directories",
   367→		"homeDir", homeDir,
   368→		"claudeDir", claudeDir,
   369→		"projectsDir", projectsDir)
   370→
   371→	// Determine what to watch
   372→	var watchDir string
   373→	var watchingFor string
   374→
   375→	if _, err := os.Stat(claudeDir); os.IsNotExist(err) {
   376→		// .claude doesn't exist, watch home directory
   377→		watchDir = homeDir
   378→		watchingFor = ".claude"
   379→		slog.Warn("WatchForClaudeSetup: .claude directory does not exist")
   380→		slog.Info("Claude directory not found, watching for creation of ~/.claude\n")
   381→	} else {
   382→		// .claude exists but projects doesn't, watch .claude
   383→		watchDir = claudeDir
   384→		watchingFor = "projects"
   385→		slog.Warn("WatchForClaudeSetup: .claude directory exists, checking for projects")
   386→		slog.Info("Claude directory found, watching for creation of ~/.claude/projects\n")
   387→	}
   388→	slog.Info("WatchForClaudeSetup: Will watch directory",
   389→		"watchDir", watchDir,
   390→		"watchingFor", watchingFor)
   391→
   392→	// Create watcher
   393→	watcher, err := fsnotify.NewWatcher()
   394→	if err != nil {
   395→		log.UserWarn("Failed to create file watcher: %v", err)
   396→		slog.Error("WatchForClaudeSetup: Failed to create file watcher", "error", err)
   397→		return fmt.Errorf("failed to create file watcher: %v", err)
   398→	}
   399→
   400→	// Add directory to watch
   401→	slog.Info("WatchForClaudeSetup: Adding directory to watcher", "directory", watchDir)
   402→	if err := watcher.Add(watchDir); err != nil {
   403→		_ = watcher.Close() // Clean up on error; close errors less important than Add error
   404→		return fmt.Errorf("failed to watch directory %s: %v", watchDir, err)
   405→	}
   406→	slog.Info("WatchForClaudeSetup: Successfully started watching", "directory", watchDir)
   407→
   408→	// Start watching in a goroutine
   409→	go func() {
   410→		defer func() { _ = watcher.Close() }() // Cleanup on exit; errors not recoverable
   411→
   412→		for {
   413→			select {
   414→			case event, ok := <-watcher.Events:
   415→				if !ok {
   416→					return
   417→				}
   418→
   419→				slog.Info("WatchForClaudeSetup: Received event",
   420→					"operation", event.Op.String(),
   421→					"path", event.Name)
   422→				// Check if this is the directory we're waiting for (case-insensitive)
   423→				if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), watchingFor) {
   424→					slog.Info("Detected creation", "path", event.Name)
   425→					slog.Info("WatchForClaudeSetup: Target directory created", "path", event.Name)
   426→
   427→					// Wait a second to let things settle
   428→					slog.Info("WatchForClaudeSetup: Waiting 1 second for things to settle")
   429→					time.Sleep(1 * time.Second)
   430→
   431→					// Check what we should do next
   432→					if watchingFor == ".claude" {
   433→						slog.Info("WatchForClaudeSetup: .claude was created, checking if projects exists")
   434→						// We were watching for .claude, now check if projects exists
   435→						if _, err := os.Stat(projectsDir); os.IsNotExist(err) {
   436→							slog.Info("WatchForClaudeSetup: projects directory does not exist, switching watcher")
   437→							// Need to watch for projects directory
   438→							_ = watcher.Remove(watchDir) // OK if fails; switching watch targets
   439→							watchDir = claudeDir
   440→							watchingFor = "projects"
   441→							slog.Info("WatchForClaudeSetup: Switching to watch",
   442→								"watchDir", watchDir,
   443→								"watchingFor", watchingFor)
   444→							if err := watcher.Add(watchDir); err != nil {
   445→								log.UserWarn("Error switching to watch .claude directory: %v", err)
   446→								slog.Error("WatchForClaudeSetup: Failed to switch watcher", "error", err)
   447→								return
   448→							}
   449→							slog.Info("Now watching for creation of ~/.claude/projects\n")
   450→							continue
   451→						} else {
   452→							slog.Info("WatchForClaudeSetup: projects directory already exists!")
   453→						}
   454→					}
   455→
   456→					// If we get here, projects directory should exist
   457→					slog.Info("WatchForClaudeSetup: Projects directory should now exist, cleaning up watcher")
   458→					// Remove the current watcher
   459→					_ = watcher.Remove(watchDir) // OK if fails; we're transitioning to project watcher
   460→
   461→					// Start the normal project watcher
   462→					slog.Info("Claude projects directory now exists, starting normal file watcher\n")
   463→					// Try to get the project directory again
   464→					slog.Info("WatchForClaudeSetup: Getting project directory name")
   465→					if projectDir, err := GetClaudeCodeProjectDir(""); err == nil {
   466→						slog.Info("WatchForClaudeSetup: Project directory will be", "directory", projectDir)
   467→						if err := startProjectWatcher(projectDir); err != nil {
   468→							log.UserWarn("Error starting project watcher: %v", err)
   469→							slog.Error("WatchForClaudeSetup: Failed to start project watcher", "error", err)
   470→						} else {
   471→							slog.Info("WatchForClaudeSetup: Successfully started project watcher")
   472→						}
   473→					} else {
   474→						log.UserWarn("Error getting project directory after Claude setup: %v", err)
   475→						slog.Error("WatchForClaudeSetup: Failed to get project directory", "error", err)
   476→					}
   477→					return
   478→				}
   479→
   480→			case err, ok := <-watcher.Errors:
   481→				if !ok {
   482→					return
   483→				}
   484→				log.UserWarn("Watcher error: %v", err)
   485→				slog.Error("WatchForClaudeSetup: Watcher error", "error", err)
   486→			}
   487→		}
   488→	}()
   489→
   490→	return nil
   491→}
   492→
   493→// convertToAgentChatSession converts a Session to an AgentChatSession
   494→// Returns nil if the session is warmup-only (no real messages)
   495→func convertToAgentChatSession(session Session, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
   496→	// Skip empty sessions (no records)
   497→	if len(session.Records) == 0 {
   498→		return nil
   499→	}
   500→
   501→	// Write debug files first (even for warmup-only sessions)
   502→	_ = make(map[int]int) // recordToFileNumber no longer needed
   503→	if debugRaw {
   504→		// Write debug files
   505→		writeDebugRawFiles(session)
   506→	}
   507→
   508→	// Filter warmup messages
   509→	filteredRecords := filterWarmupMessages(session.Records)
   510→
   511→	// Skip if no real messages remain after filtering warmup
   512→	if len(filteredRecords) == 0 {
   513→		slog.Debug("Skipping warmup-only session", "sessionId", session.SessionUuid)
   514→		return nil
   515→	}
   516→
   517→	// Create session with filtered records
   518→	filteredSession := Session{
   519→		SessionUuid: session.SessionUuid,
   520→		Records:     filteredRecords,
   521→	}
   522→
   523→	// Get timestamp from root record
   524→	rootRecord := filteredSession.Records[0]
   525→	timestamp, ok := rootRecord.Data["timestamp"].(string)
   526→	if !ok {
   527→		slog.Warn("convertToAgentChatSession: No timestamp found in root record")
   528→		return nil
   529→	}
   530→
   531→	// Get the slug
   532→	slug := FileSlugFromRootRecord(filteredSession)
   533→
   534→	// Generate SessionData from filtered session
   535→	sessionData, err := GenerateAgentSession(filteredSession, workspaceRoot)
   536→	if err != nil {
   537→		slog.Error("Failed to generate SessionData", "sessionId", session.SessionUuid, "error", err)
   538→		return nil
   539→	}
   540→
   541→	// Convert session records to JSONL format for raw data
   542→	// Note: Uses unfiltered session.Records (not filteredSession.Records) to preserve
   543→	// all records including warmup messages in the raw data for complete audit trail
   544→	var rawDataBuilder strings.Builder
   545→	for _, record := range session.Records {
   546→		jsonBytes, _ := json.Marshal(record.Data)
   547→		rawDataBuilder.Write(jsonBytes)
   548→		rawDataBuilder.WriteString("\n")
   549→	}
   550→
   551→	return &spi.AgentChatSession{
   552→		SessionID:   session.SessionUuid,
   553→		CreatedAt:   timestamp, // ISO 8601 timestamp
   554→		Slug:        slug,
   555→		SessionData: sessionData,
   556→		RawData:     rawDataBuilder.String(),
   557→	}
   558→}
   559→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/provider.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"bytes"
     5→	"context"
     6→	"encoding/json"
     7→	"errors"
     8→	"fmt"
     9→	"log/slog"
    10→	"os"
    11→	"os/exec"
    12→	"path/filepath"
    13→	"regexp"
    14→	"strings"
    15→
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    18→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    19→)
    20→
    21→const defaultFactoryCommand = "droid"
    22→
    23→type Provider struct{}
    24→
    25→func NewProvider() *Provider {
    26→	return &Provider{}
    27→}
    28→
    29→func (p *Provider) Name() string {
    30→	return "Factory Droid CLI"
    31→}
    32→
    33→func (p *Provider) Check(customCommand string) spi.CheckResult {
    34→	cmdName, _ := parseDroidCommand(customCommand)
    35→	isCustom := strings.TrimSpace(customCommand) != ""
    36→	versionFlag := "--version"
    37→
    38→	resolved, err := exec.LookPath(cmdName)
    39→	if err != nil {
    40→		msg := buildCheckErrorMessage("not_found", cmdName, isCustom, "")
    41→		trackCheckFailure("droid", isCustom, cmdName, "", classifyDroidPath(cmdName, ""), versionFlag, "", "not_found", err.Error())
    42→		return spi.CheckResult{Success: false, Location: "", ErrorMessage: msg}
    43→	}
    44→	pathType := classifyDroidPath(cmdName, resolved)
    45→
    46→	var stdout, stderr bytes.Buffer
    47→	cmd := exec.Command(resolved, versionFlag)
    48→	cmd.Stdout = &stdout
    49→	cmd.Stderr = &stderr
    50→	if err := cmd.Run(); err != nil {
    51→		errorType := classifyCheckError(err)
    52→		stderrOutput := strings.TrimSpace(stderr.String())
    53→		msg := buildCheckErrorMessage(errorType, resolved, isCustom, stderrOutput)
    54→		trackCheckFailure("droid", isCustom, cmdName, resolved, pathType, versionFlag, stderrOutput, errorType, err.Error())
    55→		return spi.CheckResult{Success: false, Location: resolved, ErrorMessage: msg}
    56→	}
    57→
    58→	versionOutput := sanitizeDroidVersion(stdout.String())
    59→	version := extractDroidVersion(versionOutput)
    60→	if version == "" {
    61→		version = strings.TrimSpace(versionOutput)
    62→	}
    63→	trackCheckSuccess("droid", isCustom, cmdName, resolved, pathType, version, versionFlag)
    64→	return spi.CheckResult{Success: true, Version: version, Location: resolved}
    65→}
    66→
    67→func (p *Provider) DetectAgent(projectPath string, helpOutput bool) bool {
    68→	files, err := listSessionFiles()
    69→	if err != nil {
    70→		if helpOutput {
    71→			log.UserWarn("Factory Droid detection failed: %v", err)
    72→		}
    73→		return false
    74→	}
    75→	if len(files) == 0 {
    76→		if helpOutput {
    77→			printDetectionHelp()
    78→		}
    79→		return false
    80→	}
    81→	if projectPath == "" {
    82→		return true
    83→	}
    84→	for _, file := range files {
    85→		if sessionMentionsProject(file.Path, projectPath) {
    86→			return true
    87→		}
    88→	}
    89→	if helpOutput {
    90→		printDetectionHelp()
    91→	}
    92→	return false
    93→}
    94→
    95→func (p *Provider) GetAgentChatSessions(projectPath string, debugRaw bool) ([]spi.AgentChatSession, error) {
    96→	files, err := listSessionFiles()
    97→	if err != nil {
    98→		return nil, err
    99→	}
   100→	result := make([]spi.AgentChatSession, 0, len(files))
   101→	normalizedProject := strings.TrimSpace(projectPath)
   102→
   103→	for _, file := range files {
   104→		if normalizedProject != "" && !sessionMentionsProject(file.Path, normalizedProject) {
   105→			continue
   106→		}
   107→		session, err := parseFactorySession(file.Path)
   108→		if err != nil {
   109→			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
   110→			continue
   111→		}
   112→		chat := convertToAgentSession(session, projectPath, debugRaw)
   113→		if chat != nil {
   114→			result = append(result, *chat)
   115→		}
   116→	}
   117→	return result, nil
   118→}
   119→
   120→func (p *Provider) GetAgentChatSession(projectPath string, sessionID string, debugRaw bool) (*spi.AgentChatSession, error) {
   121→	path, err := findSessionFileByID(sessionID)
   122→	if err != nil || path == "" {
   123→		return nil, err
   124→	}
   125→	if strings.TrimSpace(projectPath) != "" && !sessionMentionsProject(path, projectPath) {
   126→		return nil, nil
   127→	}
   128→	session, err := parseFactorySession(path)
   129→	if err != nil {
   130→		return nil, err
   131→	}
   132→	return convertToAgentSession(session, projectPath, debugRaw), nil
   133→}
   134→
   135→func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   136→	if sessionCallback == nil {
   137→		return ExecuteDroid(customCommand, resumeSessionID)
   138→	}
   139→
   140→	ctx, cancel := context.WithCancel(context.Background())
   141→	defer cancel()
   142→
   143→	watchErr := make(chan error, 1)
   144→	go func() {
   145→		watchErr <- watchSessions(ctx, projectPath, debugRaw, sessionCallback)
   146→	}()
   147→
   148→	err := ExecuteDroid(customCommand, resumeSessionID)
   149→	cancel()
   150→
   151→	if werr := <-watchErr; werr != nil && !errors.Is(werr, context.Canceled) {
   152→		slog.Warn("droidcli: watcher stopped with error", "error", werr)
   153→	}
   154→
   155→	if err != nil {
   156→		return fmt.Errorf("factory droid CLI execution failed: %w", err)
   157→	}
   158→	return nil
   159→}
   160→
   161→func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   162→	if sessionCallback == nil {
   163→		return fmt.Errorf("session callback is required")
   164→	}
   165→	return watchSessions(ctx, projectPath, debugRaw, sessionCallback)
   166→}
   167→
   168→func convertToAgentSession(session *fdSession, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
   169→	if session == nil {
   170→		return nil
   171→	}
   172→	if len(session.Blocks) == 0 {
   173→		return nil
   174→	}
   175→	sessionData, err := GenerateAgentSession(session, workspaceRoot)
   176→	if err != nil {
   177→		slog.Debug("droidcli: skipping session due to conversion error", "sessionId", session.ID, "error", err)
   178→		return nil
   179→	}
   180→	created := strings.TrimSpace(sessionData.CreatedAt)
   181→	chat := &spi.AgentChatSession{
   182→		SessionID:   session.ID,
   183→		CreatedAt:   created,
   184→		Slug:        session.Slug,
   185→		SessionData: sessionData,
   186→		RawData:     session.RawData,
   187→	}
   188→	if debugRaw {
   189→		if err := writeFactoryDebugRaw(session); err != nil {
   190→			slog.Debug("droidcli: debug raw failed", "sessionId", session.ID, "error", err)
   191→		}
   192→	}
   193→	return chat
   194→}
   195→
   196→func classifyCheckError(err error) string {
   197→	var execErr *exec.Error
   198→	var pathErr *os.PathError
   199→	switch {
   200→	case errors.As(err, &execErr) && execErr.Err == exec.ErrNotFound:
   201→		return "not_found"
   202→	case errors.As(err, &pathErr) && errors.Is(pathErr.Err, os.ErrPermission):
   203→		return "permission_denied"
   204→	case errors.Is(err, os.ErrPermission):
   205→		return "permission_denied"
   206→	default:
   207→		return "version_failed"
   208→	}
   209→}
   210→
   211→func buildCheckErrorMessage(errorType string, command string, isCustom bool, stderr string) string {
   212→	var builder strings.Builder
   213→	switch errorType {
   214→	case "not_found":
   215→		builder.WriteString("Factory Droid CLI was not found.\n\n")
   216→		if isCustom {
   217→			builder.WriteString("• Verify the custom path you provided is executable.\n")
   218→			builder.WriteString(fmt.Sprintf("• Provided command: %s\n", command))
   219→		} else {
   220→			builder.WriteString("• Install the Factory CLI and ensure `droid` is on your PATH.\n")
   221→			builder.WriteString("• Re-run `specstory check droid` after installation.\n")
   222→		}
   223→	case "permission_denied":
   224→		builder.WriteString("SpecStory cannot execute the Factory CLI due to permissions.\n\n")
   225→		builder.WriteString(fmt.Sprintf("Try: chmod +x %s\n", command))
   226→	default:
   227→		builder.WriteString("`droid --version` failed.\n\n")
   228→		if stderr != "" {
   229→			builder.WriteString("Error output:\n")
   230→			builder.WriteString(stderr)
   231→			builder.WriteString("\n\n")
   232→		}
   233→		builder.WriteString("Run `droid --version` manually to diagnose, then retry.")
   234→	}
   235→	return builder.String()
   236→}
   237→
   238→var ansiRegexp = regexp.MustCompile(`\x1b\[[0-9;]*[A-Za-z]`)
   239→
   240→func sanitizeDroidVersion(raw string) string {
   241→	clean := strings.ReplaceAll(raw, "\r", "")
   242→	clean = ansiRegexp.ReplaceAllString(clean, "")
   243→	return clean
   244→}
   245→
   246→func extractDroidVersion(raw string) string {
   247→	lines := strings.Split(raw, "\n")
   248→	var filtered []string
   249→	for _, line := range lines {
   250→		line = strings.TrimSpace(line)
   251→		if line == "" {
   252→			continue
   253→		}
   254→		filtered = append(filtered, line)
   255→	}
   256→	if len(filtered) == 0 {
   257→		return ""
   258→	}
   259→	return filtered[len(filtered)-1]
   260→}
   261→
   262→func trackCheckSuccess(provider string, custom bool, commandPath string, resolvedPath string, pathType string, version string, versionFlag string) {
   263→	props := analytics.Properties{
   264→		"provider":       provider,
   265→		"custom_command": custom,
   266→		"command_path":   commandPath,
   267→		"resolved_path":  resolvedPath,
   268→		"path_type":      pathType,
   269→		"version":        version,
   270→		"version_flag":   versionFlag,
   271→	}
   272→	analytics.TrackEvent(analytics.EventCheckInstallSuccess, props)
   273→}
   274→
   275→func trackCheckFailure(provider string, custom bool, commandPath string, resolvedPath string, pathType string, versionFlag string, stderrOutput string, errorType string, message string) {
   276→	props := analytics.Properties{
   277→		"provider":       provider,
   278→		"custom_command": custom,
   279→		"command_path":   commandPath,
   280→		"resolved_path":  resolvedPath,
   281→		"path_type":      pathType,
   282→		"version_flag":   versionFlag,
   283→		"error_type":     errorType,
   284→		"error_message":  message,
   285→	}
   286→	if stderrOutput != "" {
   287→		props["stderr"] = stderrOutput
   288→	}
   289→	analytics.TrackEvent(analytics.EventCheckInstallFailed, props)
   290→}
   291→
   292→func classifyDroidPath(command string, resolvedPath string) string {
   293→	if resolvedPath == "" {
   294→		if filepath.IsAbs(command) {
   295→			return "absolute_path"
   296→		}
   297→		return "unknown"
   298→	}
   299→	resolvedLower := strings.ToLower(resolvedPath)
   300→	if strings.Contains(resolvedLower, "homebrew") || strings.Contains(resolvedLower, "/opt/homebrew/") {
   301→		return "homebrew"
   302→	}
   303→	if strings.Contains(resolvedLower, "/.local/bin/") {
   304→		return "user_local"
   305→	}
   306→	if strings.Contains(resolvedLower, "/.factory/") {
   307→		return "factory_local"
   308→	}
   309→	if filepath.IsAbs(command) {
   310→		return "absolute_path"
   311→	}
   312→	return "system_path"
   313→}
   314→
   315→func printDetectionHelp() {
   316→	log.UserMessage("No Factory Droid sessions found under ~/.factory/sessions yet.\n")
   317→	log.UserMessage("Run the Factory CLI inside this project to create a JSONL session, then rerun `specstory sync droid`.\n")
   318→}
   319→
   320→func sessionMentionsProject(filePath string, projectPath string) bool {
   321→	projectPath = strings.TrimSpace(projectPath)
   322→	if projectPath == "" {
   323→		return false
   324→	}
   325→
   326→	canonicalProject := canonicalizePath(projectPath)
   327→	if sessionRoot := extractSessionWorkspaceRoot(filePath); sessionRoot != "" {
   328→		canonicalRoot := canonicalizePath(sessionRoot)
   329→		if canonicalProject != "" && canonicalRoot != "" {
   330→			return canonicalRoot == canonicalProject
   331→		}
   332→		return strings.TrimSpace(sessionRoot) == projectPath
   333→	}
   334→
   335→	return sessionMentionsProjectText(filePath, projectPath)
   336→}
   337→
   338→func extractSessionWorkspaceRoot(filePath string) string {
   339→	file, err := os.Open(filePath)
   340→	if err != nil {
   341→		return ""
   342→	}
   343→	defer func() {
   344→		_ = file.Close()
   345→	}()
   346→
   347→	var workspaceRoot string
   348→	scanErr := scanLines(file, func(line string) error {
   349→		trimmed := strings.TrimSpace(line)
   350→		if trimmed == "" {
   351→			return nil
   352→		}
   353→		var env jsonlEnvelope
   354→		if err := json.Unmarshal([]byte(trimmed), &env); err != nil {
   355→			return nil
   356→		}
   357→		if env.Type != "session_start" {
   358→			return nil
   359→		}
   360→		var event sessionStartEvent
   361→		if err := json.Unmarshal([]byte(trimmed), &event); err != nil {
   362→			return nil
   363→		}
   364→		workspaceRoot = firstNonEmpty(event.CWD, event.WorkspaceRoot, event.Session.CWD, event.Session.WorkspaceRoot)
   365→		return errStopScan
   366→	})
   367→	if scanErr != nil && !errors.Is(scanErr, errStopScan) {
   368→		return ""
   369→	}
   370→
   371→	return strings.TrimSpace(workspaceRoot)
   372→}
   373→
   374→func canonicalizePath(path string) string {
   375→	trimmed := strings.TrimSpace(path)
   376→	if trimmed == "" {
   377→		return ""
   378→	}
   379→	canonical, err := spi.GetCanonicalPath(trimmed)
   380→	if err == nil {
   381→		return canonical
   382→	}
   383→	if abs, absErr := filepath.Abs(trimmed); absErr == nil {
   384→		return filepath.Clean(abs)
   385→	}
   386→	return filepath.Clean(trimmed)
   387→}
   388→
   389→func sessionMentionsProjectText(filePath string, projectPath string) bool {
   390→	file, err := os.Open(filePath)
   391→	if err != nil {
   392→		return false
   393→	}
   394→	defer func() {
   395→		_ = file.Close()
   396→	}()
   397→	needle := strings.TrimSpace(projectPath)
   398→	short := filepath.Base(projectPath)
   399→	foundLines := 0
   400→	err = scanLines(file, func(line string) error {
   401→		if needle != "" && strings.Contains(line, needle) {
   402→			return errStopScan
   403→		}
   404→		if short != "" && strings.Contains(line, short) {
   405→			foundLines++
   406→			if foundLines > 2 {
   407→				return errStopScan
   408→			}
   409→		}
   410→		return nil
   411→	})
   412→
   413→	if err != nil && !errors.Is(err, errStopScan) {
   414→		slog.Warn("error scanning session file", "path", filePath, "err", err)
   415→		return false
   416→	}
   417→
   418→	return errors.Is(err, errStopScan)
   419→}
   420→
   421→func writeFactoryDebugRaw(session *fdSession) error {
   422→	if session == nil {
   423→		return nil
   424→	}
   425→	dir := spi.GetDebugDir(session.ID)
   426→	if err := os.MkdirAll(dir, 0o755); err != nil {
   427→		return fmt.Errorf("droidcli: unable to create debug dir: %w", err)
   428→	}
   429→	if err := os.WriteFile(filepath.Join(dir, "session.jsonl"), []byte(session.RawData), 0o644); err != nil {
   430→		return fmt.Errorf("droidcli: unable to write debug raw: %w", err)
   431→	}
   432→	meta := fmt.Sprintf("Session: %s\nTitle: %s\nCreated: %s\nBlocks: %d\n", session.ID, session.Title, session.CreatedAt, len(session.Blocks))
   433→	return os.WriteFile(filepath.Join(dir, "summary.txt"), []byte(meta), 0o644)
   434→}
   435→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/codexcli/watcher.go`
```
     1→package codexcli
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"os"
     8→	"path/filepath"
     9→	"strings"
    10→	"sync"
    11→	"time"
    12→
    13→	"github.com/fsnotify/fsnotify"
    14→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    15→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    16→)
    17→
    18→var (
    19→	watcherCtx      context.Context
    20→	watcherCancel   context.CancelFunc
    21→	watcherWg       sync.WaitGroup
    22→	watcherCallback func(*spi.AgentChatSession) // Callback for session updates
    23→	watcherDebugRaw bool                        // Whether to write debug raw data files
    24→	watcherMutex    sync.RWMutex                // Protects watcherCallback and watcherDebugRaw
    25→)
    26→
    27→func init() {
    28→	watcherCtx, watcherCancel = context.WithCancel(context.Background())
    29→}
    30→
    31→// SetWatcherCallback sets the callback function for session updates.
    32→func SetWatcherCallback(callback func(*spi.AgentChatSession)) {
    33→	watcherMutex.Lock()
    34→	defer watcherMutex.Unlock()
    35→	watcherCallback = callback
    36→	slog.Info("SetWatcherCallback: Callback set", "isNil", callback == nil)
    37→}
    38→
    39→// ClearWatcherCallback clears the callback function.
    40→func ClearWatcherCallback() {
    41→	watcherMutex.Lock()
    42→	defer watcherMutex.Unlock()
    43→	watcherCallback = nil
    44→	slog.Info("ClearWatcherCallback: Callback cleared")
    45→}
    46→
    47→// getWatcherCallback returns the current callback function (thread-safe).
    48→func getWatcherCallback() func(*spi.AgentChatSession) {
    49→	watcherMutex.RLock()
    50→	defer watcherMutex.RUnlock()
    51→	return watcherCallback
    52→}
    53→
    54→// SetWatcherDebugRaw sets whether to write debug raw data files.
    55→func SetWatcherDebugRaw(debugRaw bool) {
    56→	watcherMutex.Lock()
    57→	defer watcherMutex.Unlock()
    58→	watcherDebugRaw = debugRaw
    59→	slog.Debug("SetWatcherDebugRaw: Debug raw set", "debugRaw", debugRaw)
    60→}
    61→
    62→// getWatcherDebugRaw returns the current debug raw setting (thread-safe).
    63→func getWatcherDebugRaw() bool {
    64→	watcherMutex.RLock()
    65→	defer watcherMutex.RUnlock()
    66→	return watcherDebugRaw
    67→}
    68→
    69→// StopWatcher gracefully stops the watcher goroutine.
    70→func StopWatcher() {
    71→	slog.Info("StopWatcher: Signaling watcher to stop")
    72→	watcherCancel()
    73→	slog.Info("StopWatcher: Waiting for watcher goroutine to finish")
    74→	watcherWg.Wait()
    75→	slog.Info("StopWatcher: Watcher stopped")
    76→}
    77→
    78→// WatchForCodexSessions watches for Codex CLI sessions that match the given project path.
    79→// If resumeSessionID is provided, it finds and watches the directory containing that session.
    80→// Otherwise, watches hierarchically for new sessions, handling date changes across days/months/years.
    81→func WatchForCodexSessions(projectPath string, resumeSessionID string) error {
    82→	slog.Info("WatchForCodexSessions: Starting Codex session watcher",
    83→		"projectPath", projectPath,
    84→		"resumeSessionID", resumeSessionID)
    85→
    86→	homeDir, err := osUserHomeDir()
    87→	if err != nil {
    88→		slog.Error("WatchForCodexSessions: Failed to get home directory", "error", err)
    89→		return fmt.Errorf("failed to get home directory: %w", err)
    90→	}
    91→
    92→	sessionsRoot := codexSessionsRoot(homeDir)
    93→	slog.Info("WatchForCodexSessions: Sessions root", "path", sessionsRoot)
    94→
    95→	var initialDayDir string
    96→
    97→	if resumeSessionID != "" {
    98→		// Find the directory containing the resumed session
    99→		slog.Info("WatchForCodexSessions: Finding directory for resumed session", "sessionID", resumeSessionID)
   100→
   101→		// Use findCodexSessions to locate the specific session (will short-circuit when found)
   102→		sessions, err := findCodexSessions(projectPath, resumeSessionID, false)
   103→		if err != nil {
   104→			slog.Error("WatchForCodexSessions: Failed to find resumed session", "error", err)
   105→			return fmt.Errorf("failed to find resumed session: %w", err)
   106→		}
   107→
   108→		// Check if session was found
   109→		if len(sessions) == 0 {
   110→			slog.Error("WatchForCodexSessions: Resumed session not found", "sessionID", resumeSessionID)
   111→			return fmt.Errorf("resumed session %s not found", resumeSessionID)
   112→		}
   113→
   114→		// Get the directory containing the session file
   115→		initialDayDir = filepath.Dir(sessions[0].SessionPath)
   116→		slog.Info("WatchForCodexSessions: Found resumed session directory", "path", initialDayDir)
   117→	} else {
   118→		// Calculate today's directory (will be watched along with hierarchical watching)
   119→		now := time.Now()
   120→		initialDayDir = filepath.Join(sessionsRoot, fmt.Sprintf("%04d", now.Year()), fmt.Sprintf("%02d", now.Month()), fmt.Sprintf("%02d", now.Day()))
   121→		slog.Info("WatchForCodexSessions: Initial day directory", "path", initialDayDir)
   122→	}
   123→
   124→	return startCodexSessionWatcher(projectPath, sessionsRoot, initialDayDir)
   125→}
   126→
   127→// dirType determines the type of directory relative to sessionsRoot based on the
   128→// YYYY/MM/DD structure. Returns "year", "month", "day", or "" if not a recognized type.
   129→func dirType(path string, sessionsRoot string) string {
   130→	rel, err := filepath.Rel(sessionsRoot, path)
   131→	if err != nil || strings.HasPrefix(rel, "..") {
   132→		return "" // Path is not under sessionsRoot
   133→	}
   134→
   135→	parts := strings.Split(filepath.ToSlash(rel), "/")
   136→	switch len(parts) {
   137→	case 1: // YYYY
   138→		if len(parts[0]) == 4 {
   139→			return "year"
   140→		}
   141→	case 2: // YYYY/MM
   142→		if len(parts[0]) == 4 && len(parts[1]) == 2 {
   143→			return "month"
   144→		}
   145→	case 3: // YYYY/MM/DD
   146→		if len(parts[0]) == 4 && len(parts[1]) == 2 && len(parts[2]) == 2 {
   147→			return "day"
   148→		}
   149→	}
   150→	return ""
   151→}
   152→
   153→// startCodexSessionWatcher starts watching hierarchically for Codex sessions.
   154→// Watches sessionsRoot/YYYY/MM/DD/ structure to handle date changes across days, months, and years.
   155→// The initialDayDir is scanned immediately if it exists.
   156→func startCodexSessionWatcher(projectPath string, sessionsRoot string, initialDayDir string) error {
   157→	slog.Info("startCodexSessionWatcher: Creating hierarchical watcher",
   158→		"sessionsRoot", sessionsRoot,
   159→		"initialDayDir", initialDayDir)
   160→
   161→	// Create a new watcher
   162→	watcher, err := fsnotify.NewWatcher()
   163→	if err != nil {
   164→		return fmt.Errorf("failed to create file watcher: %v", err)
   165→	}
   166→
   167→	// Increment wait group before starting goroutine
   168→	watcherWg.Add(1)
   169→
   170→	// Start watching in a goroutine
   171→	go func() {
   172→		// Decrement wait group when done
   173→		defer watcherWg.Done()
   174→
   175→		// Log when goroutine starts
   176→		slog.Info("startCodexSessionWatcher: Goroutine started")
   177→
   178→		// Defer cleanup
   179→		defer func() {
   180→			slog.Info("startCodexSessionWatcher: Goroutine exiting, closing watcher")
   181→			if err := watcher.Close(); err != nil {
   182→				slog.Debug("startCodexSessionWatcher: Error closing watcher", "error", err)
   183→			}
   184→		}()
   185→
   186→		// Track which directories are being watched to avoid duplicates
   187→		watchedDirs := make(map[string]bool)
   188→		var watchedDirsMutex sync.Mutex
   189→
   190→		// Helper to add a directory to watcher if not already watched
   191→		addWatch := func(dir string) error {
   192→			watchedDirsMutex.Lock()
   193→			defer watchedDirsMutex.Unlock()
   194→
   195→			if watchedDirs[dir] {
   196→				return nil // Already watching
   197→			}
   198→
   199→			if err := watcher.Add(dir); err != nil {
   200→				return err
   201→			}
   202→			watchedDirs[dir] = true
   203→			slog.Info("startCodexSessionWatcher: Added watch", "directory", dir)
   204→			return nil
   205→		}
   206→
   207→		// Helper to scan a day directory for existing sessions
   208→		scanDayDir := func(dayDir string) {
   209→			if _, err := os.Stat(dayDir); err == nil {
   210→				slog.Info("startCodexSessionWatcher: Scanning day directory", "directory", dayDir)
   211→				ScanCodexSessions(projectPath, dayDir, nil)
   212→			}
   213→		}
   214→
   215→		// Helper to watch a day directory and scan it
   216→		watchDayDir := func(dayDir string) {
   217→			if err := addWatch(dayDir); err != nil {
   218→				slog.Error("startCodexSessionWatcher: Failed to watch day directory",
   219→					"directory", dayDir,
   220→					"error", err)
   221→				return
   222→			}
   223→			scanDayDir(dayDir)
   224→		}
   225→
   226→		// Helper to watch a month directory and its existing day directories
   227→		watchMonthDir := func(monthDir string) {
   228→			if err := addWatch(monthDir); err != nil {
   229→				slog.Error("startCodexSessionWatcher: Failed to watch month directory",
   230→					"directory", monthDir,
   231→					"error", err)
   232→				return
   233→			}
   234→
   235→			// Scan for existing day directories
   236→			entries, err := os.ReadDir(monthDir)
   237→			if err != nil {
   238→				slog.Debug("startCodexSessionWatcher: Cannot read month directory",
   239→					"directory", monthDir,
   240→					"error", err)
   241→				return
   242→			}
   243→
   244→			for _, entry := range entries {
   245→				if !entry.IsDir() {
   246→					continue
   247→				}
   248→				// Day directories are named 01-31
   249→				if len(entry.Name()) == 2 {
   250→					dayDir := filepath.Join(monthDir, entry.Name())
   251→					watchDayDir(dayDir)
   252→				}
   253→			}
   254→		}
   255→
   256→		// Helper to watch a year directory and its existing month directories
   257→		watchYearDir := func(yearDir string) {
   258→			if err := addWatch(yearDir); err != nil {
   259→				slog.Error("startCodexSessionWatcher: Failed to watch year directory",
   260→					"directory", yearDir,
   261→					"error", err)
   262→				return
   263→			}
   264→
   265→			// Scan for existing month directories
   266→			entries, err := os.ReadDir(yearDir)
   267→			if err != nil {
   268→				slog.Debug("startCodexSessionWatcher: Cannot read year directory",
   269→					"directory", yearDir,
   270→					"error", err)
   271→				return
   272→			}
   273→
   274→			for _, entry := range entries {
   275→				if !entry.IsDir() {
   276→					continue
   277→				}
   278→				// Month directories are named 01-12
   279→				if len(entry.Name()) == 2 {
   280→					monthDir := filepath.Join(yearDir, entry.Name())
   281→					watchMonthDir(monthDir)
   282→				}
   283→			}
   284→		}
   285→
   286→		// Watch sessions root for year directories
   287→		if err := addWatch(sessionsRoot); err != nil {
   288→			log.UserError("Error watching sessions root: %v", err)
   289→			slog.Error("startCodexSessionWatcher: Failed to watch sessions root", "error", err)
   290→			return
   291→		}
   292→
   293→		// Scan for existing year directories
   294→		entries, err := os.ReadDir(sessionsRoot)
   295→		if err != nil {
   296→			slog.Warn("startCodexSessionWatcher: Cannot read sessions root",
   297→				"directory", sessionsRoot,
   298→				"error", err)
   299→		} else {
   300→			for _, entry := range entries {
   301→				if !entry.IsDir() {
   302→					continue
   303→				}
   304→				// Year directories are named YYYY (4 digits)
   305→				if len(entry.Name()) == 4 {
   306→					yearDir := filepath.Join(sessionsRoot, entry.Name())
   307→					watchYearDir(yearDir)
   308→				}
   309→			}
   310→		}
   311→
   312→		// Scan the initial day directory if it exists
   313→		scanDayDir(initialDayDir)
   314→
   315→		// Watch for events
   316→		slog.Info("startCodexSessionWatcher: Now watching for file and directory events")
   317→		for {
   318→			select {
   319→			case <-watcherCtx.Done():
   320→				slog.Info("startCodexSessionWatcher: Context cancelled, stopping watcher")
   321→				return
   322→
   323→			case event, ok := <-watcher.Events:
   324→				if !ok {
   325→					slog.Info("startCodexSessionWatcher: Watcher events channel closed")
   326→					return
   327→				}
   328→
   329→				if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) && !event.Has(fsnotify.Remove) {
   330→					continue
   331→				}
   332→
   333→				// Determine what type of path this is
   334→				eventPath := event.Name
   335→				parentDir := filepath.Dir(eventPath)
   336→
   337→				// Check if this is a JSONL file (in a day directory)
   338→				if strings.HasSuffix(eventPath, ".jsonl") {
   339→					switch {
   340→					case event.Has(fsnotify.Create), event.Has(fsnotify.Write):
   341→						slog.Info("startCodexSessionWatcher: JSONL file event",
   342→							"operation", event.Op.String(),
   343→							"file", eventPath)
   344→						ScanCodexSessions(projectPath, parentDir, &eventPath)
   345→					case event.Has(fsnotify.Remove):
   346→						slog.Info("startCodexSessionWatcher: JSONL file removed", "file", eventPath)
   347→						ScanCodexSessions(projectPath, parentDir, nil)
   348→					}
   349→					continue
   350→				}
   351→
   352→				// Check if this is a directory creation
   353→				if event.Has(fsnotify.Create) {
   354→					switch dirType(eventPath, sessionsRoot) {
   355→					case "year":
   356→						slog.Info("startCodexSessionWatcher: New year directory created", "directory", eventPath)
   357→						watchYearDir(eventPath)
   358→					case "month":
   359→						slog.Info("startCodexSessionWatcher: New month directory created", "directory", eventPath)
   360→						watchMonthDir(eventPath)
   361→					case "day":
   362→						slog.Info("startCodexSessionWatcher: New day directory created", "directory", eventPath)
   363→						watchDayDir(eventPath)
   364→					}
   365→				}
   366→
   367→			case err, ok := <-watcher.Errors:
   368→				if !ok {
   369→					slog.Info("startCodexSessionWatcher: Watcher errors channel closed")
   370→					return
   371→				}
   372→				log.UserWarn("Watcher error: %v", err)
   373→				slog.Error("startCodexSessionWatcher: Watcher error", "error", err)
   374→			}
   375→		}
   376→	}()
   377→
   378→	return nil
   379→}
   380→
   381→// ScanCodexSessions scans JSONL files in the session directory and processes sessions
   382→// that match the project path. If changedFile is nil, scans all JSONL files in the directory.
   383→// If changedFile is non-nil, only processes that specific file.
   384→func ScanCodexSessions(projectPath string, sessionDir string, changedFile *string) {
   385→	// Ensure logs are flushed even if we panic
   386→	defer func() {
   387→		if r := recover(); r != nil {
   388→			log.UserWarn("PANIC in ScanCodexSessions: %v", r)
   389→			slog.Error("ScanCodexSessions: PANIC recovered", "panic", r)
   390→		}
   391→	}()
   392→
   393→	slog.Info("ScanCodexSessions: === START SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   394→	if changedFile != nil {
   395→		slog.Info("ScanCodexSessions: Scanning with changed file",
   396→			"projectPath", projectPath,
   397→			"sessionDir", sessionDir,
   398→			"changedFile", *changedFile)
   399→	} else {
   400→		slog.Info("ScanCodexSessions: Scanning all sessions",
   401→			"projectPath", projectPath,
   402→			"sessionDir", sessionDir)
   403→	}
   404→
   405→	// Get the session callback
   406→	callback := getWatcherCallback()
   407→	if callback == nil {
   408→		slog.Error("ScanCodexSessions: No callback provided - this should not happen")
   409→		return
   410→	}
   411→
   412→	// Normalize project path for comparison
   413→	normalizedProjectPath := normalizeCodexPath(projectPath)
   414→	if normalizedProjectPath == "" {
   415→		slog.Debug("ScanCodexSessions: Unable to normalize project path", "projectPath", projectPath)
   416→	}
   417→
   418→	// If we have a specific changed file, only process that file
   419→	if changedFile != nil {
   420→		if err := processCodexSessionFile(*changedFile, projectPath, normalizedProjectPath, callback); err != nil {
   421→			slog.Debug("ScanCodexSessions: Failed to process changed file",
   422→				"file", *changedFile,
   423→				"error", err)
   424→		}
   425→		slog.Info("ScanCodexSessions: === END SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   426→		return
   427→	}
   428→
   429→	// Otherwise, scan all JSONL files in the session directory
   430→	entries, err := os.ReadDir(sessionDir)
   431→	if err != nil {
   432→		slog.Error("ScanCodexSessions: Failed to read session directory",
   433→			"directory", sessionDir,
   434→			"error", err)
   435→		return
   436→	}
   437→
   438→	for _, entry := range entries {
   439→		if entry.IsDir() {
   440→			continue
   441→		}
   442→		if filepath.Ext(entry.Name()) != ".jsonl" {
   443→			continue
   444→		}
   445→
   446→		sessionPath := filepath.Join(sessionDir, entry.Name())
   447→		if err := processCodexSessionFile(sessionPath, projectPath, normalizedProjectPath, callback); err != nil {
   448→			slog.Debug("ScanCodexSessions: Failed to process session file",
   449→				"file", sessionPath,
   450→				"error", err)
   451→			// Continue processing other files even if one fails
   452→		}
   453→	}
   454→
   455→	slog.Info("ScanCodexSessions: Processing complete")
   456→	slog.Info("ScanCodexSessions: === END SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   457→}
   458→
   459→// processCodexSessionFile processes a single Codex session file and calls the callback
   460→// if the session matches the project path.
   461→func processCodexSessionFile(sessionPath string, projectPath string, normalizedProjectPath string, callback func(*spi.AgentChatSession)) error {
   462→	// Load session metadata
   463→	meta, err := loadCodexSessionMeta(sessionPath)
   464→	if err != nil {
   465→		return fmt.Errorf("failed to load session meta: %w", err)
   466→	}
   467→
   468→	// Check if session matches project path
   469→	sessionID := strings.TrimSpace(meta.Payload.ID)
   470→	normalizedCWD := normalizeCodexPath(meta.Payload.CWD)
   471→	if normalizedCWD == "" {
   472→		slog.Debug("processCodexSessionFile: Session meta missing cwd", "sessionID", sessionID, "path", sessionPath)
   473→		return fmt.Errorf("session meta missing cwd")
   474→	}
   475→
   476→	// Check if this session matches the project path
   477→	matched := false
   478→	if normalizedProjectPath != "" {
   479→		if normalizedCWD == normalizedProjectPath || strings.EqualFold(normalizedCWD, normalizedProjectPath) {
   480→			matched = true
   481→		}
   482→	} else if normalizedCWD == projectPath || strings.EqualFold(normalizedCWD, projectPath) {
   483→		matched = true
   484→	}
   485→
   486→	if !matched {
   487→		slog.Debug("processCodexSessionFile: Session does not match project path",
   488→			"sessionID", sessionID,
   489→			"sessionCWD", normalizedCWD,
   490→			"projectPath", normalizedProjectPath)
   491→		return nil // Not an error, just doesn't match
   492→	}
   493→
   494→	slog.Info("processCodexSessionFile: Session matched project",
   495→		"sessionID", sessionID,
   496→		"sessionPath", sessionPath)
   497→
   498→	// Create session info
   499→	sessionInfo := &codexSessionInfo{
   500→		SessionID:   sessionID,
   501→		SessionPath: sessionPath,
   502→		Meta:        meta,
   503→	}
   504→
   505→	// Process the session
   506→	agentSession, err := processSessionToAgentChat(sessionInfo, projectPath, getWatcherDebugRaw())
   507→	if err != nil {
   508→		return fmt.Errorf("failed to process session: %w", err)
   509→	}
   510→
   511→	// Skip empty sessions
   512→	if agentSession == nil {
   513→		slog.Debug("processCodexSessionFile: Skipping empty session", "sessionID", sessionID)
   514→		return nil
   515→	}
   516→
   517→	// Skip sessions without user message (empty slug)
   518→	if agentSession.Slug == "" {
   519→		slog.Debug("processCodexSessionFile: Skipping session without user message",
   520→			"sessionID", agentSession.SessionID)
   521→		return nil
   522→	}
   523→
   524→	slog.Info("processCodexSessionFile: Calling callback for session", "sessionID", agentSession.SessionID)
   525→	// Call the callback in a goroutine to avoid blocking
   526→	go func(s *spi.AgentChatSession) {
   527→		defer func() {
   528→			if r := recover(); r != nil {
   529→				slog.Error("processCodexSessionFile: Callback panicked", "panic", r)
   530→			}
   531→		}()
   532→		callback(s)
   533→	}(agentSession)
   534→
   535→	return nil
   536→}
   537→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/agent_session.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"encoding/json"
     5→	"fmt"
     6→	"path/filepath"
     7→	"strings"
     8→
     9→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/schema"
    10→)
    11→
    12→type (
    13→	SessionData  = schema.SessionData
    14→	ProviderInfo = schema.ProviderInfo
    15→	Exchange     = schema.Exchange
    16→	Message      = schema.Message
    17→	ContentPart  = schema.ContentPart
    18→	ToolInfo     = schema.ToolInfo
    19→)
    20→
    21→// GenerateAgentSession converts an fdSession into the shared SessionData schema.
    22→func GenerateAgentSession(session *fdSession, workspaceRoot string) (*SessionData, error) {
    23→	if session == nil {
    24→		return nil, fmt.Errorf("session is nil")
    25→	}
    26→
    27→	workspaceRoot = strings.TrimSpace(workspaceRoot)
    28→	if sessionRoot := strings.TrimSpace(session.WorkspaceRoot); sessionRoot != "" {
    29→		workspaceRoot = sessionRoot
    30→	}
    31→
    32→	exchanges, lastTimestamp := buildExchanges(session, workspaceRoot)
    33→	if len(exchanges) == 0 {
    34→		return nil, fmt.Errorf("session contains no conversational exchanges")
    35→	}
    36→
    37→	for idx := range exchanges {
    38→		exchanges[idx].ExchangeID = fmt.Sprintf("%s:%d", session.ID, idx)
    39→		ensureExchangeTimestamps(&exchanges[idx])
    40→	}
    41→
    42→	created := strings.TrimSpace(session.CreatedAt)
    43→	if created == "" {
    44→		created = exchanges[0].StartTime
    45→	}
    46→	if created == "" {
    47→		created = lastTimestamp
    48→	}
    49→
    50→	updated := strings.TrimSpace(lastTimestamp)
    51→	if updated == "" {
    52→		updated = created
    53→	}
    54→
    55→	data := &SessionData{
    56→		SchemaVersion: "1.0",
    57→		Provider: ProviderInfo{
    58→			ID:      "droid-cli",
    59→			Name:    "Factory Droid CLI",
    60→			Version: "unknown",
    61→		},
    62→		SessionID:     session.ID,
    63→		CreatedAt:     created,
    64→		UpdatedAt:     updated,
    65→		Slug:          session.Slug,
    66→		WorkspaceRoot: workspaceRoot,
    67→		Exchanges:     exchanges,
    68→	}
    69→
    70→	return data, nil
    71→}
    72→
    73→func buildExchanges(session *fdSession, workspaceRoot string) ([]Exchange, string) {
    74→	var exchanges []Exchange
    75→	var current *Exchange
    76→	var lastTimestamp string
    77→	lastBlockWasUser := false
    78→
    79→	flush := func() {
    80→		if current == nil {
    81→			return
    82→		}
    83→		if len(current.Messages) > 0 {
    84→			if current.StartTime == "" {
    85→				current.StartTime = current.Messages[0].Timestamp
    86→			}
    87→			if current.EndTime == "" {
    88→				current.EndTime = current.Messages[len(current.Messages)-1].Timestamp
    89→			}
    90→			exchanges = append(exchanges, *current)
    91→		}
    92→		current = nil
    93→		lastBlockWasUser = false
    94→	}
    95→
    96→	appendMessage := func(msg Message, timestamp string) {
    97→		if current == nil {
    98→			current = &Exchange{StartTime: timestamp}
    99→		}
   100→		current.Messages = append(current.Messages, msg)
   101→		if timestamp != "" {
   102→			current.EndTime = timestamp
   103→		}
   104→	}
   105→
   106→	for _, block := range session.Blocks {
   107→		ts := strings.TrimSpace(block.Timestamp)
   108→		if ts != "" {
   109→			lastTimestamp = ts
   110→		}
   111→
   112→		if isUserBlock(block) {
   113→			text := cleanUserText(block.Text)
   114→			if text == "" {
   115→				continue
   116→			}
   117→			if !lastBlockWasUser {
   118→				flush()
   119→				current = &Exchange{StartTime: ts}
   120→			}
   121→			msg := Message{
   122→				ID:        strings.TrimSpace(block.MessageID),
   123→				Timestamp: ts,
   124→				Role:      "user",
   125→				Content: []ContentPart{
   126→					{Type: "text", Text: text},
   127→				},
   128→			}
   129→			appendMessage(msg, ts)
   130→			lastBlockWasUser = true
   131→			continue
   132→		}
   133→
   134→		if current == nil {
   135→			current = &Exchange{StartTime: ts}
   136→		}
   137→		lastBlockWasUser = false
   138→
   139→		switch block.Kind {
   140→		case blockText:
   141→			if msg := buildAgentTextMessage(block); msg != nil {
   142→				appendMessage(*msg, ts)
   143→			}
   144→		case blockTool:
   145→			if msg := buildToolMessage(block, workspaceRoot); msg != nil {
   146→				appendMessage(*msg, ts)
   147→			}
   148→		case blockTodo:
   149→			if msg := buildTodoMessage(block); msg != nil {
   150→				appendMessage(*msg, ts)
   151→			}
   152→		case blockSummary:
   153→			if msg := buildSummaryMessage(block); msg != nil {
   154→				appendMessage(*msg, ts)
   155→			}
   156→		}
   157→	}
   158→
   159→	flush()
   160→	return exchanges, lastTimestamp
   161→}
   162→
   163→func ensureExchangeTimestamps(ex *Exchange) {
   164→	if ex.StartTime == "" && len(ex.Messages) > 0 {
   165→		ex.StartTime = ex.Messages[0].Timestamp
   166→	}
   167→	if ex.EndTime == "" && len(ex.Messages) > 0 {
   168→		ex.EndTime = ex.Messages[len(ex.Messages)-1].Timestamp
   169→	}
   170→}
   171→
   172→func isUserBlock(block fdBlock) bool {
   173→	return block.Kind == blockText && strings.EqualFold(strings.TrimSpace(block.Role), "user")
   174→}
   175→
   176→func buildAgentTextMessage(block fdBlock) *Message {
   177→	text := strings.TrimSpace(block.Text)
   178→	if text == "" {
   179→		return nil
   180→	}
   181→	partType := "text"
   182→	if block.IsReasoning {
   183→		partType = "thinking"
   184→	}
   185→	return &Message{
   186→		ID:        strings.TrimSpace(block.MessageID),
   187→		Timestamp: strings.TrimSpace(block.Timestamp),
   188→		Role:      "agent",
   189→		Model:     strings.TrimSpace(block.Model),
   190→		Content: []ContentPart{
   191→			{Type: partType, Text: text},
   192→		},
   193→	}
   194→}
   195→
   196→func buildToolMessage(block fdBlock, workspaceRoot string) *Message {
   197→	if block.Tool == nil {
   198→		return nil
   199→	}
   200→	toolInfo := convertToolCallToInfo(block.Tool)
   201→	if toolInfo == nil {
   202→		return nil
   203→	}
   204→	formatted := formatToolCall(block.Tool)
   205→	if formatted != "" {
   206→		toolInfo.FormattedMarkdown = &formatted
   207→	}
   208→	toolInfo.Type = toolType(toolInfo.Name)
   209→	if toolInfo.Output != nil {
   210→		if content, ok := toolInfo.Output["content"].(string); ok {
   211→			toolInfo.Output["content"] = strings.TrimSpace(content)
   212→		}
   213→	}
   214→	pathHints := extractPathHints(toolInfo.Input, workspaceRoot)
   215→	return &Message{
   216→		ID:        strings.TrimSpace(block.MessageID),
   217→		Timestamp: strings.TrimSpace(block.Timestamp),
   218→		Role:      "agent",
   219→		Model:     strings.TrimSpace(block.Model),
   220→		Tool:      toolInfo,
   221→		PathHints: pathHints,
   222→	}
   223→}
   224→
   225→func buildTodoMessage(block fdBlock) *Message {
   226→	if block.Todo == nil || len(block.Todo.Items) == 0 {
   227→		return nil
   228→	}
   229→	formatted := formatTodoUpdate(block.Todo)
   230→	input := map[string]interface{}{
   231→		"items": todoItemsToMap(block.Todo.Items),
   232→	}
   233→	tool := &ToolInfo{
   234→		Name:  "todo_state",
   235→		Type:  "task",
   236→		UseID: fmt.Sprintf("todo_%s", strings.ReplaceAll(block.Timestamp, ":", "")),
   237→		Input: input,
   238→	}
   239→	if formatted != "" {
   240→		tool.FormattedMarkdown = &formatted
   241→	}
   242→	return &Message{
   243→		ID:        strings.TrimSpace(block.MessageID),
   244→		Timestamp: strings.TrimSpace(block.Timestamp),
   245→		Role:      "agent",
   246→		Tool:      tool,
   247→	}
   248→}
   249→
   250→func buildSummaryMessage(block fdBlock) *Message {
   251→	if block.Summary == nil {
   252→		return nil
   253→	}
   254→	body := strings.TrimSpace(block.Summary.Body)
   255→	if body == "" {
   256→		return nil
   257→	}
   258→	title := strings.TrimSpace(block.Summary.Title)
   259→	if title == "" {
   260→		title = "Summary"
   261→	}
   262→	text := fmt.Sprintf("**%s**\n\n%s", title, body)
   263→	return &Message{
   264→		ID:        strings.TrimSpace(block.MessageID),
   265→		Timestamp: strings.TrimSpace(block.Timestamp),
   266→		Role:      "agent",
   267→		Content: []ContentPart{
   268→			{Type: "thinking", Text: text},
   269→		},
   270→	}
   271→}
   272→
   273→func convertToolCallToInfo(call *fdToolCall) *ToolInfo {
   274→	if call == nil {
   275→		return nil
   276→	}
   277→	name := strings.TrimSpace(call.Name)
   278→	if name == "" {
   279→		name = "tool"
   280→	}
   281→	useID := strings.TrimSpace(call.ID)
   282→	if useID == "" {
   283→		useID = fmt.Sprintf("tool-%s", strings.ReplaceAll(call.InvocationAt, ":", ""))
   284→	}
   285→	args := decodeInput(call.Input)
   286→	var output map[string]interface{}
   287→	if call.Result != nil {
   288→		content := strings.TrimSpace(call.Result.Content)
   289→		if content != "" || call.Result.IsError {
   290→			output = map[string]interface{}{
   291→				"content": content,
   292→				"isError": call.Result.IsError,
   293→			}
   294→		}
   295→	}
   296→	tool := &ToolInfo{
   297→		Name:   name,
   298→		Type:   toolType(name),
   299→		UseID:  useID,
   300→		Input:  args,
   301→		Output: output,
   302→	}
   303→	if call.RiskLevel != "" {
   304→		summary := fmt.Sprintf("Risk level: %s", call.RiskLevel)
   305→		if strings.TrimSpace(call.RiskReason) != "" {
   306→			summary = fmt.Sprintf("%s — %s", summary, strings.TrimSpace(call.RiskReason))
   307→		}
   308→		tool.Summary = &summary
   309→	}
   310→	return tool
   311→}
   312→
   313→func todoItemsToMap(items []fdTodoItem) []map[string]interface{} {
   314→	result := make([]map[string]interface{}, 0, len(items))
   315→	for _, item := range items {
   316→		result = append(result, map[string]interface{}{
   317→			"description": strings.TrimSpace(item.Description),
   318→			"status":      strings.TrimSpace(item.Status),
   319→		})
   320→	}
   321→	return result
   322→}
   323→
   324→func extractPathHints(input map[string]interface{}, workspaceRoot string) []string {
   325→	fields := []string{"path", "file_path", "filePath", "dir", "directory",
   326→		"workdir", "cwd", "target"}
   327→	var hints []string
   328→	if input == nil {
   329→		return hints
   330→	}
   331→	for _, field := range fields {
   332→		val, ok := input[field]
   333→		if !ok {
   334→			continue
   335→		}
   336→		switch v := val.(type) {
   337→		case string:
   338→			addPathHint(&hints, v, workspaceRoot)
   339→		case []interface{}:
   340→			for _, entry := range v {
   341→				if s, ok := entry.(string); ok {
   342→					addPathHint(&hints, s, workspaceRoot)
   343→				}
   344→			}
   345→		case json.Number:
   346→			addPathHint(&hints, v.String(), workspaceRoot)
   347→		}
   348→	}
   349→	return hints
   350→}
   351→
   352→func addPathHint(hints *[]string, value string, workspaceRoot string) {
   353→	value = strings.TrimSpace(value)
   354→	if value == "" {
   355→		return
   356→	}
   357→	normalized := normalizeWorkspacePath(value, workspaceRoot)
   358→	for _, existing := range *hints {
   359→		if existing == normalized {
   360→			return
   361→		}
   362→	}
   363→	*hints = append(*hints, normalized)
   364→}
   365→
   366→func normalizeWorkspacePath(path string, workspaceRoot string) string {
   367→	if workspaceRoot == "" {
   368→		return path
   369→	}
   370→	if filepath.IsAbs(path) {
   371→		if rel, err := filepath.Rel(workspaceRoot, path); err == nil {
   372→			rel = filepath.Clean(rel)
   373→			if rel == "." {
   374→				return "."
   375→			}
   376→			if !strings.HasPrefix(rel, "..") {
   377→				return rel
   378→			}
   379→		}
   380→	}
   381→	return path
   382→}
   383→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:49Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/geminicli/watcher.go`
```
     1→package geminicli
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"os"
     8→	"path/filepath"
     9→	"strings"
    10→	"sync"
    11→	"time"
    12→
    13→	"github.com/fsnotify/fsnotify"
    14→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    15→)
    16→
    17→var (
    18→	watcherCtx           context.Context
    19→	watcherCancel        context.CancelFunc
    20→	watcherWg            sync.WaitGroup
    21→	watcherCallback      func(*spi.AgentChatSession)
    22→	watcherMutex         sync.RWMutex
    23→	watcherDebugRaw      bool
    24→	watcherWorkspaceRoot string
    25→)
    26→
    27→const (
    28→	initialBackoff = 1 * time.Second
    29→	maxBackoff     = 30 * time.Second
    30→)
    31→
    32→func init() {
    33→	watcherCtx, watcherCancel = context.WithCancel(context.Background())
    34→}
    35→
    36→func SetWatcherCallback(callback func(*spi.AgentChatSession)) {
    37→	watcherMutex.Lock()
    38→	defer watcherMutex.Unlock()
    39→	watcherCallback = callback
    40→}
    41→
    42→func SetWatcherDebugRaw(debugRaw bool) {
    43→	watcherMutex.Lock()
    44→	defer watcherMutex.Unlock()
    45→	watcherDebugRaw = debugRaw
    46→}
    47→
    48→func SetWatcherWorkspaceRoot(workspaceRoot string) {
    49→	watcherMutex.Lock()
    50→	defer watcherMutex.Unlock()
    51→	watcherWorkspaceRoot = workspaceRoot
    52→}
    53→
    54→func getWatcherWorkspaceRoot() string {
    55→	watcherMutex.RLock()
    56→	defer watcherMutex.RUnlock()
    57→	return watcherWorkspaceRoot
    58→}
    59→
    60→func getWatcherDebugRaw() bool {
    61→	watcherMutex.RLock()
    62→	defer watcherMutex.RUnlock()
    63→	return watcherDebugRaw
    64→}
    65→
    66→func StopWatcher() {
    67→	watcherCancel()
    68→	watcherWg.Wait()
    69→}
    70→
    71→func WatchGeminiProject(projectPath string, callback func(*spi.AgentChatSession)) error {
    72→	SetWatcherCallback(callback)
    73→	SetWatcherWorkspaceRoot(projectPath)
    74→
    75→	projectDir, err := GetGeminiProjectDir(projectPath)
    76→	if err != nil {
    77→		return fmt.Errorf("failed to get gemini project dir: %w", err)
    78→	}
    79→
    80→	tmpDir := filepath.Dir(projectDir)
    81→	chatsDir := filepath.Join(projectDir, "chats")
    82→
    83→	watcherWg.Add(1)
    84→	go func() {
    85→		defer watcherWg.Done()
    86→
    87→		if err := waitForDirectory(watcherCtx, tmpDir, "Gemini tmp directory"); err != nil {
    88→			slog.Warn("Stopped Gemini watcher while waiting for tmp directory", "error", err)
    89→			return
    90→		}
    91→
    92→		if err := waitForDirectory(watcherCtx, projectDir, "Gemini project directory"); err != nil {
    93→			slog.Warn("Stopped Gemini watcher while waiting for project directory", "error", err)
    94→			return
    95→		}
    96→
    97→		if err := waitForDirectory(watcherCtx, chatsDir, "Gemini chats directory"); err != nil {
    98→			slog.Warn("Stopped Gemini watcher while waiting for chats directory", "error", err)
    99→			return
   100→		}
   101→
   102→		if err := startChatsWatcher(chatsDir); err != nil {
   103→			slog.Error("Failed to start chats watcher", "error", err)
   104→		}
   105→
   106→		if err := startArtifactWatcher(filepath.Join(projectDir, "logs.json"), "logs.json"); err != nil {
   107→			slog.Warn("Failed to watch logs.json", "error", err)
   108→		}
   109→
   110→		if err := startArtifactWatcher(filepath.Join(projectDir, "shell_history"), "shell_history"); err != nil {
   111→			slog.Warn("Failed to watch shell_history", "error", err)
   112→		}
   113→	}()
   114→
   115→	return nil
   116→}
   117→
   118→func startChatsWatcher(chatsDir string) error {
   119→	watcher, err := fsnotify.NewWatcher()
   120→	if err != nil {
   121→		return err
   122→	}
   123→
   124→	watcherWg.Add(1)
   125→	go func() {
   126→		defer watcherWg.Done()
   127→		defer func() {
   128→			_ = watcher.Close()
   129→		}()
   130→
   131→		if err := watcher.Add(chatsDir); err != nil {
   132→			slog.Error("Failed to add chats dir to watcher", "error", err)
   133→			return
   134→		}
   135→
   136→		for {
   137→			select {
   138→			case <-watcherCtx.Done():
   139→				return
   140→			case event, ok := <-watcher.Events:
   141→				if !ok {
   142→					return
   143→				}
   144→				if strings.HasSuffix(event.Name, ".json") && (event.Has(fsnotify.Write) || event.Has(fsnotify.Create)) {
   145→					processSessionChange(event.Name)
   146→				}
   147→			case err, ok := <-watcher.Errors:
   148→				if !ok {
   149→					return
   150→				}
   151→				slog.Error("Watcher error", "error", err)
   152→			}
   153→		}
   154→	}()
   155→
   156→	return nil
   157→}
   158→
   159→func processSessionChange(filePath string) {
   160→	slog.Debug("processSessionChange: Detected session file change", "file", filePath)
   161→
   162→	// Extract short session ID from filename to find related files
   163→	filename := filepath.Base(filePath)
   164→	shortID := extractSessionIDFromFilename(filename)
   165→	if shortID == "" {
   166→		slog.Error("processSessionChange: Could not extract session ID from filename", "file", filename)
   167→		return
   168→	}
   169→
   170→	// Parse the changed file to get the full session ID
   171→	session, err := ParseSessionFile(filePath)
   172→	if err != nil {
   173→		slog.Error("processSessionChange: Failed to parse session file", "file", filePath, "error", err)
   174→		return
   175→	}
   176→
   177→	fullSessionID := session.ID
   178→
   179→	// Find all files for this session to merge them
   180→	// Why: Gemini CLI may have created multiple files for this session
   181→	chatsDir := filepath.Dir(filePath)
   182→	entries, err := os.ReadDir(chatsDir)
   183→	if err != nil {
   184→		slog.Error("processSessionChange: Failed to read chats directory", "dir", chatsDir, "error", err)
   185→		// Fall back to single-file session
   186→		agentSession := convertToAgentChatSession(session, getWatcherWorkspaceRoot(), getWatcherDebugRaw())
   187→		triggerCallback(agentSession)
   188→		return
   189→	}
   190→
   191→	// Collect all files that match this session's short ID
   192→	var sessionFiles []string
   193→	for _, entry := range entries {
   194→		if entry.IsDir() {
   195→			continue
   196→		}
   197→		if extractSessionIDFromFilename(entry.Name()) == shortID {
   198→			sessionFiles = append(sessionFiles, filepath.Join(chatsDir, entry.Name()))
   199→		}
   200→	}
   201→
   202→	slog.Debug("processSessionChange: Found session files to merge",
   203→		"shortID", shortID,
   204→		"fileCount", len(sessionFiles))
   205→
   206→	// Merge all files for this session
   207→	mergedSession, err := parseAndMergeSessionFiles(shortID, sessionFiles)
   208→	if err != nil {
   209→		slog.Error("processSessionChange: Failed to merge session files",
   210→			"sessionId", fullSessionID,
   211→			"fileCount", len(sessionFiles),
   212→			"error", err)
   213→		// Fall back to single-file session
   214→		agentSession := convertToAgentChatSession(session, getWatcherWorkspaceRoot(), getWatcherDebugRaw())
   215→		triggerCallback(agentSession)
   216→		return
   217→	}
   218→
   219→	slog.Info("processSessionChange: Successfully processed session change",
   220→		"sessionId", mergedSession.ID,
   221→		"fileCount", len(sessionFiles),
   222→		"messageCount", len(mergedSession.Messages),
   223→		"startTime", mergedSession.StartTime,
   224→		"lastUpdated", mergedSession.LastUpdated)
   225→
   226→	agentSession := convertToAgentChatSession(mergedSession, getWatcherWorkspaceRoot(), getWatcherDebugRaw())
   227→	triggerCallback(agentSession)
   228→}
   229→
   230→// triggerCallback is a helper to call the watcher callback with proper locking
   231→func triggerCallback(agentSession *spi.AgentChatSession) {
   232→	watcherMutex.RLock()
   233→	cb := watcherCallback
   234→	watcherMutex.RUnlock()
   235→
   236→	if cb != nil && agentSession != nil {
   237→		cb(agentSession)
   238→	}
   239→}
   240→
   241→func waitForDirectory(ctx context.Context, dir string, label string) error {
   242→	backoff := initialBackoff
   243→	for {
   244→		info, err := os.Stat(dir)
   245→		if err == nil && info.IsDir() {
   246→			slog.Info("Gemini watcher: directory ready", "label", label, "path", dir)
   247→			return nil
   248→		}
   249→		if err != nil && !os.IsNotExist(err) {
   250→			slog.Warn("Gemini watcher: failed to stat directory", "label", label, "path", dir, "error", err)
   251→		} else {
   252→			slog.Info("Gemini watcher: waiting for directory", "label", label, "path", dir, "retryIn", backoff)
   253→		}
   254→
   255→		select {
   256→		case <-ctx.Done():
   257→			return ctx.Err()
   258→		case <-time.After(backoff):
   259→			if backoff < maxBackoff {
   260→				backoff *= 2
   261→				if backoff > maxBackoff {
   262→					backoff = maxBackoff
   263→				}
   264→			}
   265→		}
   266→	}
   267→}
   268→
   269→func startArtifactWatcher(filePath string, label string) error {
   270→	dir := filepath.Dir(filePath)
   271→	watcher, err := fsnotify.NewWatcher()
   272→	if err != nil {
   273→		return err
   274→	}
   275→
   276→	if err := watcher.Add(dir); err != nil {
   277→		_ = watcher.Close()
   278→		return err
   279→	}
   280→
   281→	watcherWg.Add(1)
   282→	go func() {
   283→		defer watcherWg.Done()
   284→		defer func() {
   285→			_ = watcher.Close()
   286→		}()
   287→
   288→		slog.Info("Gemini watcher: monitoring artifact", "artifact", label, "path", filePath)
   289→
   290→		for {
   291→			select {
   292→			case <-watcherCtx.Done():
   293→				return
   294→			case event, ok := <-watcher.Events:
   295→				if !ok {
   296→					return
   297→				}
   298→				if filepath.Clean(event.Name) != filepath.Clean(filePath) {
   299→					continue
   300→				}
   301→				if event.Has(fsnotify.Write) || event.Has(fsnotify.Create) {
   302→					slog.Info("Gemini artifact updated", "artifact", label, "path", event.Name, "op", event.Op.String())
   303→				}
   304→			case err, ok := <-watcher.Errors:
   305→				if !ok {
   306→					return
   307→				}
   308→				slog.Warn("Gemini artifact watcher error", "artifact", label, "error", err)
   309→			}
   310→		}
   311→	}()
   312→
   313→	return nil
   314→}
   315→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:50Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/cursorcli/watcher.go`
```
     1→package cursorcli
     2→
     3→import (
     4→	"context"
     5→	"database/sql"
     6→	"encoding/json"
     7→	"fmt"
     8→	"log/slog"
     9→	"os"
    10→	"path/filepath"
    11→	"sync"
    12→	"time"
    13→
    14→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    15→	_ "modernc.org/sqlite" // Pure Go SQLite driver
    16→)
    17→
    18→// CursorWatcher monitors Cursor SQLite databases for changes
    19→type CursorWatcher struct {
    20→	projectPath     string
    21→	hashDir         string // The hash directory for this project
    22→	pollInterval    time.Duration
    23→	ctx             context.Context
    24→	cancel          context.CancelFunc
    25→	wg              sync.WaitGroup
    26→	callbackWg      sync.WaitGroup              // Track callback goroutines
    27→	lastCounts      map[string]int              // Track record counts per session
    28→	knownSessions   map[string]bool             // Sessions that existed at startup (don't process unless resumed)
    29→	resumedSession  string                      // Session ID being resumed (watch for changes)
    30→	sessionCallback func(*spi.AgentChatSession) // Callback for session updates
    31→	debugRaw        bool                        // Whether to write debug raw data files
    32→	mu              sync.RWMutex                // Protects maps
    33→}
    34→
    35→// NewCursorWatcher creates a new Cursor database watcher
    36→func NewCursorWatcher(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) (*CursorWatcher, error) {
    37→	// Get the project hash directory
    38→	hashDir, err := GetProjectHashDir(projectPath)
    39→	if err != nil {
    40→		return nil, fmt.Errorf("failed to get project hash directory: %w", err)
    41→	}
    42→
    43→	ctx, cancel := context.WithCancel(context.Background())
    44→
    45→	return &CursorWatcher{
    46→		projectPath:     projectPath,
    47→		hashDir:         hashDir,
    48→		pollInterval:    5 * time.Second, // 5-second polling interval
    49→		ctx:             ctx,
    50→		cancel:          cancel,
    51→		lastCounts:      make(map[string]int),
    52→		knownSessions:   make(map[string]bool),
    53→		resumedSession:  "",
    54→		sessionCallback: sessionCallback,
    55→		debugRaw:        debugRaw,
    56→	}, nil
    57→}
    58→
    59→// SetInitialState sets the sessions that existed at startup and which session is being resumed
    60→func (w *CursorWatcher) SetInitialState(existingSessionIDs map[string]bool, resumedSessionID string) {
    61→	w.mu.Lock()
    62→	defer w.mu.Unlock()
    63→	w.knownSessions = existingSessionIDs
    64→	w.resumedSession = resumedSessionID
    65→	if resumedSessionID != "" {
    66→		slog.Info("Watcher will monitor resumed session for changes", "sessionId", resumedSessionID)
    67→	}
    68→	slog.Debug("Watcher initialized with existing sessions", "count", len(existingSessionIDs))
    69→}
    70→
    71→// Start begins monitoring the Cursor databases
    72→func (w *CursorWatcher) Start() error {
    73→	slog.Info("Starting Cursor CLI watcher",
    74→		"projectPath", w.projectPath,
    75→		"hashDir", w.hashDir,
    76→		"pollInterval", w.pollInterval)
    77→
    78→	// Check if hash directory exists
    79→	stat, err := os.Stat(w.hashDir)
    80→	if err != nil {
    81→		if os.IsNotExist(err) {
    82→			slog.Info("Project hash directory doesn't exist yet, will watch for it", "hashDir", w.hashDir)
    83→		} else {
    84→			slog.Warn("Cannot access project hash directory", "hashDir", w.hashDir, "error", err)
    85→		}
    86→		// Start watching for the directory to be created
    87→		w.wg.Add(1)
    88→		go w.watchForDirectory()
    89→		return nil
    90→	}
    91→
    92→	// Log that we found the directory
    93→	slog.Info("Project hash directory exists", "hashDir", w.hashDir, "isDir", stat.IsDir())
    94→
    95→	// Directory exists, start watching sessions
    96→	w.wg.Add(1)
    97→	go w.watchLoop()
    98→
    99→	return nil
   100→}
   101→
   102→// Stop gracefully stops the watcher
   103→func (w *CursorWatcher) Stop() {
   104→	slog.Info("Stopping Cursor watcher")
   105→
   106→	// Perform one final check before stopping to catch any last-minute changes
   107→	slog.Info("Performing final check for changes before stopping")
   108→	w.checkForChanges()
   109→
   110→	// Now stop the watcher goroutines
   111→	w.cancel()
   112→	w.wg.Wait()
   113→
   114→	// Wait for any pending callback goroutines to complete
   115→	slog.Info("Waiting for pending callbacks to complete")
   116→	w.callbackWg.Wait()
   117→
   118→	slog.Info("Cursor watcher stopped")
   119→}
   120→
   121→// watchForDirectory waits for the project hash directory to be created
   122→func (w *CursorWatcher) watchForDirectory() {
   123→	defer w.wg.Done()
   124→
   125→	ticker := time.NewTicker(w.pollInterval)
   126→	defer ticker.Stop()
   127→
   128→	for {
   129→		select {
   130→		case <-w.ctx.Done():
   131→			return
   132→		case <-ticker.C:
   133→			// Check if directory now exists
   134→			if _, err := os.Stat(w.hashDir); err == nil {
   135→				slog.Info("Project hash directory detected, starting session watcher", "hashDir", w.hashDir)
   136→				// Directory exists now, start watching sessions
   137→				w.wg.Add(1)
   138→				go w.watchLoop()
   139→				return
   140→			}
   141→		}
   142→	}
   143→}
   144→
   145→// watchLoop is the main monitoring loop
   146→func (w *CursorWatcher) watchLoop() {
   147→	defer w.wg.Done()
   148→
   149→	ticker := time.NewTicker(w.pollInterval)
   150→	defer ticker.Stop()
   151→
   152→	// Do an initial check immediately
   153→	w.checkForChanges()
   154→
   155→	for {
   156→		select {
   157→		case <-w.ctx.Done():
   158→			return
   159→		case <-ticker.C:
   160→			// Uncomment this to see the ticker in action when debugging the watcher
   161→			//slog.Debug("Watcher tick - checking for changes")
   162→			w.checkForChanges()
   163→		}
   164→	}
   165→}
   166→
   167→// checkForChanges scans all session directories for database changes
   168→func (w *CursorWatcher) checkForChanges() {
   169→
   170→	// Get all session directories
   171→	sessionIDs, err := GetCursorSessionDirs(w.hashDir)
   172→	if err != nil {
   173→		slog.Debug("Failed to get session directories", "error", err)
   174→		return
   175→	}
   176→
   177→	for _, sessionID := range sessionIDs {
   178→		// Check if this is a NEW session or the resumed session
   179→		w.mu.RLock()
   180→		isKnown := w.knownSessions[sessionID]
   181→		isResumed := sessionID == w.resumedSession
   182→		w.mu.RUnlock()
   183→
   184→		// Skip known sessions unless it's the one being resumed
   185→		if isKnown && !isResumed {
   186→			continue
   187→		}
   188→
   189→		// Check if this session has a store.db file
   190→		dbPath := filepath.Join(w.hashDir, sessionID, "store.db")
   191→
   192→		// Check if database exists
   193→		fileInfo, err := os.Stat(dbPath)
   194→		if err != nil {
   195→			continue // Skip sessions without store.db
   196→		}
   197→
   198→		// For NEW sessions, process them once and then watch for changes
   199→		if !isKnown {
   200→			// Check if we've already seen this new session
   201→			if w.hasSessionChanged(sessionID, fileInfo, dbPath) {
   202→				slog.Info("Detected NEW Cursor session", "sessionId", sessionID)
   203→				w.processSessionChanges(sessionID, dbPath)
   204→			}
   205→		} else if isResumed {
   206→			// For resumed session, check for changes
   207→			slog.Debug("Polling resumed session for changes", "sessionId", sessionID)
   208→			if w.hasSessionChanged(sessionID, fileInfo, dbPath) {
   209→				slog.Info("Detected changes in resumed Cursor session", "sessionId", sessionID)
   210→				w.processSessionChanges(sessionID, dbPath)
   211→			} else {
   212→				slog.Debug("No changes detected in resumed session", "sessionId", sessionID)
   213→			}
   214→		}
   215→	}
   216→}
   217→
   218→// hasSessionChanged checks if a session database has new records
   219→func (w *CursorWatcher) hasSessionChanged(sessionID string, fileInfo os.FileInfo, dbPath string) bool {
   220→	w.mu.Lock()
   221→	defer w.mu.Unlock()
   222→
   223→	// Always check record count - don't rely on file modification time
   224→	// SQLite with WAL mode may not update file mtime when records are added
   225→
   226→	// Open database to count records (with WAL mode)
   227→	db, err := sql.Open("sqlite", dbPath+"?mode=ro")
   228→	if err != nil {
   229→		slog.Error("Failed to open database", "sessionId", sessionID, "error", err)
   230→		return false
   231→	}
   232→	defer func() {
   233→		if err := db.Close(); err != nil {
   234→			slog.Debug("Failed to close database", "error", err)
   235→		}
   236→	}()
   237→
   238→	// Enable WAL mode for non-blocking reads
   239→	if _, err := db.Exec("PRAGMA journal_mode=WAL"); err != nil {
   240→		slog.Debug("Failed to enable WAL mode in watcher", "error", err)
   241→	}
   242→
   243→	// Count total records in the blobs table
   244→	var count int
   245→	err = db.QueryRow("SELECT COUNT(*) FROM blobs").Scan(&count)
   246→	if err != nil {
   247→		slog.Error("Failed to count blobs", "sessionId", sessionID, "error", err)
   248→		return false
   249→	}
   250→
   251→	// Check if record count changed
   252→	lastCount, countExists := w.lastCounts[sessionID]
   253→	w.lastCounts[sessionID] = count
   254→
   255→	if !countExists {
   256→		// First time seeing this session - only process if it has content
   257→		if count > 0 {
   258→			slog.Debug("First check of session with content", "sessionId", sessionID, "recordCount", count)
   259→			return true
   260→		}
   261→		slog.Debug("First check of session but empty", "sessionId", sessionID)
   262→		return false
   263→	}
   264→
   265→	if count > lastCount {
   266→		// Records added to existing session
   267→		slog.Debug("Session has new records", "sessionId", sessionID, "oldCount", lastCount, "newCount", count)
   268→		return true
   269→	}
   270→
   271→	// Uncomment this to see the ticker in action when debugging the watcher
   272→	//slog.Debug("No new records in session", "sessionId", sessionID, "count", count)
   273→	return false
   274→}
   275→
   276→// processSessionChanges handles changes detected in a session
   277→func (w *CursorWatcher) processSessionChanges(sessionID string, dbPath string) {
   278→	slog.Info("Processing Cursor session changes", "sessionId", sessionID)
   279→
   280→	// Read the session data
   281→	sessionPath := filepath.Dir(dbPath) // Get the session directory from db path
   282→	createdAt, slug, blobRecords, _, err := ReadSessionData(sessionPath)
   283→	if err != nil {
   284→		slog.Error("Failed to read session data", "sessionId", sessionID, "error", err)
   285→		return
   286→	}
   287→
   288→	if len(blobRecords) == 0 {
   289→		slog.Debug("Session has no message records", "sessionId", sessionID)
   290→		return
   291→	}
   292→
   293→	// Generate SessionData from blob records
   294→	sessionData, err := GenerateAgentSession(blobRecords, w.projectPath, sessionID, createdAt, slug)
   295→	if err != nil {
   296→		slog.Error("Failed to generate SessionData", "sessionId", sessionID, "error", err)
   297→		return
   298→	}
   299→
   300→	// Marshal blob records to JSON for raw data
   301→	rawDataJSON, err := json.Marshal(blobRecords)
   302→	if err != nil {
   303→		slog.Error("Failed to marshal blob records", "sessionId", sessionID, "error", err)
   304→		return
   305→	}
   306→
   307→	// Write provider-specific debug output if requested
   308→	if w.debugRaw {
   309→		if err := writeDebugOutput(sessionID, string(rawDataJSON), nil); err != nil {
   310→			slog.Debug("Failed to write debug output", "sessionID", sessionID, "error", err)
   311→			// Don't fail the operation if debug output fails
   312→		}
   313→	}
   314→
   315→	// Create the AgentChatSession
   316→	agentSession := &spi.AgentChatSession{
   317→		SessionID:   sessionID,
   318→		CreatedAt:   createdAt,
   319→		Slug:        slug,
   320→		SessionData: sessionData,
   321→		RawData:     string(rawDataJSON),
   322→	}
   323→
   324→	// Call the callback asynchronously to avoid blocking the watcher
   325→	if w.sessionCallback != nil {
   326→		w.callbackWg.Add(1)
   327→		go func(s *spi.AgentChatSession) {
   328→			defer w.callbackWg.Done()
   329→			defer func() {
   330→				if r := recover(); r != nil {
   331→					slog.Error("Session callback panicked", "panic", r, "sessionId", s.SessionID)
   332→				}
   333→			}()
   334→			w.sessionCallback(s)
   335→		}(agentSession)
   336→
   337→		// Log that we detected changes and invoked the callback
   338→		slog.Info("Detected session changes, callback invoked", "sessionId", sessionID)
   339→	}
   340→}
   341→
   342→// WatchCursorProject starts monitoring a Cursor project
   343→func WatchCursorProject(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) (*CursorWatcher, error) {
   344→	watcher, err := NewCursorWatcher(projectPath, debugRaw, sessionCallback)
   345→	if err != nil {
   346→		return nil, err
   347→	}
   348→
   349→	if err := watcher.Start(); err != nil {
   350→		return nil, err
   351→	}
   352→
   353→	return watcher, nil
   354→}
   355→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:50Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/watcher.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"time"
     8→
     9→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    10→)
    11→
    12→const droidWatchInterval = 1 * time.Second
    13→
    14→type watchState struct {
    15→	lastProcessed map[string]int64
    16→}
    17→
    18→func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
    19→	if sessionCallback == nil {
    20→		return fmt.Errorf("session callback is required")
    21→	}
    22→
    23→	state := &watchState{lastProcessed: make(map[string]int64)}
    24→	if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    25→		return err
    26→	}
    27→
    28→	ticker := time.NewTicker(droidWatchInterval)
    29→	defer ticker.Stop()
    30→
    31→	for {
    32→		select {
    33→		case <-ctx.Done():
    34→			return ctx.Err()
    35→		case <-ticker.C:
    36→			if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    37→				slog.Debug("droidcli: scan failed", "error", err)
    38→			}
    39→		}
    40→	}
    41→}
    42→
    43→func scanAndProcessSessions(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) error {
    44→	files, err := listSessionFiles()
    45→	if err != nil {
    46→		return err
    47→	}
    48→
    49→	for _, file := range files {
    50→		if last, ok := state.lastProcessed[file.Path]; ok && last >= file.ModTime {
    51→			continue
    52→		}
    53→		if projectPath != "" && !sessionMentionsProject(file.Path, projectPath) {
    54→			continue
    55→		}
    56→		session, err := parseFactorySession(file.Path)
    57→		if err != nil {
    58→			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
    59→			continue
    60→		}
    61→		chat := convertToAgentSession(session, projectPath, debugRaw)
    62→		if chat == nil {
    63→			continue
    64→		}
    65→		state.lastProcessed[file.Path] = file.ModTime
    66→		dispatchSession(sessionCallback, chat)
    67→	}
    68→	return nil
    69→}
    70→
    71→func dispatchSession(sessionCallback func(*spi.AgentChatSession), session *spi.AgentChatSession) {
    72→	if sessionCallback == nil || session == nil {
    73→		return
    74→	}
    75→	go func() {
    76→		defer func() {
    77→			if r := recover(); r != nil {
    78→				slog.Error("droidcli: session callback panicked", "panic", r)
    79→			}
    80→		}()
    81→		sessionCallback(session)
    82→	}()
    83→}
    84→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:51Z)**_

Now let me look at the helper functions that the watcher uses to understand what files it watches:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:52Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg/providers/droidcli` pattern `listSessionFiles|findSessionFileByID`
```
Found 3 files
pkg/providers/droidcli/watcher.go
pkg/providers/droidcli/provider.go
pkg/providers/droidcli/path_utils.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:52Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/path_utils.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"fmt"
     5→	"io/fs"
     6→	"os"
     7→	"path/filepath"
     8→	"sort"
     9→)
    10→
    11→const (
    12→	factoryRootDir     = ".factory"
    13→	factorySessionsDir = "sessions"
    14→)
    15→
    16→type sessionFile struct {
    17→	Path     string
    18→	ModTime  int64
    19→	FileName string
    20→}
    21→
    22→func resolveSessionsDir() (string, error) {
    23→	home, err := os.UserHomeDir()
    24→	if err != nil {
    25→		return "", fmt.Errorf("droidcli: cannot resolve home dir: %w", err)
    26→	}
    27→	dir := filepath.Join(home, factoryRootDir, factorySessionsDir)
    28→	return dir, nil
    29→}
    30→
    31→func listSessionFiles() ([]sessionFile, error) {
    32→	dir, err := resolveSessionsDir()
    33→	if err != nil {
    34→		return nil, err
    35→	}
    36→	files := make([]sessionFile, 0, 64)
    37→	walker := func(path string, d fs.DirEntry, walkErr error) error {
    38→		if walkErr != nil {
    39→			return nil
    40→		}
    41→		if d.IsDir() {
    42→			return nil
    43→		}
    44→		if filepath.Ext(d.Name()) != ".jsonl" {
    45→			return nil
    46→		}
    47→		info, err := d.Info()
    48→		if err != nil {
    49→			return nil
    50→		}
    51→		files = append(files, sessionFile{
    52→			Path:     path,
    53→			ModTime:  info.ModTime().UnixNano(),
    54→			FileName: d.Name(),
    55→		})
    56→		return nil
    57→	}
    58→	if err := filepath.WalkDir(dir, walker); err != nil {
    59→		if os.IsNotExist(err) {
    60→			return []sessionFile{}, nil
    61→		}
    62→		return nil, fmt.Errorf("droidcli: unable to read sessions dir: %w", err)
    63→	}
    64→	sort.Slice(files, func(i, j int) bool {
    65→		return files[i].ModTime > files[j].ModTime
    66→	})
    67→	return files, nil
    68→}
    69→
    70→func findSessionFileByID(sessionID string) (string, error) {
    71→	files, err := listSessionFiles()
    72→	if err != nil {
    73→		return "", err
    74→	}
    75→	for _, file := range files {
    76→		candidate := file.FileName
    77→		if candidate == sessionID || trimExt(candidate) == sessionID {
    78→			return file.Path, nil
    79→		}
    80→	}
    81→	return "", nil
    82→}
    83→
    84→func trimExt(name string) string {
    85→	ext := filepath.Ext(name)
    86→	if ext == "" {
    87→		return name
    88→	}
    89→	return name[:len(name)-len(ext)]
    90→}
    91→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:53Z)**_

Now let me look at the provider.go files to see how these watchers are initialized and how they integrate with the broader system.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:54Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/claudecode/provider.go`
```
     1→package claudecode
     2→
     3→import (
     4→	"bytes"
     5→	"context"
     6→	"encoding/json"
     7→	"errors"
     8→	"fmt"
     9→	"log/slog"
    10→	"os"
    11→	"os/exec"
    12→	"path/filepath"
    13→	"strings"
    14→
    15→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    18→)
    19→
    20→// Provider implements the SPI Provider interface for Claude Code
    21→type Provider struct{}
    22→
    23→// NewProvider creates a new Claude Code provider instance
    24→func NewProvider() *Provider {
    25→	return &Provider{}
    26→}
    27→
    28→// filterWarmupMessages removes warmup messages (sidechain messages before first real message)
    29→func filterWarmupMessages(records []JSONLRecord) []JSONLRecord {
    30→	// Find first non-sidechain message
    31→	firstRealMessageIndex := -1
    32→	for i, record := range records {
    33→		if isSidechain, ok := record.Data["isSidechain"].(bool); !ok || !isSidechain {
    34→			firstRealMessageIndex = i
    35→			break
    36→		}
    37→	}
    38→
    39→	// No real messages found
    40→	if firstRealMessageIndex == -1 {
    41→		return []JSONLRecord{}
    42→	}
    43→
    44→	// Return records starting from first real message
    45→	return records[firstRealMessageIndex:]
    46→}
    47→
    48→// processSession filters warmup messages and converts a Session to an AgentChatSession
    49→// Returns nil if the session is warmup-only (no real messages)
    50→func processSession(session Session, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
    51→	// Write debug files first (even for warmup-only sessions)
    52→	if debugRaw {
    53→		// Write debug files and get the record-to-file mapping
    54→		_ = writeDebugRawFiles(session) // Unused but needed for side effect
    55→	}
    56→
    57→	// Filter warmup messages
    58→	filteredRecords := filterWarmupMessages(session.Records)
    59→
    60→	// Skip if no real messages remain after filtering warmup
    61→	if len(filteredRecords) == 0 {
    62→		slog.Debug("Skipping warmup-only session", "sessionId", session.SessionUuid)
    63→		return nil
    64→	}
    65→
    66→	// Create session with filtered records
    67→	filteredSession := Session{
    68→		SessionUuid: session.SessionUuid,
    69→		Records:     filteredRecords,
    70→	}
    71→
    72→	// Get timestamp from root record
    73→	rootRecord := filteredSession.Records[0]
    74→	timestamp := rootRecord.Data["timestamp"].(string)
    75→
    76→	// Get the slug
    77→	slug := FileSlugFromRootRecord(filteredSession)
    78→
    79→	// Generate SessionData from filtered session
    80→	sessionData, err := GenerateAgentSession(filteredSession, workspaceRoot)
    81→	if err != nil {
    82→		slog.Error("Failed to generate SessionData", "sessionId", session.SessionUuid, "error", err)
    83→		return nil
    84→	}
    85→
    86→	// Convert session records to JSONL format for raw data
    87→	// Note: Uses unfiltered session.Records (not filteredSession.Records) to preserve
    88→	// all records including warmup messages in the raw data for complete audit trail
    89→	var rawDataBuilder strings.Builder
    90→	for _, record := range session.Records {
    91→		jsonBytes, _ := json.Marshal(record.Data)
    92→		rawDataBuilder.Write(jsonBytes)
    93→		rawDataBuilder.WriteString("\n")
    94→	}
    95→
    96→	return &spi.AgentChatSession{
    97→		SessionID:   session.SessionUuid,
    98→		CreatedAt:   timestamp, // ISO 8601 timestamp
    99→		Slug:        slug,
   100→		SessionData: sessionData,
   101→		RawData:     rawDataBuilder.String(),
   102→	}
   103→}
   104→
   105→// Name returns the human-readable name of this provider
   106→func (p *Provider) Name() string {
   107→	return "Claude Code"
   108→}
   109→
   110→// buildCheckErrorMessage creates a user-facing error message tailored to the failure type.
   111→func buildCheckErrorMessage(errorType string, claudeCmd string, isCustom bool, stderrOutput string) string {
   112→	var errorMsg strings.Builder
   113→
   114→	switch errorType {
   115→	case "not_found":
   116→		errorMsg.WriteString(fmt.Sprintf("  🔍 Could not find Claude Code at: %s\n", claudeCmd))
   117→		errorMsg.WriteString("\n")
   118→		errorMsg.WriteString("  💡 Here's how to fix this:\n")
   119→		errorMsg.WriteString("\n")
   120→		if isCustom {
   121→			errorMsg.WriteString("     The specified path doesn't exist. Please check:\n")
   122→			errorMsg.WriteString(fmt.Sprintf("     • Is Claude Code installed at %s?\n", claudeCmd))
   123→			errorMsg.WriteString("     • Did you type the path correctly?")
   124→		} else {
   125→			errorMsg.WriteString("     1. Make sure Claude Code is installed:\n")
   126→			errorMsg.WriteString("        • Visit https://docs.claude.com/en/docs/claude-code/quickstart\n")
   127→			errorMsg.WriteString("\n")
   128→			errorMsg.WriteString("     2. If it's already installed, try:\n")
   129→			errorMsg.WriteString("        • Check if 'claude' is in your PATH\n")
   130→			errorMsg.WriteString("        • Use -c flag to specify the full path\n")
   131→			errorMsg.WriteString("        • Example: specstory check claude -c \"~/.claude/local/claude\"")
   132→		}
   133→	case "permission_denied":
   134→		errorMsg.WriteString(fmt.Sprintf("  🔒 Permission denied when trying to run: %s\n", claudeCmd))
   135→		errorMsg.WriteString("\n")
   136→		errorMsg.WriteString("  💡 Here's how to fix this:\n")
   137→		errorMsg.WriteString(fmt.Sprintf("     • Check file permissions: chmod +x %s\n", claudeCmd))
   138→		errorMsg.WriteString("     • Try running with elevated permissions if needed")
   139→	case "unexpected_output":
   140→		errorMsg.WriteString(fmt.Sprintf("  ⚠️  Unexpected output from 'claude -v': %s\n", strings.TrimSpace(stderrOutput)))
   141→		errorMsg.WriteString("\n")
   142→		errorMsg.WriteString("  💡 This might not be Claude Code. Expected output containing '(Claude Code)'.\n")
   143→		errorMsg.WriteString("     • Make sure you have Claude Code installed, not a different 'claude' command\n")
   144→		errorMsg.WriteString("     • Visit https://docs.anthropic.com/en/docs/claude-code/quickstart for installation")
   145→	default:
   146→		errorMsg.WriteString("  ⚠️  Error running 'claude -v'\n")
   147→		if stderrOutput != "" {
   148→			errorMsg.WriteString(fmt.Sprintf("  📋 Error details: %s\n", stderrOutput))
   149→		}
   150→		errorMsg.WriteString("\n")
   151→		errorMsg.WriteString("  💡 Troubleshooting tips:\n")
   152→		errorMsg.WriteString("     • Make sure Claude Code is properly installed\n")
   153→		errorMsg.WriteString("     • Try running 'claude -v' directly in your terminal\n")
   154→		errorMsg.WriteString("     • Check https://docs.claude.com/en/docs/claude-code/quickstart for installation help")
   155→	}
   156→
   157→	return errorMsg.String()
   158→}
   159→
   160→// Check verifies Claude Code installation and returns version info
   161→func (p *Provider) Check(customCommand string) spi.CheckResult {
   162→	// Parse the command (no resume session for version check)
   163→	claudeCmd, _ := parseClaudeCommand(customCommand, "")
   164→
   165→	// Determine if custom command was used
   166→	isCustomCommand := customCommand != ""
   167→
   168→	// Resolve the actual path of the command
   169→	resolvedPath := claudeCmd
   170→	if !filepath.IsAbs(claudeCmd) {
   171→		// Try to find the command in PATH
   172→		if path, err := exec.LookPath(claudeCmd); err == nil {
   173→			resolvedPath = path
   174→		}
   175→	}
   176→
   177→	// Run claude -v to check version (ignore custom args for version check)
   178→	cmd := exec.Command(claudeCmd, "-v")
   179→	var out bytes.Buffer
   180→	var errOut bytes.Buffer
   181→	cmd.Stdout = &out
   182→	cmd.Stderr = &errOut
   183→
   184→	if err := cmd.Run(); err != nil {
   185→		// Track installation check failure
   186→		errorType := "unknown"
   187→
   188→		var execErr *exec.Error
   189→		var pathErr *os.PathError
   190→
   191→		// Check error types in order of specificity
   192→		switch {
   193→		case errors.As(err, &execErr) && execErr.Err == exec.ErrNotFound:
   194→			errorType = "not_found"
   195→		case errors.As(err, &pathErr):
   196→			if errors.Is(pathErr.Err, os.ErrNotExist) {
   197→				errorType = "not_found"
   198→			} else if errors.Is(pathErr.Err, os.ErrPermission) {
   199→				errorType = "permission_denied"
   200→			}
   201→		case errors.Is(err, os.ErrPermission):
   202→			errorType = "permission_denied"
   203→		}
   204→
   205→		stderrOutput := strings.TrimSpace(errOut.String())
   206→		analytics.TrackEvent(analytics.EventCheckInstallFailed, analytics.Properties{
   207→			"provider":       "claude",
   208→			"custom_command": isCustomCommand,
   209→			"command_path":   claudeCmd,
   210→			"error_type":     errorType,
   211→			"error_message":  err.Error(),
   212→		})
   213→
   214→		errorMessage := buildCheckErrorMessage(errorType, claudeCmd, isCustomCommand, stderrOutput)
   215→
   216→		return spi.CheckResult{
   217→			Success:      false,
   218→			Version:      "",
   219→			Location:     resolvedPath,
   220→			ErrorMessage: errorMessage,
   221→		}
   222→	}
   223→
   224→	// Check if output contains "Claude Code"
   225→	output := out.String()
   226→	if !strings.Contains(output, "(Claude Code)") {
   227→		// Track unexpected output error
   228→		analytics.TrackEvent(analytics.EventCheckInstallFailed, analytics.Properties{
   229→			"provider":       "claude",
   230→			"custom_command": isCustomCommand,
   231→			"command_path":   claudeCmd,
   232→			"error_type":     "unexpected_output",
   233→			"output":         strings.TrimSpace(output),
   234→		})
   235→
   236→		errorMessage := buildCheckErrorMessage("unexpected_output", claudeCmd, isCustomCommand, output)
   237→
   238→		return spi.CheckResult{
   239→			Success:      false,
   240→			Version:      "",
   241→			Location:     resolvedPath,
   242→			ErrorMessage: errorMessage,
   243→		}
   244→	}
   245→
   246→	// Success! Track it
   247→	pathType := getPathType(claudeCmd, resolvedPath)
   248→	analytics.TrackEvent(analytics.EventCheckInstallSuccess, analytics.Properties{
   249→		"provider":       "claude",
   250→		"custom_command": isCustomCommand,
   251→		"command_path":   resolvedPath,
   252→		"path_type":      pathType,
   253→		"version":        strings.TrimSpace(output),
   254→	})
   255→
   256→	return spi.CheckResult{
   257→		Success:      true,
   258→		Version:      strings.TrimSpace(output),
   259→		Location:     resolvedPath,
   260→		ErrorMessage: "",
   261→	}
   262→}
   263→
   264→// DetectAgent checks if Claude Code has been used in the given project directory
   265→func (p *Provider) DetectAgent(projectPath string, helpOutput bool) bool {
   266→	// Get the Claude Code project directory for the given path
   267→	claudeProjectPath, err := GetClaudeCodeProjectDir(projectPath)
   268→	if err != nil {
   269→		slog.Debug("DetectAgent: Failed to get Claude Code project directory", "error", err)
   270→		return false
   271→	}
   272→
   273→	// Check if the Claude Code project directory exists
   274→	if info, err := os.Stat(claudeProjectPath); err == nil && info.IsDir() {
   275→		slog.Debug("DetectAgent: Claude Code project found", "path", claudeProjectPath)
   276→		return true
   277→	}
   278→
   279→	slog.Debug("DetectAgent: No Claude Code project found", "expected_path", claudeProjectPath)
   280→
   281→	// If helpOutput is requested, provide helpful guidance
   282→	if helpOutput {
   283→		fmt.Println() // Add visual separation
   284→		log.UserWarn("No Claude Code project found for this directory.\n")
   285→		log.UserMessage("Claude Code hasn't created a project folder for your current directory yet.\n")
   286→		log.UserMessage("This happens when Claude Code hasn't been run in this directory.\n\n")
   287→		log.UserMessage("To fix this:\n")
   288→		log.UserMessage("  1. Run 'specstory run' to start Claude Code in this directory\n")
   289→		log.UserMessage("  2. Or run Claude Code directly with `claude`, then try syncing again\n\n")
   290→		log.UserMessage("Expected project folder: %s\n", claudeProjectPath)
   291→		fmt.Println() // Add trailing newline
   292→	}
   293→
   294→	return false
   295→}
   296→
   297→// GetAgentChatSessions retrieves all chat sessions for the given project path
   298→func (p *Provider) GetAgentChatSessions(projectPath string, debugRaw bool) ([]spi.AgentChatSession, error) {
   299→	// Get the Claude Code project directory
   300→	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
   301→	if err != nil {
   302→		return nil, err
   303→	}
   304→
   305→	// Check if project directory exists
   306→	if _, err := os.Stat(claudeProjectDir); os.IsNotExist(err) {
   307→		return []spi.AgentChatSession{}, nil // No sessions if no project
   308→	}
   309→
   310→	// Parse JSONL files
   311→	parser := NewJSONLParser()
   312→	err = parser.ParseProjectSessions(claudeProjectDir, true) // silent = true
   313→	if err != nil {
   314→		return nil, err
   315→	}
   316→
   317→	// Convert sessions to AgentChatSession structs
   318→	result := make([]spi.AgentChatSession, 0, len(parser.Sessions))
   319→	for _, session := range parser.Sessions {
   320→		// Skip empty sessions (no records)
   321→		if len(session.Records) == 0 {
   322→			continue
   323→		}
   324→
   325→		// Process session (filter warmup, generate SessionData)
   326→		chatSession := processSession(session, projectPath, debugRaw)
   327→		if chatSession != nil {
   328→			result = append(result, *chatSession)
   329→		}
   330→	}
   331→
   332→	return result, nil
   333→}
   334→
   335→// GetAgentChatSession retrieves a single chat session by ID for the given project path
   336→func (p *Provider) GetAgentChatSession(projectPath string, sessionID string, debugRaw bool) (*spi.AgentChatSession, error) {
   337→	// Get the Claude Code project directory
   338→	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
   339→	if err != nil {
   340→		return nil, err
   341→	}
   342→
   343→	// Check if project directory exists
   344→	if _, err := os.Stat(claudeProjectDir); os.IsNotExist(err) {
   345→		return nil, nil // No sessions if no project
   346→	}
   347→
   348→	// Parse only the session we're looking for
   349→	parser := NewJSONLParser()
   350→	err = parser.ParseSingleSession(claudeProjectDir, sessionID)
   351→	if err != nil {
   352→		// If session not found, return nil (not an error)
   353→		if strings.Contains(err.Error(), "not found") {
   354→			return nil, nil
   355→		}
   356→		return nil, err
   357→	}
   358→
   359→	// Find the session
   360→	sessionPointer := parser.FindSession(sessionID)
   361→	if sessionPointer == nil {
   362→		return nil, nil
   363→	}
   364→	session := *sessionPointer
   365→
   366→	// Skip empty sessions (no records)
   367→	if len(session.Records) == 0 {
   368→		return nil, nil
   369→	}
   370→
   371→	// Process session (filter warmup, generate SessionData)
   372→	return processSession(session, projectPath, debugRaw), nil
   373→}
   374→
   375→// ExecAgentAndWatch executes Claude Code in interactive mode and watches for session updates
   376→func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   377→	slog.Info("ExecAgentAndWatch: Starting Claude Code execution and monitoring",
   378→		"projectPath", projectPath,
   379→		"customCommand", customCommand,
   380→		"resumeSessionID", resumeSessionID,
   381→		"debugRaw", debugRaw)
   382→
   383→	// Validate resume session ID if provided (Claude Code uses UUID format)
   384→	if resumeSessionID != "" {
   385→		resumeSessionID = strings.TrimSpace(resumeSessionID)
   386→		// Simple UUID validation for Claude Code sessions
   387→		if len(resumeSessionID) != 36 || !strings.Contains(resumeSessionID, "-") {
   388→			return fmt.Errorf("invalid session ID format for Claude Code: %s (must be a UUID)", resumeSessionID)
   389→		}
   390→		slog.Info("Resuming Claude Code session", "sessionId", resumeSessionID)
   391→	}
   392→
   393→	// Set up the callback which enables real-time markdown generation and cloud sync during
   394→	// interactive sessions. As Claude Code writes JSONL updates, the watcher detects
   395→	// changes and invokes this callback, allowing immediate processing without blocking
   396→	// the agent's execution. The defer ensures cleanup when the agent exits.
   397→	SetWatcherCallback(sessionCallback)
   398→	defer ClearWatcherCallback()
   399→
   400→	// Set debug raw mode for the watcher
   401→	SetWatcherDebugRaw(debugRaw)
   402→
   403→	// Start watching for project directory in the background
   404→	slog.Info("Initializing project directory monitoring...")
   405→
   406→	if err := WatchForProjectDir(); err != nil {
   407→		// Log the error but don't fail - watcher might work later
   408→		slog.Error("Failed to start project directory watcher", "error", err)
   409→	}
   410→
   411→	// Execute Claude Code - this blocks until Claude exits
   412→	slog.Info("Executing Claude Code", "command", customCommand)
   413→	err := ExecuteClaude(customCommand, resumeSessionID)
   414→
   415→	// Stop the watcher goroutine before returning
   416→	slog.Info("Claude Code has exited, stopping watcher")
   417→	StopWatcher()
   418→
   419→	// Return any execution error
   420→	if err != nil {
   421→		return fmt.Errorf("claude Code execution failed: %w", err)
   422→	}
   423→
   424→	return nil
   425→}
   426→
   427→// WatchAgent watches for Claude Code agent activity and calls the callback with AgentChatSession
   428→// Does NOT execute the agent - only watches for existing activity
   429→// Runs until error or context cancellation
   430→func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   431→	slog.Info("WatchAgent: Starting Claude Code activity monitoring",
   432→		"projectPath", projectPath,
   433→		"debugRaw", debugRaw)
   434→
   435→	// The watcher callback directly passes AgentChatSession (which now contains SessionData)
   436→	wrappedCallback := func(agentChatSession *spi.AgentChatSession) {
   437→		slog.Debug("WatchAgent: Received AgentChatSession",
   438→			"sessionID", agentChatSession.SessionID,
   439→			"hasSessionData", agentChatSession.SessionData != nil)
   440→
   441→		// Call the user's callback with the AgentChatSession
   442→		sessionCallback(agentChatSession)
   443→	}
   444→
   445→	// Set up the callback for the watcher
   446→	SetWatcherCallback(wrappedCallback)
   447→	defer ClearWatcherCallback()
   448→
   449→	// Set debug raw mode for the watcher
   450→	SetWatcherDebugRaw(debugRaw)
   451→
   452→	// Get the Claude Code project directory for the specified project path
   453→	slog.Info("WatchAgent: Initializing project directory monitoring...")
   454→
   455→	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
   456→	if err != nil {
   457→		slog.Error("WatchAgent: Failed to get Claude Code project directory", "error", err)
   458→		return fmt.Errorf("failed to get project directory: %w", err)
   459→	}
   460→
   461→	slog.Info("WatchAgent: Project directory found", "directory", claudeProjectDir)
   462→
   463→	if err := startProjectWatcher(claudeProjectDir); err != nil {
   464→		slog.Error("WatchAgent: Failed to start project watcher", "error", err)
   465→		return fmt.Errorf("failed to start watcher: %w", err)
   466→	}
   467→
   468→	// Block until context is cancelled
   469→	// The watcher runs in a background goroutine and will continue
   470→	// until context is cancelled or the process exits
   471→	slog.Info("WatchAgent: Watcher started, blocking until context cancelled")
   472→
   473→	// Wait for context cancellation
   474→	<-ctx.Done()
   475→
   476→	slog.Info("WatchAgent: Context cancelled, stopping watcher")
   477→	StopWatcher()
   478→
   479→	return ctx.Err()
   480→}
   481→
   482→// findFirstUserMessage finds the first user message in a session for slug generation
   483→// Returns empty string if no suitable user message is found
   484→func findFirstUserMessage(session Session) string {
   485→	for _, record := range session.Records {
   486→		// Check if this is a user message
   487→		if recordType, ok := record.Data["type"].(string); !ok || recordType != "user" {
   488→			continue
   489→		}
   490→
   491→		// Skip meta user messages
   492→		if isMeta, ok := record.Data["isMeta"].(bool); ok && isMeta {
   493→			continue
   494→		}
   495→
   496→		// Extract content from message
   497→		if message, ok := record.Data["message"].(map[string]interface{}); ok {
   498→			if content, ok := message["content"].(string); ok && content != "" {
   499→				// Skip messages containing "warmup" (case-insensitive)
   500→				if strings.Contains(strings.ToLower(content), "warmup") {
   501→					continue
   502→				}
   503→				return content
   504→			}
   505→		}
   506→	}
   507→	return ""
   508→}
   509→
   510→// FileSlugFromRootRecord generates the slug part of the filename from the session
   511→// Returns the human-readable slug derived from the first user message, or empty string if none
   512→func FileSlugFromRootRecord(session Session) string {
   513→	// Find the first user message and generate slug from it
   514→	firstUserMessage := findFirstUserMessage(session)
   515→	slog.Debug("FileSlugFromRootRecord: First user message",
   516→		"sessionId", session.SessionUuid,
   517→		"message", firstUserMessage)
   518→
   519→	slug := spi.GenerateFilenameFromUserMessage(firstUserMessage)
   520→	slog.Debug("FileSlugFromRootRecord: Generated slug",
   521→		"sessionId", session.SessionUuid,
   522→		"slug", slug)
   523→
   524→	return slug
   525→}
   526→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:54Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/codexcli/provider.go`
```
     1→package codexcli
     2→
     3→import (
     4→	"bufio"
     5→	"context"
     6→	"encoding/json"
     7→	"errors"
     8→	"fmt"
     9→	"io"
    10→	"log/slog"
    11→	"os"
    12→	"os/exec"
    13→	"path/filepath"
    14→	"strings"
    15→
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    18→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    19→)
    20→
    21→const (
    22→	KB                    = 1024
    23→	MB                    = 1024 * 1024
    24→	maxReasonableLineSize = 250 * MB // 250MB sanity limit to prevent OOM from malformed or malicious files
    25→)
    26→
    27→// codexSessionMetaPayload captures the payload embedded in the Codex CLI session metadata record.
    28→type codexSessionMetaPayload struct {
    29→	ID        string `json:"id"`
    30→	Timestamp string `json:"timestamp"`
    31→	CWD       string `json:"cwd"`
    32→}
    33→
    34→// codexSessionMeta represents the metadata stored as the first line of a Codex CLI session JSONL file.
    35→type codexSessionMeta struct {
    36→	Type      string                  `json:"type"`
    37→	Timestamp string                  `json:"timestamp"`
    38→	Payload   codexSessionMetaPayload `json:"payload"`
    39→}
    40→
    41→// codexSessionInfo holds information about a discovered Codex CLI session.
    42→type codexSessionInfo struct {
    43→	SessionID   string
    44→	SessionPath string
    45→	Meta        *codexSessionMeta
    46→}
    47→
    48→// Provider implements the SPI Provider interface for the OpenAI Codex CLI.
    49→type Provider struct{}
    50→
    51→// NewProvider creates a new Codex CLI provider instance.
    52→func NewProvider() *Provider {
    53→	return &Provider{}
    54→}
    55→
    56→// Name returns the human-readable name of this provider.
    57→func (p *Provider) Name() string {
    58→	return "Codex CLI"
    59→}
    60→
    61→// buildCheckErrorMessage creates a user-facing error message tailored to the failure type.
    62→func buildCheckErrorMessage(errorType string, codexCmd string, isCustom bool, stderrOutput string) string {
    63→	var errorMsg strings.Builder
    64→
    65→	switch errorType {
    66→	case "not_found":
    67→		errorMsg.WriteString(fmt.Sprintf("  🔍 Could not find Codex CLI at: %s\n\n", codexCmd))
    68→		errorMsg.WriteString("  💡 Here's how to fix this:\n\n")
    69→		if isCustom {
    70→			errorMsg.WriteString("     • Double-check the custom command/path you provided\n")
    71→			errorMsg.WriteString("     • Ensure the file exists and is executable\n")
    72→			errorMsg.WriteString("     • If the binary lives elsewhere, point to it with an absolute path\n")
    73→		} else {
    74→			errorMsg.WriteString("     1. Check common installation locations:\n")
    75→			errorMsg.WriteString("        • Homebrew: /opt/homebrew/bin/codex (installed via `brew install codex`)\n")
    76→			errorMsg.WriteString("        • npm: $(npm bin -g)/codex (installed via `npm install -g codex`)\n")
    77→			errorMsg.WriteString("\n")
    78→			errorMsg.WriteString("     2. If it's already installed, try:\n")
    79→			errorMsg.WriteString("        • Check if 'codex' is in your PATH\n")
    80→			errorMsg.WriteString("        • Use -c flag to specify the full path\n")
    81→			errorMsg.WriteString("        • Example: specstory check codex -c \"/opt/local/bin/codex\"")
    82→		}
    83→	case "permission_denied":
    84→		errorMsg.WriteString(fmt.Sprintf("  🔒 Permission denied when trying to run: %s\n\n", codexCmd))
    85→		errorMsg.WriteString("  💡 Try the following:\n")
    86→		errorMsg.WriteString(fmt.Sprintf("     • Ensure the binary is executable: chmod +x %s\n", codexCmd))
    87→		errorMsg.WriteString("     • Run the command manually to confirm it works outside SpecStory\n")
    88→	case "no_output":
    89→		errorMsg.WriteString("  ⚠️  No version information from codex\n\n")
    90→		errorMsg.WriteString("  🤔 The command ran but produced no output\n")
    91→		errorMsg.WriteString("  ❓ Expected: Version information from codex\n\n")
    92→		errorMsg.WriteString("  💡 Please verify you're pointing at the Codex CLI binary:\n")
    93→		errorMsg.WriteString("     • Try running '" + codexCmd + " --version' directly\n")
    94→		errorMsg.WriteString("     • If you're using a wrapper script, pass the real codex binary with -c\n")
    95→	default:
    96→		errorMsg.WriteString(fmt.Sprintf("  ⚠️  Error running '%s --version'\n", codexCmd))
    97→		if stderrOutput != "" {
    98→			errorMsg.WriteString(fmt.Sprintf("  📋 Error details: %s\n", stderrOutput))
    99→		}
   100→		errorMsg.WriteString("\n")
   101→		errorMsg.WriteString("  💡 Troubleshooting tips:\n")
   102→		errorMsg.WriteString("     • Make sure the Codex CLI is correctly installed\n")
   103→		errorMsg.WriteString("     • Try running 'codex --version' directly in your terminal\n")
   104→		errorMsg.WriteString("     • Check https://developers.openai.com/codex/quickstart for installation help\n")
   105→	}
   106→
   107→	return errorMsg.String()
   108→}
   109→
   110→// Check verifies OpenAI Codex CLI installation and returns version info.
   111→func (p *Provider) Check(customCommand string) spi.CheckResult {
   112→	codexCmd, _ := parseCodexCommand(customCommand)
   113→	isCustomCommand := customCommand != ""
   114→
   115→	resolvedPath := codexCmd
   116→	if !filepath.IsAbs(codexCmd) {
   117→		if path, err := exec.LookPath(codexCmd); err == nil {
   118→			resolvedPath = path
   119→		}
   120→	}
   121→
   122→	versionOutput, versionFlag, stderrOutput, err := runCodexVersionCommand(codexCmd)
   123→	if err != nil {
   124→		errorType := classifyCheckError(err)
   125→		analytics.TrackEvent(analytics.EventCheckInstallFailed, analytics.Properties{
   126→			"provider":            "codex",
   127→			"custom_command":      isCustomCommand,
   128→			"command_path":        codexCmd,
   129→			"resolved_path":       resolvedPath,
   130→			"error_type":          errorType,
   131→			"version_flag":        versionFlag,
   132→			"stderr":              stderrOutput,
   133→			"error_message":       err.Error(),
   134→			"path_classification": classifyCodexPath(codexCmd, resolvedPath),
   135→		})
   136→
   137→		errorMessage := buildCheckErrorMessage(errorType, codexCmd, isCustomCommand, stderrOutput)
   138→
   139→		return spi.CheckResult{
   140→			Success:      false,
   141→			Version:      "",
   142→			Location:     resolvedPath,
   143→			ErrorMessage: errorMessage,
   144→		}
   145→	}
   146→
   147→	if versionOutput == "" {
   148→		errorType := "no_output"
   149→		analytics.TrackEvent(analytics.EventCheckInstallFailed, analytics.Properties{
   150→			"provider":            "codex",
   151→			"custom_command":      isCustomCommand,
   152→			"command_path":        codexCmd,
   153→			"resolved_path":       resolvedPath,
   154→			"error_type":          errorType,
   155→			"version_flag":        versionFlag,
   156→			"stderr":              stderrOutput,
   157→			"path_classification": classifyCodexPath(codexCmd, resolvedPath),
   158→		})
   159→
   160→		errorMessage := buildCheckErrorMessage(errorType, codexCmd, isCustomCommand, stderrOutput)
   161→
   162→		return spi.CheckResult{
   163→			Success:      false,
   164→			Version:      "",
   165→			Location:     resolvedPath,
   166→			ErrorMessage: errorMessage,
   167→		}
   168→	}
   169→
   170→	pathType := classifyCodexPath(codexCmd, resolvedPath)
   171→	analytics.TrackEvent(analytics.EventCheckInstallSuccess, analytics.Properties{
   172→		"provider":       "codex",
   173→		"custom_command": isCustomCommand,
   174→		"command_path":   resolvedPath,
   175→		"path_type":      pathType,
   176→		"version":        versionOutput,
   177→		"version_flag":   versionFlag,
   178→	})
   179→
   180→	slog.Debug("Codex CLI check successful", "version", versionOutput, "location", resolvedPath, "flag", versionFlag)
   181→
   182→	return spi.CheckResult{
   183→		Success:      true,
   184→		Version:      versionOutput,
   185→		Location:     resolvedPath,
   186→		ErrorMessage: "",
   187→	}
   188→}
   189→
   190→// DetectAgent checks if OpenAI Codex CLI has been used in the given project path.
   191→func (p *Provider) DetectAgent(projectPath string, helpOutput bool) bool {
   192→	// Try to find sessions using the shared helper (stop on first match)
   193→	sessions, err := findCodexSessions(projectPath, "", true)
   194→
   195→	// Handle different error cases with helpful output
   196→	if err != nil {
   197→		// Check if it's a home directory error
   198→		if strings.Contains(err.Error(), "home directory") {
   199→			slog.Debug("DetectAgent: Failed to resolve user home directory", "error", err)
   200→			if helpOutput {
   201→				fmt.Println()
   202→				log.UserWarn("Could not scan Codex CLI sessions for this directory.\n")
   203→				log.UserMessage("Reason: failed to determine your home directory.\n")
   204→				fmt.Println()
   205→			}
   206→			return false
   207→		}
   208→
   209→		// Check if it's a sessions directory error
   210→		if strings.Contains(err.Error(), "sessions directory not accessible") || strings.Contains(err.Error(), "sessions root") {
   211→			homeDir, _ := osUserHomeDir()
   212→			sessionsRoot := codexSessionsRoot(homeDir)
   213→
   214→			slog.Debug("DetectAgent: Codex sessions directory not accessible", "error", err)
   215→			if helpOutput {
   216→				fmt.Println()
   217→				log.UserWarn("No Codex CLI sessions were found for this directory.\n")
   218→				log.UserMessage("Codex CLI stores activity under ~/.codex/sessions/YYYY/MM/DD/. We couldn't find that directory.\n\n")
   219→				log.UserMessage("To fix this:\n")
   220→				log.UserMessage("  1. Run `specstory run codex` to launch Codex CLI in this project\n")
   221→				log.UserMessage("  2. Or start Codex CLI manually, then run `specstory sync codex` afterward\n\n")
   222→				log.UserMessage("Expected sessions directory: %s\n", sessionsRoot)
   223→				fmt.Println()
   224→			}
   225→			return false
   226→		}
   227→
   228→		// Unknown error
   229→		slog.Debug("DetectAgent: Error finding sessions", "error", err)
   230→		return false
   231→	}
   232→
   233→	// Check if we found any sessions
   234→	if len(sessions) > 0 {
   235→		session := sessions[0]
   236→		slog.Debug("DetectAgent: Codex CLI activity detected",
   237→			"sessionID", session.SessionID,
   238→			"sessionPath", session.SessionPath)
   239→		return true
   240→	}
   241→
   242→	// No sessions found - provide helpful output
   243→	if helpOutput {
   244→		homeDir, _ := osUserHomeDir()
   245→		sessionsRoot := codexSessionsRoot(homeDir)
   246→
   247→		fmt.Println()
   248→		log.UserWarn("No Codex CLI sessions were found for this directory.\n")
   249→		log.UserMessage("Codex CLI hasn't saved a session with this working directory yet.\n")
   250→		log.UserMessage("Codex stores sessions in ~/.codex/sessions/YYYY/MM/DD/ as JSONL files.\n\n")
   251→		log.UserMessage("To fix this:\n")
   252→		log.UserMessage("  1. Run `specstory run codex` to launch Codex CLI here\n")
   253→		log.UserMessage("  2. Or open Codex CLI manually in this project, then try syncing again\n\n")
   254→		log.UserMessage("Checked sessions directory: %s\n", sessionsRoot)
   255→		fmt.Println()
   256→	}
   257→
   258→	return false
   259→}
   260→
   261→// GetAgentChatSessions retrieves chat sessions for the given project path.
   262→func (p *Provider) GetAgentChatSessions(projectPath string, debugRaw bool) ([]spi.AgentChatSession, error) {
   263→	// Find all sessions for this project (don't stop on first)
   264→	sessions, err := findCodexSessions(projectPath, "", false)
   265→	if err != nil {
   266→		// If sessions directory doesn't exist, return empty list (not an error)
   267→		if strings.Contains(err.Error(), "sessions directory not accessible") ||
   268→			strings.Contains(err.Error(), "sessions root") ||
   269→			strings.Contains(err.Error(), "home directory") {
   270→			return []spi.AgentChatSession{}, nil
   271→		}
   272→		return nil, fmt.Errorf("failed to find codex sessions: %w", err)
   273→	}
   274→
   275→	// Convert to AgentChatSession structs
   276→	var result []spi.AgentChatSession
   277→	for _, sessionInfo := range sessions {
   278→		session, err := processSessionToAgentChat(&sessionInfo, projectPath, debugRaw)
   279→		if err != nil {
   280→			slog.Debug("GetAgentChatSessions: Failed to process session",
   281→				"sessionID", sessionInfo.SessionID,
   282→				"error", err)
   283→			continue // Skip sessions we can't process
   284→		}
   285→
   286→		// Skip empty sessions (processSessionToAgentChat returns nil for empty sessions)
   287→		if session == nil {
   288→			slog.Debug("GetAgentChatSessions: Skipping empty session",
   289→				"sessionID", sessionInfo.SessionID)
   290→			continue
   291→		}
   292→
   293→		result = append(result, *session)
   294→	}
   295→
   296→	return result, nil
   297→}
   298→
   299→// GetAgentChatSession retrieves a chat session by ID.
   300→func (p *Provider) GetAgentChatSession(projectPath string, sessionID string, debugRaw bool) (*spi.AgentChatSession, error) {
   301→	// Find the specific session (will short-circuit when found)
   302→	sessions, err := findCodexSessions(projectPath, sessionID, false)
   303→	if err != nil {
   304→		// If sessions directory doesn't exist, return nil (not an error)
   305→		if strings.Contains(err.Error(), "sessions directory not accessible") ||
   306→			strings.Contains(err.Error(), "sessions root") ||
   307→			strings.Contains(err.Error(), "home directory") {
   308→			return nil, nil
   309→		}
   310→		return nil, fmt.Errorf("failed to find codex sessions: %w", err)
   311→	}
   312→
   313→	// Session not found (empty result)
   314→	if len(sessions) == 0 {
   315→		return nil, nil
   316→	}
   317→
   318→	// Process the first (and only) session using shared helper
   319→	return processSessionToAgentChat(&sessions[0], projectPath, debugRaw)
   320→}
   321→
   322→// ExecAgentAndWatch executes the Codex CLI in interactive mode and monitors for session updates.
   323→// The function blocks until the Codex CLI exits. During execution, it watches for JSONL file changes
   324→// and invokes sessionCallback for each update, enabling real-time markdown generation and cloud sync.
   325→func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   326→	slog.Info("ExecAgentAndWatch: Starting Codex CLI execution and monitoring",
   327→		"projectPath", projectPath,
   328→		"customCommand", customCommand,
   329→		"resumeSessionID", resumeSessionID,
   330→		"debugRaw", debugRaw)
   331→
   332→	// Log if resuming a specific session
   333→	if resumeSessionID != "" {
   334→		slog.Info("ExecAgentAndWatch: Will resume specific Codex session", "sessionID", resumeSessionID)
   335→	}
   336→
   337→	// Set up the callback which enables real-time markdown generation and cloud sync during
   338→	// interactive sessions. As Codex CLI writes JSONL updates, the watcher detects changes
   339→	// and invokes this callback, allowing immediate processing without blocking the agent's
   340→	// execution. The defer ensures cleanup when the agent exits.
   341→	SetWatcherCallback(sessionCallback)
   342→	defer ClearWatcherCallback()
   343→
   344→	// Set debug raw mode for the watcher
   345→	SetWatcherDebugRaw(debugRaw)
   346→
   347→	// Start watching for Codex sessions in the background
   348→	slog.Info("Initializing Codex session monitoring...")
   349→
   350→	if err := WatchForCodexSessions(projectPath, resumeSessionID); err != nil {
   351→		// Log the error but don't fail - watcher might work later
   352→		slog.Error("Failed to start Codex session watcher", "error", err)
   353→	}
   354→
   355→	// Execute Codex CLI - this blocks until Codex exits
   356→	slog.Info("Executing Codex CLI", "command", customCommand, "resumeSessionID", resumeSessionID)
   357→	err := ExecuteCodex(customCommand, resumeSessionID)
   358→
   359→	// Stop the watcher goroutine and wait for it to finish before returning
   360→	slog.Info("Codex CLI has exited, stopping watcher")
   361→	StopWatcher()
   362→
   363→	// Return any execution error
   364→	if err != nil {
   365→		return fmt.Errorf("codex CLI execution failed: %w", err)
   366→	}
   367→
   368→	return nil
   369→}
   370→
   371→// WatchAgent watches for Codex CLI agent activity and calls the callback with AgentChatSession
   372→// Does NOT execute the agent - only watches for existing activity
   373→// Runs until error or context cancellation (blocks indefinitely)
   374→func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   375→	slog.Info("WatchAgent: Starting Codex CLI activity monitoring",
   376→		"projectPath", projectPath,
   377→		"debugRaw", debugRaw)
   378→
   379→	// The watcher callback directly passes AgentChatSession (which now contains SessionData)
   380→	wrappedCallback := func(agentChatSession *spi.AgentChatSession) {
   381→		slog.Debug("WatchAgent: Received AgentChatSession",
   382→			"sessionID", agentChatSession.SessionID,
   383→			"hasSessionData", agentChatSession.SessionData != nil)
   384→
   385→		// Call the user's callback with the AgentChatSession
   386→		sessionCallback(agentChatSession)
   387→	}
   388→
   389→	// Set up the callback for the watcher
   390→	SetWatcherCallback(wrappedCallback)
   391→	defer ClearWatcherCallback()
   392→
   393→	// Set debug raw mode for the watcher
   394→	SetWatcherDebugRaw(debugRaw)
   395→
   396→	// Start watching for Codex sessions in the background
   397→	slog.Info("WatchAgent: Initializing Codex session monitoring...")
   398→
   399→	if err := WatchForCodexSessions(projectPath, ""); err != nil {
   400→		slog.Error("WatchAgent: Failed to start Codex session watcher", "error", err)
   401→		return fmt.Errorf("failed to start watcher: %w", err)
   402→	}
   403→
   404→	// Block until context is cancelled
   405→	// The watcher runs in a background goroutine and will continue
   406→	// until context is cancelled or the process exits
   407→	slog.Info("WatchAgent: Watcher started, blocking until context cancelled")
   408→
   409→	// Wait for context cancellation
   410→	<-ctx.Done()
   411→
   412→	slog.Info("WatchAgent: Context cancelled, stopping watcher")
   413→	StopWatcher()
   414→
   415→	return ctx.Err()
   416→}
   417→
   418→// findCodexSessions traverses the Codex CLI sessions directory structure and finds
   419→// sessions that match the given project path.
   420→//
   421→// Short-circuit behavior:
   422→//   - If targetSessionID is provided: stops when that specific session is found (ignores stopOnFirst)
   423→//   - If targetSessionID is empty and stopOnFirst is true: stops after finding first matching session
   424→//   - If targetSessionID is empty and stopOnFirst is false: returns all matching sessions
   425→func findCodexSessions(projectPath string, targetSessionID string, stopOnFirst bool) ([]codexSessionInfo, error) {
   426→	normalizedProjectPath := normalizeCodexPath(projectPath)
   427→	if normalizedProjectPath == "" {
   428→		slog.Debug("findCodexSessions: Unable to normalize project path", "projectPath", projectPath)
   429→	}
   430→
   431→	homeDir, err := osUserHomeDir()
   432→	if err != nil {
   433→		slog.Debug("findCodexSessions: Failed to resolve user home directory", "error", err)
   434→		return nil, fmt.Errorf("failed to determine home directory: %w", err)
   435→	}
   436→
   437→	sessionsRoot := codexSessionsRoot(homeDir)
   438→	rootInfo, err := os.Stat(sessionsRoot)
   439→	if err != nil {
   440→		if os.IsNotExist(err) {
   441→			slog.Debug("findCodexSessions: Codex sessions directory not found", "path", sessionsRoot)
   442→		} else {
   443→			slog.Debug("findCodexSessions: Failed to stat Codex sessions directory", "path", sessionsRoot, "error", err)
   444→		}
   445→		return nil, fmt.Errorf("sessions directory not accessible: %w", err)
   446→	}
   447→
   448→	if !rootInfo.IsDir() {
   449→		slog.Debug("findCodexSessions: Codex sessions root is not a directory", "path", sessionsRoot)
   450→		return nil, fmt.Errorf("sessions root is not a directory: %s", sessionsRoot)
   451→	}
   452→
   453→	yearEntries, err := readDirSortedDesc(sessionsRoot)
   454→	if err != nil {
   455→		slog.Debug("findCodexSessions: Failed to read Codex sessions root", "path", sessionsRoot, "error", err)
   456→		return nil, fmt.Errorf("failed to read sessions root: %w", err)
   457→	}
   458→
   459→	var sessions []codexSessionInfo
   460→
   461→	// Traverse year/month/day directory structure
   462→	for _, yearEntry := range yearEntries {
   463→		if !yearEntry.IsDir() {
   464→			continue
   465→		}
   466→
   467→		yearPath := filepath.Join(sessionsRoot, yearEntry.Name())
   468→		monthEntries, err := readDirSortedDesc(yearPath)
   469→		if err != nil {
   470→			slog.Debug("findCodexSessions: Failed to read Codex year directory", "path", yearPath, "error", err)
   471→			continue
   472→		}
   473→
   474→		for _, monthEntry := range monthEntries {
   475→			if !monthEntry.IsDir() {
   476→				continue
   477→			}
   478→
   479→			monthPath := filepath.Join(yearPath, monthEntry.Name())
   480→			dayEntries, err := readDirSortedDesc(monthPath)
   481→			if err != nil {
   482→				slog.Debug("findCodexSessions: Failed to read Codex month directory", "path", monthPath, "error", err)
   483→				continue
   484→			}
   485→
   486→			for _, dayEntry := range dayEntries {
   487→				if !dayEntry.IsDir() {
   488→					continue
   489→				}
   490→
   491→				dayPath := filepath.Join(monthPath, dayEntry.Name())
   492→				sessionEntries, err := readDirSortedDesc(dayPath)
   493→				if err != nil {
   494→					slog.Debug("findCodexSessions: Failed to read Codex day directory", "path", dayPath, "error", err)
   495→					continue
   496→				}
   497→
   498→				for _, sessionEntry := range sessionEntries {
   499→					if sessionEntry.IsDir() {
   500→						continue
   501→					}
   502→					if filepath.Ext(sessionEntry.Name()) != ".jsonl" {
   503→						continue
   504→					}
   505→
   506→					sessionPath := filepath.Join(dayPath, sessionEntry.Name())
   507→					meta, err := loadCodexSessionMeta(sessionPath)
   508→					if err != nil {
   509→						slog.Debug("findCodexSessions: Failed to load Codex session meta", "path", sessionPath, "error", err)
   510→						continue
   511→					}
   512→
   513→					sessionID := strings.TrimSpace(meta.Payload.ID)
   514→					normalizedCWD := normalizeCodexPath(meta.Payload.CWD)
   515→					if normalizedCWD == "" {
   516→						slog.Debug("findCodexSessions: Session meta missing cwd", "sessionID", sessionID, "path", sessionPath)
   517→						continue
   518→					}
   519→
   520→					// Check if this session matches the project path
   521→					matched := false
   522→					if normalizedProjectPath != "" {
   523→						if normalizedCWD == normalizedProjectPath || strings.EqualFold(normalizedCWD, normalizedProjectPath) {
   524→							matched = true
   525→						}
   526→					} else if normalizedCWD == projectPath || strings.EqualFold(normalizedCWD, projectPath) {
   527→						matched = true
   528→					}
   529→
   530→					if matched {
   531→						// If we're searching for a specific session, skip sessions that don't match
   532→						if targetSessionID != "" && sessionID != targetSessionID {
   533→							continue
   534→						}
   535→
   536→						slog.Debug("findCodexSessions: Codex CLI session matched project",
   537→							"sessionID", sessionID,
   538→							"sessionPath", sessionPath)
   539→
   540→						sessions = append(sessions, codexSessionInfo{
   541→							SessionID:   sessionID,
   542→							SessionPath: sessionPath,
   543→							Meta:        meta,
   544→						})
   545→
   546→						// Short-circuit logic:
   547→						// 1. If we have a target sessionID and this matches, we're done
   548→						if targetSessionID != "" && sessionID == targetSessionID {
   549→							slog.Debug("findCodexSessions: Found target session, stopping search", "sessionID", targetSessionID)
   550→							return sessions, nil
   551→						}
   552→
   553→						// 2. If stopOnFirst is true (and no target sessionID), return first match
   554→						if targetSessionID == "" && stopOnFirst {
   555→							return sessions, nil
   556→						}
   557→
   558→						// 3. Otherwise, continue collecting all matching sessions
   559→					}
   560→				}
   561→			}
   562→		}
   563→	}
   564→
   565→	return sessions, nil
   566→}
   567→
   568→// readSessionRawData reads all JSONL lines from a Codex CLI session file and returns
   569→// both the parsed records and the raw JSONL content.
   570→func readSessionRawData(sessionPath string) ([]map[string]interface{}, string, error) {
   571→	file, err := os.Open(sessionPath)
   572→	if err != nil {
   573→		return nil, "", fmt.Errorf("failed to open session file: %w", err)
   574→	}
   575→	defer func() {
   576→		_ = file.Close()
   577→	}()
   578→
   579→	var records []map[string]interface{}
   580→	var rawBuilder strings.Builder
   581→
   582→	// Use bufio.Reader instead of Scanner to handle arbitrarily large lines
   583→	// Scanner has a token size limit (even with custom buffer), but Reader does not
   584→	reader := bufio.NewReader(file)
   585→
   586→	lineNumber := 0
   587→	for {
   588→		// Read line using ReadString which has no size limit
   589→		line, err := reader.ReadString('\n')
   590→		line = strings.TrimSuffix(line, "\n")
   591→
   592→		// EOF is expected at end of file, other errors are genuine failures
   593→		if err != nil && err != io.EOF {
   594→			return nil, "", fmt.Errorf("error reading line %d: %w", lineNumber+1, err)
   595→		}
   596→
   597→		// Determine if we're at end of file and if we have content to process
   598→		atEOF := err == io.EOF
   599→		hasContent := len(line) > 0
   600→
   601→		// Increment line number for every line read (including empty lines) to match text editor line numbers
   602→		if hasContent || !atEOF {
   603→			lineNumber++
   604→		}
   605→
   606→		// If no content, either skip empty line or exit at EOF
   607→		if !hasContent {
   608→			if atEOF {
   609→				break // Reached end of file with no content
   610→			}
   611→			continue // Empty line in middle of file, skip it
   612→		}
   613→
   614→		// Sanity check to prevent OOM from pathological files
   615→		if len(line) > maxReasonableLineSize {
   616→			slog.Warn("line exceeds reasonable size limit",
   617→				"lineNumber", lineNumber,
   618→				"sizeMB", len(line)/MB,
   619→				"limitMB", maxReasonableLineSize/MB,
   620→				"file", filepath.Base(sessionPath))
   621→			return nil, "", fmt.Errorf("line %d exceeds reasonable size limit (%d MB): refusing to process potentially malformed file",
   622→				lineNumber, maxReasonableLineSize/MB)
   623→		}
   624→
   625→		// Log when processing unusually large lines (helps debug performance issues)
   626→		if len(line) > 10*MB {
   627→			slog.Debug("processing large JSONL line",
   628→				"lineNumber", lineNumber,
   629→				"sizeMB", len(line)/MB,
   630→				"file", filepath.Base(sessionPath))
   631→		}
   632→
   633→		// Trim whitespace and skip empty lines
   634→		line = strings.TrimSpace(line)
   635→		if line == "" {
   636→			if atEOF {
   637→				break
   638→			}
   639→			continue
   640→		}
   641→
   642→		// Add to raw data
   643→		rawBuilder.WriteString(line)
   644→		rawBuilder.WriteString("\n")
   645→
   646→		// Parse JSON
   647→		var record map[string]interface{}
   648→		if err := json.Unmarshal([]byte(line), &record); err != nil {
   649→			slog.Debug("readSessionRawData: Failed to parse JSON line",
   650→				"error", err,
   651→				"lineNumber", lineNumber,
   652→				"line", line[:min(len(line), 100)])
   653→			// After processing record, check if we're done
   654→			if atEOF {
   655→				break
   656→			}
   657→			continue
   658→		}
   659→
   660→		records = append(records, record)
   661→
   662→		// After processing record, check if we're done
   663→		if atEOF {
   664→			break
   665→		}
   666→	}
   667→
   668→	return records, rawBuilder.String(), nil
   669→}
   670→
   671→// loadCodexSessionMeta reads the first JSON line from a session file and parses the session metadata.
   672→func loadCodexSessionMeta(sessionPath string) (*codexSessionMeta, error) {
   673→	file, err := os.Open(sessionPath)
   674→	if err != nil {
   675→		return nil, err
   676→	}
   677→	defer func() {
   678→		_ = file.Close()
   679→	}()
   680→
   681→	scanner := bufio.NewScanner(file)
   682→	if !scanner.Scan() {
   683→		if scanErr := scanner.Err(); scanErr != nil {
   684→			return nil, scanErr
   685→		}
   686→		return nil, errors.New("codex session meta not found")
   687→	}
   688→
   689→	line := strings.TrimSpace(scanner.Text())
   690→	if line == "" {
   691→		return nil, errors.New("codex session meta is empty")
   692→	}
   693→
   694→	var meta codexSessionMeta
   695→	if err := json.Unmarshal([]byte(line), &meta); err != nil {
   696→		return nil, fmt.Errorf("failed to parse codex session meta: %w", err)
   697→	}
   698→
   699→	if meta.Type != "session_meta" {
   700→		return nil, fmt.Errorf("unexpected codex session record type: %s", meta.Type)
   701→	}
   702→
   703→	return &meta, nil
   704→}
   705→
   706→// processSessionToAgentChat converts a codexSessionInfo into an AgentChatSession by reading
   707→// the session data, generating SessionData, and optionally writing debug files. Returns nil if
   708→// the session is empty or cannot be read.
   709→func processSessionToAgentChat(sessionInfo *codexSessionInfo, workspaceRoot string, debugRaw bool) (*spi.AgentChatSession, error) {
   710→	// Read the session data
   711→	records, rawData, err := readSessionRawData(sessionInfo.SessionPath)
   712→	if err != nil {
   713→		return nil, fmt.Errorf("failed to read session data: %w", err)
   714→	}
   715→
   716→	// Skip empty sessions
   717→	if len(records) == 0 {
   718→		return nil, nil
   719→	}
   720→
   721→	// Get timestamp from metadata
   722→	timestamp := sessionInfo.Meta.Timestamp
   723→
   724→	// Generate slug from first user message
   725→	firstUserMessage := findFirstUserMessage(records)
   726→	slug := spi.GenerateFilenameFromUserMessage(firstUserMessage)
   727→	if slug == "" {
   728→		slog.Debug("processSessionToAgentChat: No user message for slug yet",
   729→			"sessionID", sessionInfo.SessionID)
   730→	} else {
   731→		slog.Debug("processSessionToAgentChat: Generated slug from user message",
   732→			"sessionID", sessionInfo.SessionID,
   733→			"slug", slug)
   734→	}
   735→
   736→	// Generate SessionData from records
   737→	sessionData, err := GenerateAgentSession(records, workspaceRoot)
   738→	if err != nil {
   739→		slog.Error("Failed to generate SessionData", "sessionId", sessionInfo.SessionID, "error", err)
   740→		return nil, fmt.Errorf("failed to generate SessionData: %w", err)
   741→	}
   742→
   743→	// Write provider-specific debug files if requested
   744→	if debugRaw {
   745→		if err := writeDebugRawFiles(sessionInfo.SessionID, records); err != nil {
   746→			slog.Debug("processSessionToAgentChat: Failed to write debug files",
   747→				"sessionID", sessionInfo.SessionID,
   748→				"error", err)
   749→			// Don't fail the operation if debug output fails
   750→		}
   751→	}
   752→
   753→	return &spi.AgentChatSession{
   754→		SessionID:   sessionInfo.SessionID,
   755→		CreatedAt:   timestamp,
   756→		Slug:        slug,
   757→		SessionData: sessionData,
   758→		RawData:     rawData,
   759→	}, nil
   760→}
   761→
   762→// writeDebugRawFiles writes debug JSON files for a Codex CLI session.
   763→// Each record is written as a numbered JSON file in .specstory/debug/<session-id>/
   764→func writeDebugRawFiles(sessionID string, records []map[string]interface{}) error {
   765→	// Get the debug directory path
   766→	debugDir := spi.GetDebugDir(sessionID)
   767→
   768→	// Create the debug directory
   769→	if err := os.MkdirAll(debugDir, 0755); err != nil {
   770→		return fmt.Errorf("failed to create debug directory: %w", err)
   771→	}
   772→
   773→	// Write each record as a pretty-printed JSON file
   774→	for index, record := range records {
   775→		// Create filename with 1-based index for readability
   776→		filename := fmt.Sprintf("%d.json", index+1)
   777→		debugPath := filepath.Join(debugDir, filename)
   778→
   779→		// Pretty print the record
   780→		prettyJSON, err := json.MarshalIndent(record, "", "  ")
   781→		if err != nil {
   782→			slog.Debug("writeDebugRawFiles: Failed to marshal record to JSON",
   783→				"index", index,
   784→				"error", err)
   785→			continue
   786→		}
   787→
   788→		// Write the file
   789→		if err := os.WriteFile(debugPath, prettyJSON, 0644); err != nil {
   790→			slog.Debug("writeDebugRawFiles: Failed to write debug file",
   791→				"path", debugPath,
   792→				"error", err)
   793→			continue
   794→		}
   795→
   796→		slog.Debug("writeDebugRawFiles: Wrote debug file",
   797→			"path", debugPath,
   798→			"index", index)
   799→	}
   800→
   801→	return nil
   802→}
   803→
   804→// findFirstUserMessage extracts the first user message from Codex CLI session records.
   805→// Returns empty string if no user message is found.
   806→func findFirstUserMessage(records []map[string]interface{}) string {
   807→	for _, record := range records {
   808→		// Get record type
   809→		recordType, ok := record["type"].(string)
   810→		if !ok || recordType != "event_msg" {
   811→			continue
   812→		}
   813→
   814→		// Get payload
   815→		payload, ok := record["payload"].(map[string]interface{})
   816→		if !ok {
   817→			continue
   818→		}
   819→
   820→		// Check if this is a user message
   821→		payloadType, ok := payload["type"].(string)
   822→		if !ok || payloadType != "user_message" {
   823→			continue
   824→		}
   825→
   826→		// Extract the message content
   827→		message, ok := payload["message"].(string)
   828→		if !ok || message == "" {
   829→			continue
   830→		}
   831→
   832→		// Found the first user message
   833→		slog.Debug("findFirstUserMessage: Found first user message",
   834→			"message", message[:min(len(message), 100)])
   835→		return message
   836→	}
   837→
   838→	slog.Debug("findFirstUserMessage: No user message found in session")
   839→	return ""
   840→}
   841→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:55Z)**_

Now let me check if there are any tests for the watcher to better understand its behavior:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:56Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find test files in droidcli package

`find /Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli -name "*test.go" -type f`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/markdown_tools_test.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:58Z)**_

Let me check the provider_test to see how the watcher is tested:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:58:59Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg/providers/droidcli/provider_test.go` pattern `watchSessions|WatchAgent|ExecAgentAndWatch`
```
<tool_use_error>InputValidationError: Grep failed due to the following issue:
An unexpected parameter `context` was provided</tool_use_error>
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:59:01Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg/providers/droidcli/provider_test.go` pattern `watchSessions|WatchAgent|ExecAgentAndWatch`
```
<tool_use_error>InputValidationError: Grep failed due to the following issue:
An unexpected parameter `context_lines` was provided</tool_use_error>
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:59:03Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg/providers/droidcli/provider_test.go` pattern `watchSessions|WatchAgent|ExecAgentAndWatch`
```
No matches found
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:59:05Z)**_

Now let me look at the types and parser to understand the data structure better:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:59:05Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/types.go`
```
     1→package droidcli
     2→
     3→import "encoding/json"
     4→
     5→// fdBlockKind describes the semantic type of a parsed session chunk.
     6→type fdBlockKind int
     7→
     8→const (
     9→	blockText fdBlockKind = iota
    10→	blockTool
    11→	blockTodo
    12→	blockSummary
    13→)
    14→
    15→// fdBlock represents a normalized slice of the Factory Droid transcript.
    16→type fdBlock struct {
    17→	Kind        fdBlockKind
    18→	Role        string
    19→	MessageID   string
    20→	Timestamp   string
    21→	Model       string
    22→	Text        string
    23→	IsReasoning bool
    24→	Tool        *fdToolCall
    25→	Todo        *fdTodoState
    26→	Summary     *fdSummary
    27→}
    28→
    29→// fdToolCall captures a tool invocation plus its result.
    30→type fdToolCall struct {
    31→	ID           string
    32→	Name         string
    33→	Input        json.RawMessage
    34→	RiskLevel    string
    35→	RiskReason   string
    36→	Result       *fdToolResult
    37→	InvocationAt string
    38→}
    39→
    40→// fdToolResult contains the textual output of a tool.
    41→type fdToolResult struct {
    42→	Content string
    43→	IsError bool
    44→}
    45→
    46→// fdTodoState tracks todo list snapshots emitted by the agent.
    47→type fdTodoState struct {
    48→	Items []fdTodoItem
    49→}
    50→
    51→// fdTodoItem represents a single todo entry.
    52→type fdTodoItem struct {
    53→	Description string
    54→	Status      string
    55→}
    56→
    57→// fdSummary stores compaction summary text from Factory Droid.
    58→type fdSummary struct {
    59→	Title string
    60→	Body  string
    61→}
    62→
    63→// fdSession aggregates parsed metadata and blocks.
    64→type fdSession struct {
    65→	ID            string
    66→	Title         string
    67→	CreatedAt     string
    68→	WorkspaceRoot string
    69→	Blocks        []fdBlock
    70→	Slug          string
    71→	RawData       string
    72→}
    73→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:59:05Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Read first part of parser.go to see parseFactorySession and related functions

`head -100 /Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser.go`
```
package droidcli

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
)

type jsonlEnvelope struct {
	Type string `json:"type"`
}

type sessionStartEvent struct {
	Type          string `json:"type"`
	Timestamp     string `json:"timestamp"`
	ID            string `json:"id"`
	Title         string `json:"title"`
	SessionTitle  string `json:"sessionTitle"`
	CreatedAt     string `json:"created_at"`
	CWD           string `json:"cwd"`
	WorkspaceRoot string `json:"workspace_root"`
	Session       struct {
		ID            string `json:"id"`
		Title         string `json:"title"`
		CreatedAt     string `json:"created_at"`
		CWD           string `json:"cwd"`
		WorkspaceRoot string `json:"workspace_root"`
	} `json:"session"`
}

type messageEvent struct {
	Type      string          `json:"type"`
	ID        string          `json:"id"`
	Timestamp string          `json:"timestamp"`
	Message   messagePayload  `json:"message"`
	Metadata  json.RawMessage `json:"metadata"`
}

type messagePayload struct {
	Role    string           `json:"role"`
	Model   string           `json:"model"`
	Content []contentPayload `json:"content"`
}

type contentPayload struct {
	Type            string          `json:"type"`
	Text            string          `json:"text"`
	ID              string          `json:"id"`
	Name            string          `json:"name"`
	Input           json.RawMessage `json:"input"`
	ToolUseID       string          `json:"tool_use_id"`
	Content         json.RawMessage `json:"content"`
	IsError         bool            `json:"is_error"`
	RiskLevel       string          `json:"riskLevel"`
	RiskLevelReason string          `json:"riskLevelReason"`
}

type todoEvent struct {
	Type      string       `json:"type"`
	Timestamp string       `json:"timestamp"`
	Todos     []fdTodoItem `json:"todos"`
}

type compactionEvent struct {
	Type      string    `json:"type"`
	Timestamp string    `json:"timestamp"`
	Summary   fdSummary `json:"summary"`
}

// parseFactorySession converts a Factory Droid JSONL transcript into an fdSession.
func parseFactorySession(filePath string) (*fdSession, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("droidcli: unable to open session %s: %w", filePath, err)
	}
	defer func() {
		_ = file.Close()
	}()

	session := &fdSession{Blocks: make([]fdBlock, 0, 64)}
	toolIndex := make(map[string]*fdToolCall)
	var rawBuilder strings.Builder
	var firstUserText string
	var firstTimestamp string

	scanErr := scanLines(file, func(line string) error {
		rawBuilder.WriteString(line)
		rawBuilder.WriteByte('\n')

		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:59:25Z)**_

Perfect! Now I have a comprehensive understanding of the Droid provider's file watching implementation. Let me compile all the findings:

## Droid Provider File Watching Implementation Report

Based on my exploration of the codebase, here's a detailed analysis of how the Droid provider implements file watching with a 1-second poll:

### 1. Watcher Implementation and Polling Mechanism

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go`

The watcher uses a time-based ticker mechanism:

```go
const droidWatchInterval = 1 * time.Second

func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	state := &watchState{lastProcessed: make(map[string]int64)}
	if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
		return err
	}

	ticker := time.NewTicker(droidWatchInterval)  // 1-second poll interval
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:  // Fires every 1 second
			if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
				slog.Debug("droidcli: scan failed", "error", err)
			}
		}
	}
}
```

**Key characteristics:**
- Uses `time.NewTicker(1 * time.Second)` for polling
- Context-aware: stops when `ctx.Done()` signals
- Runs `scanAndProcessSessions()` on each tick
- Initial scan before entering the loop
- Logs errors but doesn't exit on scan failures

### 2. How the Watcher is Started and Stopped

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider.go`

**Function:** `ExecAgentAndWatch()` (lines 135-159)

```go
func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	if sessionCallback == nil {
		return ExecuteDroid(customCommand, resumeSessionID)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	watchErr := make(chan error, 1)
	go func() {
		watchErr <- watchSessions(ctx, projectPath, debugRaw, sessionCallback)
	}()

	err := ExecuteDroid(customCommand, resumeSessionID)
	cancel()  // Stop the watcher

	if werr := <-watchErr; werr != nil && !errors.Is(werr, context.Canceled) {
		slog.Warn("droidcli: watcher stopped with error", "error", werr)
	}

	if err != nil {
		return fmt.Errorf("factory droid CLI execution failed: %w", err)
	}
	return nil
}
```

**Function:** `WatchAgent()` (lines 161-166)

```go
func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	if sessionCallback == nil {
		return fmt.Errorf("session callback is required")
	}
	return watchSessions(ctx, projectPath, debugRaw, sessionCallback)
}
```

**Startup/Shutdown mechanism:**
- Started: Goroutine spawned in `ExecAgentAndWatch()` or called directly in `WatchAgent()`
- Context-based cancellation propagates to stop the ticker
- `defer cancel()` ensures cleanup when the command completes
- Error from watcher read from channel after cancellation

### 3. What Files/Directories it Watches

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/path_utils.go`

The watcher monitors:

```go
const (
	factoryRootDir     = ".factory"
	factorySessionsDir = "sessions"
)

func resolveSessionsDir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("droidcli: cannot resolve home dir: %w", err)
	}
	dir := filepath.Join(home, factoryRootDir, factorySessionsDir)
	return dir, nil
}

func listSessionFiles() ([]sessionFile, error) {
	dir, err := resolveSessionsDir()
	if err != nil {
		return nil, err
	}
	files := make([]sessionFile, 0, 64)
	walker := func(path string, d fs.DirEntry, walkErr error) error {
		if walkErr != nil {
			return nil
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(d.Name()) != ".jsonl" {
			return nil
		}
		info, err := d.Info()
		if err != nil {
			return nil
		}
		files = append(files, sessionFile{
			Path:     path,
			ModTime:  info.ModTime().UnixNano(),
			FileName: d.Name(),
		})
		return nil
	}
	if err := filepath.WalkDir(dir, walker); err != nil {
		if os.IsNotExist(err) {
			return []sessionFile{}, nil
		}
		return nil, fmt.Errorf("droidcli: unable to read sessions dir: %w", err)
	}
	sort.Slice(files, func(i, j int) bool {
		return files[i].ModTime > files[j].ModTime
	})
	return files, nil
}
```

**Watched location:** `~/.factory/sessions/`

**File criteria:**
- Only `.jsonl` files
- Files stored recursively (walk all subdirectories)
- Sorted by modification time (most recent first)
- Returns empty list if directory doesn't exist (not an error)

### 4. How it Processes Changes When Detected

**File:** `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/watcher.go` (lines 43-69)

```go
type watchState struct {
	lastProcessed map[string]int64
}

func scanAndProcessSessions(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) error {
	files, err := listSessionFiles()  // Poll all .jsonl files
	if err != nil {
		return err
	}

	for _, file := range files {
		// Skip if already processed and file hasn't changed
		if last, ok := state.lastProcessed[file.Path]; ok && last >= file.ModTime {
			continue
		}
		
		// Skip if file doesn't mention the target project
		if projectPath != "" && !sessionMentionsProject(file.Path, projectPath) {
			continue
		}
		
		// Parse the session file
		session, err := parseFactorySession(file.Path)
		if err != nil {
			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
			continue
		}
		
		// Convert to standardized format
		chat := convertToAgentSession(session, projectPath, debugRaw)
		if chat == nil {
			continue
		}
		
		// Update state with new modification time
		state.lastProcessed[file.Path] = file.ModTime
		
		// Dispatch session in goroutine with panic recovery
		dispatchSession(sessionCallback, chat)
	}
	return nil
}

func dispatchSession(sessionCallback func(*spi.AgentChatSession), session *spi.AgentChatSession) {
	if sessionCallback == nil || session == nil {
		return
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				slog.Error("droidcli: session callback panicked", "panic", r)
			}
		}()
		sessionCallback(session)
	}()
}
```

**Processing flow:**

1. **Detection:** On each 1-second tick, list all `.jsonl` files in `~/.factory/sessions/`
2. **Change detection:** Compare file modification time (`ModTime`) against `lastProcessed` map
3. **Project filtering:** Skip files that don't mention the target project path
4. **Parsing:** Parse JSONL file via `parseFactorySession()` 
5. **Conversion:** Convert Factory Droid format to standardized `spi.AgentChatSession`
6. **State update:** Store the new `ModTime` in `lastProcessed` map
7. **Dispatch:** Call session callback asynchronously in a goroutine with panic recovery

**State management:**
- `watchState.lastProcessed` tracks file path → modification time
- Only reprocesses files when `ModTime` is newer than last known time
- Prevents duplicate processing of unchanged files

---

### Summary Table

| Aspect | Details |
|--------|---------|
| **Poll Interval** | 1 second (`time.NewTicker(1 * time.Second)`) |
| **Watched Directory** | `~/.factory/sessions/` |
| **File Pattern** | `*.jsonl` files (recursively) |
| **Change Detection** | File modification time comparison |
| **State Tracking** | In-memory map: filepath → last ModTime (int64 nanoseconds) |
| **Processing** | Asynchronous via goroutine with panic recovery |
| **Stop Mechanism** | Context cancellation via `ctx.Done()` |
| **Project Filtering** | Checks if session file mentions the project path |

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-29 15:59:35Z)**_

Excellent! Now I have all the information needed. Let me compile a comprehensive exploration report of the fsnotify-based file watching implementations across the providers.

## File Watching Implementation Exploration Report

I've thoroughly explored the fsnotify-based file watching implementations across the SpecStory CLI codebase. Here's a comprehensive analysis of patterns you can reuse:

### Overview

The codebase implements file watching across **5 provider packages**:
1. **Claude Code** (`pkg/providers/claudecode/`)
2. **Codex CLI** (`pkg/providers/codexcli/`)
3. **Gemini CLI** (`pkg/providers/geminicli/`)
4. **Cursor CLI** (`pkg/providers/cursorcli/`) - Uses polling instead of fsnotify
5. **Droid CLI** (`pkg/providers/droidcli/`) - Uses polling instead of fsnotify

---

## 1. Watcher Setup and Initialization

### Claude Code Pattern (Most Sophisticated)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/watcher.go`

**Key Functions**:
- `WatchForProjectDir()` - Entry point that handles initial setup
- `startProjectWatcher(claudeProjectDir)` - Core watcher implementation
- `WatchForClaudeSetup()` - Waits for ~/.claude directory creation

**Initialization Pattern**:

```go
// Package-level context and synchronization
var (
	watcherCtx      context.Context
	watcherCancel   context.CancelFunc
	watcherWg       sync.WaitGroup
	watcherCallback func(*spi.AgentChatSession)
	watcherDebugRaw bool
	watcherMutex    sync.RWMutex
)

func init() {
	watcherCtx, watcherCancel = context.WithCancel(context.Background())
}

// Create and setup fsnotify watcher
watcher, err := fsnotify.NewWatcher()
if err != nil {
	return fmt.Errorf("failed to create file watcher: %v", err)
}

// Increment wait group before starting goroutine
watcherWg.Add(1)

// Start watching in a goroutine with proper cleanup
go func() {
	defer watcherWg.Done()
	defer func() {
		_ = watcher.Close()
	}()
	// ... event handling loop
}()
```

**Why this pattern works**:
- Global context allows graceful shutdown from anywhere
- WaitGroup ensures all goroutines complete before exit
- Deferred cleanup guarantees watcher closes even on panic

### Codex CLI Pattern (Hierarchical Directory Watching)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/watcher.go`

**Key Innovation**: Watches directory hierarchy (YYYY/MM/DD structure) to handle date changes across days, months, and years

```go
// Watches sessions root for year directories
if err := addWatch(sessionsRoot); err != nil {
	return err
}

// Scan for existing year directories and watch them
entries, err := os.ReadDir(sessionsRoot)
for _, entry := range entries {
	if entry.IsDir() && len(entry.Name()) == 4 {
		yearDir := filepath.Join(sessionsRoot, entry.Name())
		watchYearDir(yearDir)
	}
}

// Helper to prevent duplicate watches
watchedDirs := make(map[string]bool)
var watchedDirsMutex sync.Mutex

addWatch := func(dir string) error {
	watchedDirsMutex.Lock()
	defer watchedDirsMutex.Unlock()
	
	if watchedDirs[dir] {
		return nil // Already watching
	}
	
	if err := watcher.Add(dir); err != nil {
		return err
	}
	watchedDirs[dir] = true
	return nil
}
```

### Gemini CLI Pattern (Pre-directory Existence Polling)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/watcher.go`

**Key Innovation**: Polls before watching to handle cases where directories don't exist yet

```go
// Exponential backoff polling for directory readiness
const (
	initialBackoff = 1 * time.Second
	maxBackoff     = 30 * time.Second
)

func waitForDirectory(ctx context.Context, dir string, label string) error {
	backoff := initialBackoff
	for {
		info, err := os.Stat(dir)
		if err == nil && info.IsDir() {
			return nil
		}
		
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(backoff):
			if backoff < maxBackoff {
				backoff *= 2
				if backoff > maxBackoff {
					backoff = maxBackoff
				}
			}
		}
	}
}
```

### Cursor CLI Pattern (Polling Instead of fsnotify)

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher.go`

**Key Innovation**: Uses polling for SQLite databases (fsnotify doesn't work well with SQLite WAL mode)

```go
type CursorWatcher struct {
	projectPath     string
	hashDir         string
	pollInterval    time.Duration // 5 * time.Second
	ctx             context.Context
	cancel          context.CancelFunc
	wg              sync.WaitGroup
	lastCounts      map[string]int  // Track record counts per session
	knownSessions   map[string]bool // Sessions existing at startup
	resumedSession  string
	sessionCallback func(*spi.AgentChatSession)
	debugRaw        bool
	mu              sync.RWMutex
}

func (w *CursorWatcher) watchLoop() {
	defer w.wg.Done()
	
	ticker := time.NewTicker(w.pollInterval)
	defer ticker.Stop()
	
	w.checkForChanges() // Initial check
	
	for {
		select {
		case <-w.ctx.Done():
			return
		case <-ticker.C:
			w.checkForChanges()
		}
	}
}
```

---

## 2. Event Handling Patterns

### Claude Code: JSONL File Events

```go
// Watch for file events
for {
	select {
	case <-watcherCtx.Done():
		slog.Info("Context cancelled, stopping watcher")
		return
	case event, ok := <-watcher.Events:
		if !ok {
			return
		}
		
		// Only process JSONL files
		if !strings.HasSuffix(event.Name, ".jsonl") {
			continue
		}
		
		if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) {
			continue
		}
		
		// Handle different event types
		switch {
		case event.Has(fsnotify.Create):
			slog.Info("New JSONL file created", "file", event.Name)
			scanJSONLFiles(claudeProjectDir, event.Name)
		case event.Has(fsnotify.Write):
			slog.Info("JSONL file modified", "file", event.Name)
			scanJSONLFiles(claudeProjectDir, event.Name)
		}
		
	case err, ok := <-watcher.Errors:
		if !ok {
			return
		}
		log.UserError("Watcher error: %v", err)
	}
}
```

### Codex CLI: Hierarchical Directory Events

```go
case event, ok := <-watcher.Events:
	if !ok {
		return
	}
	
	// Check if this is a JSONL file (in a day directory)
	if strings.HasSuffix(eventPath, ".jsonl") {
		switch {
		case event.Has(fsnotify.Create), event.Has(fsnotify.Write):
			slog.Info("JSONL file event", "operation", event.Op.String(), "file", eventPath)
			ScanCodexSessions(projectPath, parentDir, &eventPath)
		case event.Has(fsnotify.Remove):
			slog.Info("JSONL file removed", "file", eventPath)
			ScanCodexSessions(projectPath, parentDir, nil)
		}
		continue
	}
	
	// Check if this is a directory creation (hierarchical watching)
	if event.Has(fsnotify.Create) {
		switch dirType(eventPath, sessionsRoot) {
		case "year":
			watchYearDir(eventPath)
		case "month":
			watchMonthDir(eventPath)
		case "day":
			watchDayDir(eventPath)
		}
	}
```

### Gemini CLI: Multi-file Session Handling

```go
func processSessionChange(filePath string) {
	// Extract short session ID from filename to find related files
	filename := filepath.Base(filePath)
	shortID := extractSessionIDFromFilename(filename)
	
	// Find all files for this session to merge them
	chatsDir := filepath.Dir(filePath)
	entries, err := os.ReadDir(chatsDir)
	
	// Collect all files that match this session's short ID
	var sessionFiles []string
	for _, entry := range entries {
		if !entry.IsDir() && extractSessionIDFromFilename(entry.Name()) == shortID {
			sessionFiles = append(sessionFiles, filepath.Join(chatsDir, entry.Name()))
		}
	}
	
	// Merge all files for this session
	mergedSession, err := parseAndMergeSessionFiles(shortID, sessionFiles)
	agentSession := convertToAgentChatSession(mergedSession, getWatcherWorkspaceRoot(), getWatcherDebugRaw())
	triggerCallback(agentSession)
}
```

---

## 3. Debouncing and Rate Limiting Patterns

### Claude Code: Event-Driven (No Debouncing)
- Processes events immediately as they arrive
- Single file scanning per event
- No artificial delays

### Codex CLI: Event-Driven (No Debouncing)
- Handles Create, Write, and Remove events separately
- No aggregation - each event triggers a scan
- Efficient because scans are limited to affected directory

### Cursor CLI: Polling with Change Detection
```go
// hasSessionChanged checks if a session database has new records
func (w *CursorWatcher) hasSessionChanged(sessionID string, fileInfo os.FileInfo, dbPath string) bool {
	w.mu.Lock()
	defer w.mu.Unlock()
	
	// Count total records in the blobs table
	var count int
	err = db.QueryRow("SELECT COUNT(*) FROM blobs").Scan(&count)
	
	// Check if record count changed
	lastCount, countExists := w.lastCounts[sessionID]
	w.lastCounts[sessionID] = count
	
	if !countExists {
		// First time seeing this session - only process if it has content
		return count > 0
	}
	
	if count > lastCount {
		return true // Records added
	}
	
	return false
}
```

### Gemini CLI: Polling with Backoff
```go
backoff := initialBackoff
for {
	info, err := os.Stat(dir)
	if err == nil && info.IsDir() {
		return nil
	}
	
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-time.After(backoff):
		if backoff < maxBackoff {
			backoff *= 2
			if backoff > maxBackoff {
				backoff = maxBackoff
			}
		}
	}
}
```

---

## 4. Error Handling Patterns

### Claude Code: User-Friendly Error Logging

```go
// Graceful degradation - continue on watcher errors
case err, ok := <-watcher.Errors:
	if !ok {
		slog.Info("startProjectWatcher: Watcher errors channel closed")
		return
	}
	log.UserWarn("Watcher error: %v", err)
	slog.Error("startProjectWatcher: Watcher error", "error", err)
```

### Directory Monitoring Error Recovery

```go
// If project directory doesn't exist yet, watch parent directory
if _, err := os.Stat(claudeProjectDir); err == nil {
	// Directory exists, proceed
} else {
	// Cannot access, watch parent
	parentDir := filepath.Dir(claudeProjectDir)
	
	if err := watcher.Add(parentDir); err != nil {
		log.UserError("Error watching parent directory: %v", err)
		return
	}
	
	// Wait for project directory to be created
	for waitingForCreation {
		select {
		case <-watcherCtx.Done():
			return
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}
			if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), projectName) {
				_ = watcher.Remove(parentDir) // OK if this fails
				waitingForCreation = false
			}
		}
	}
}
```

### Cursor CLI: Resilient Database Access

```go
// Open database with read-only mode
db, err := sql.Open("sqlite", dbPath+"?mode=ro")
if err != nil {
	slog.Error("Failed to open database", "sessionId", sessionID, "error", err)
	return false
}
defer func() {
	if err := db.Close(); err != nil {
		slog.Debug("Failed to close database", "error", err)
	}
}()

// Enable WAL mode for non-blocking reads
if _, err := db.Exec("PRAGMA journal_mode=WAL"); err != nil {
	slog.Debug("Failed to enable WAL mode in watcher", "error", err)
}
```

---

## 5. Watcher Cleanup Patterns

### Standard Pattern (All Providers)

```go
// Graceful shutdown function
func StopWatcher() {
	slog.Info("StopWatcher: Signaling watcher to stop")
	watcherCancel() // Signal all goroutines to stop
	slog.Info("StopWatcher: Waiting for watcher goroutine to finish")
	watcherWg.Wait() // Block until all complete
	slog.Info("StopWatcher: Watcher stopped")
}
```

### Deferred Cleanup in Goroutines

```go
go func() {
	defer watcherWg.Done()
	
	// Defer cleanup happens last (LIFO order)
	defer func() {
		slog.Info("Goroutine exiting, closing watcher")
		_ = watcher.Close() // Best effort cleanup
	}()
	
	// ... event handling loop
}()
```

### Context-Based Cancellation

```go
// All watchers respect context cancellation
watcherCtx, watcherCancel = context.WithCancel(context.Background())

// In event loop:
select {
case <-watcherCtx.Done():
	slog.Info("Context cancelled, stopping watcher")
	return
case event, ok := <-watcher.Events:
	// ... process event
}
```

### Cursor CLI: Callback Synchronization

```go
// Stop gracefully stops the watcher
func (w *CursorWatcher) Stop() {
	slog.Info("Stopping Cursor watcher")
	
	// Perform one final check before stopping
	w.checkForChanges()
	
	// Now stop the watcher goroutines
	w.cancel()
	w.wg.Wait()
	
	// Wait for any pending callback goroutines to complete
	slog.Info("Waiting for pending callbacks to complete")
	w.callbackWg.Wait()
	
	slog.Info("Cursor watcher stopped")
}
```

---

## 6. Callback Handling and Thread Safety

### Thread-Safe Callback Management

```go
var (
	watcherCallback func(*spi.AgentChatSession)
	watcherDebugRaw bool
	watcherMutex    sync.RWMutex
)

// Thread-safe setter
func SetWatcherCallback(callback func(*spi.AgentChatSession)) {
	watcherMutex.Lock()
	defer watcherMutex.Unlock()
	watcherCallback = callback
	slog.Info("SetWatcherCallback: Callback set", "isNil", callback == nil)
}

// Thread-safe getter
func getWatcherCallback() func(*spi.AgentChatSession) {
	watcherMutex.RLock()
	defer watcherMutex.RUnlock()
	return watcherCallback
}
```

### Non-Blocking Callback Invocation

```go
// Get the session callback
callback := getWatcherCallback()
if callback == nil {
	slog.Error("ScanJSONLFiles: No callback provided")
	return
}

// Call in goroutine to avoid blocking watcher
go func(s *spi.AgentChatSession) {
	defer func() {
		if r := recover(); r != nil {
			slog.Error("ScanJSONLFiles: Callback panicked", "panic", r)
		}
	}()
	callback(s)
}(agentSession)
```

### Gemini CLI: Helper Function Pattern

```go
func triggerCallback(agentSession *spi.AgentChatSession) {
	watcherMutex.RLock()
	cb := watcherCallback
	watcherMutex.RUnlock()
	
	if cb != nil && agentSession != nil {
		cb(agentSession)
	}
}
```

---

## 7. File Filtering Patterns

### Suffix-Based Filtering
```go
// Only process JSONL files
if !strings.HasSuffix(event.Name, ".jsonl") {
	continue
}
```

### Multiple Format Support (Gemini)
```go
if strings.HasSuffix(event.Name, ".json") && 
   (event.Has(fsnotify.Write) || event.Has(fsnotify.Create)) {
	processSessionChange(event.Name)
}
```

### Extension-Based Filtering
```go
if filepath.Ext(entry.Name()) != ".jsonl" {
	continue
}
```

---

## 8. Real-World Implementation Examples

### Provider Integration Pattern

**File**: `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider.go`

```go
// ExecAgentAndWatch - Execute and watch pattern
func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	// Set up the callback
	SetWatcherCallback(sessionCallback)
	defer ClearWatcherCallback()
	
	SetWatcherDebugRaw(debugRaw)
	
	// Start watching in background
	if err := WatchForProjectDir(); err != nil {
		slog.Error("Failed to start project directory watcher", "error", err)
	}
	
	// Execute agent (blocking)
	err := ExecuteClaude(customCommand, resumeSessionID)
	
	// Stop the watcher goroutine before returning
	StopWatcher()
	
	return err
}

// WatchAgent - Watch without executing pattern
func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
	SetWatcherCallback(sessionCallback)
	defer ClearWatcherCallback()
	
	SetWatcherDebugRaw(debugRaw)
	
	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
	if err != nil {
		return err
	}
	
	if err := startProjectWatcher(claudeProjectDir); err != nil {
		return err
	}
	
	// Block until context is cancelled
	<-ctx.Done()
	
	StopWatcher()
	return ctx.Err()
}
```

---

## Summary of Reusable Patterns

**✓ Watcher Setup**:
- Global context + WaitGroup pattern
- Goroutine-per-watcher with deferred cleanup
- Check directory existence before watching

**✓ Event Handling**:
- Filter by file suffix or extension
- Separate Create vs Write handling
- Short-circuit on irrelevant events

**✓ Debouncing**:
- Event-driven for file watching
- Polling with change detection for databases
- Exponential backoff for pre-existence polling

**✓ Error Handling**:
- Non-fatal watcher errors logged but not propagated
- Parent directory fallback when target doesn't exist
- WAL mode handling for SQLite

**✓ Cleanup**:
- Context cancellation signal
- WaitGroup for coordination
- Callback goroutine tracking (Cursor CLI pattern)

**✓ Thread Safety**:
- RWMutex for shared state
- Callback invoked in separate goroutine
- Deferred recovery from panics

---

## File Paths for Reference

1. **Claude Code (Most Complete)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/watcher.go`
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/claudecode/provider.go`

2. **Codex CLI (Hierarchical)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/watcher.go`
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/codexcli/provider.go`

3. **Gemini CLI (Pre-polling)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/geminicli/watcher.go`

4. **Cursor CLI (Polling for SQLite)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/cursorcli/watcher.go`

5. **Droid CLI (Simple Polling)**:
   - `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go`

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:42Z)**_

<think><details><summary>Thought Process</summary>
The exploration results are comprehensive. I now have a clear understanding of:

1. **Current Droid implementation** - Uses a 1-second polling approach with:
   - `time.NewTicker(1 * time.Second)` in `watchSessions()`
   - Scans all `.jsonl` files in `~/.factory/sessions/` on each tick
   - Uses `watchState.lastProcessed` map to track file modification times
   - Context-based cancellation

2. **fsnotify patterns from other providers** - The Claude Code provider has the most complete implementation:
   - Global context + WaitGroup pattern
   - Goroutine-per-watcher with deferred cleanup
   - Event filtering by file suffix
   - Thread-safe callback management with RWMutex
   - Parent directory fallback when target doesn't exist
   - StopWatcher() function for graceful shutdown

Let me read the key files directly to see the actual code and understand what needs to be changed.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:43Z)**_

Excellent exploration results. Now let me read the key files directly to design the implementation approach.

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:43Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/watcher.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"time"
     8→
     9→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    10→)
    11→
    12→const droidWatchInterval = 1 * time.Second
    13→
    14→type watchState struct {
    15→	lastProcessed map[string]int64
    16→}
    17→
    18→func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
    19→	if sessionCallback == nil {
    20→		return fmt.Errorf("session callback is required")
    21→	}
    22→
    23→	state := &watchState{lastProcessed: make(map[string]int64)}
    24→	if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    25→		return err
    26→	}
    27→
    28→	ticker := time.NewTicker(droidWatchInterval)
    29→	defer ticker.Stop()
    30→
    31→	for {
    32→		select {
    33→		case <-ctx.Done():
    34→			return ctx.Err()
    35→		case <-ticker.C:
    36→			if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    37→				slog.Debug("droidcli: scan failed", "error", err)
    38→			}
    39→		}
    40→	}
    41→}
    42→
    43→func scanAndProcessSessions(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) error {
    44→	files, err := listSessionFiles()
    45→	if err != nil {
    46→		return err
    47→	}
    48→
    49→	for _, file := range files {
    50→		if last, ok := state.lastProcessed[file.Path]; ok && last >= file.ModTime {
    51→			continue
    52→		}
    53→		if projectPath != "" && !sessionMentionsProject(file.Path, projectPath) {
    54→			continue
    55→		}
    56→		session, err := parseFactorySession(file.Path)
    57→		if err != nil {
    58→			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
    59→			continue
    60→		}
    61→		chat := convertToAgentSession(session, projectPath, debugRaw)
    62→		if chat == nil {
    63→			continue
    64→		}
    65→		state.lastProcessed[file.Path] = file.ModTime
    66→		dispatchSession(sessionCallback, chat)
    67→	}
    68→	return nil
    69→}
    70→
    71→func dispatchSession(sessionCallback func(*spi.AgentChatSession), session *spi.AgentChatSession) {
    72→	if sessionCallback == nil || session == nil {
    73→		return
    74→	}
    75→	go func() {
    76→		defer func() {
    77→			if r := recover(); r != nil {
    78→				slog.Error("droidcli: session callback panicked", "panic", r)
    79→			}
    80→		}()
    81→		sessionCallback(session)
    82→	}()
    83→}
    84→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:44Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/claudecode/watcher.go`
```
     1→package claudecode
     2→
     3→import (
     4→	"context"
     5→	"encoding/json"
     6→	"fmt"
     7→	"log/slog"
     8→	"os"
     9→	"path/filepath"
    10→	"strings"
    11→	"sync"
    12→	"time"
    13→
    14→	"github.com/fsnotify/fsnotify"
    15→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    17→)
    18→
    19→var (
    20→	watcherCtx      context.Context
    21→	watcherCancel   context.CancelFunc
    22→	watcherWg       sync.WaitGroup
    23→	watcherCallback func(*spi.AgentChatSession) // Callback for session updates
    24→	watcherDebugRaw bool                        // Whether to write debug raw data files
    25→	watcherMutex    sync.RWMutex                // Protects watcherCallback and watcherDebugRaw
    26→)
    27→
    28→func init() {
    29→	watcherCtx, watcherCancel = context.WithCancel(context.Background())
    30→}
    31→
    32→// SetWatcherCallback sets the callback function for session updates
    33→func SetWatcherCallback(callback func(*spi.AgentChatSession)) {
    34→	watcherMutex.Lock()
    35→	defer watcherMutex.Unlock()
    36→	watcherCallback = callback
    37→	slog.Info("SetWatcherCallback: Callback set", "isNil", callback == nil)
    38→}
    39→
    40→// ClearWatcherCallback clears the callback function
    41→func ClearWatcherCallback() {
    42→	watcherMutex.Lock()
    43→	defer watcherMutex.Unlock()
    44→	watcherCallback = nil
    45→	slog.Info("ClearWatcherCallback: Callback cleared")
    46→}
    47→
    48→// SetWatcherDebugRaw sets whether to write debug raw data files
    49→func SetWatcherDebugRaw(debugRaw bool) {
    50→	watcherMutex.Lock()
    51→	defer watcherMutex.Unlock()
    52→	watcherDebugRaw = debugRaw
    53→	slog.Debug("SetWatcherDebugRaw: Debug raw set", "debugRaw", debugRaw)
    54→}
    55→
    56→// getWatcherDebugRaw returns the current debug raw setting (thread-safe)
    57→func getWatcherDebugRaw() bool {
    58→	watcherMutex.RLock()
    59→	defer watcherMutex.RUnlock()
    60→	return watcherDebugRaw
    61→}
    62→
    63→// getWatcherCallback returns the current callback function (thread-safe)
    64→func getWatcherCallback() func(*spi.AgentChatSession) {
    65→	watcherMutex.RLock()
    66→	defer watcherMutex.RUnlock()
    67→	return watcherCallback
    68→}
    69→
    70→// StopWatcher gracefully stops the watcher goroutine
    71→func StopWatcher() {
    72→	slog.Info("StopWatcher: Signaling watcher to stop")
    73→	watcherCancel()
    74→	slog.Info("StopWatcher: Waiting for watcher goroutine to finish")
    75→	watcherWg.Wait()
    76→	slog.Info("StopWatcher: Watcher stopped")
    77→}
    78→
    79→// WatchForProjectDir watches for a project directory that matches the current working directory
    80→func WatchForProjectDir() error {
    81→	slog.Info("WatchForProjectDir: Determining project directory to monitor")
    82→	claudeProjectDir, err := GetClaudeCodeProjectDir("")
    83→	if err != nil {
    84→		slog.Error("WatchForProjectDir: Failed to get project directory", "error", err)
    85→		// Check if error is specifically about missing Claude projects directory
    86→		if strings.Contains(err.Error(), "claude projects directory not found") {
    87→			slog.Error("WatchForProjectDir: Claude projects directory not found while starting setup watcher")
    88→			// Start watching for Claude directory creation
    89→			return WatchForClaudeSetup()
    90→		}
    91→		return fmt.Errorf("failed to get project directory: %v", err)
    92→	}
    93→
    94→	slog.Info("WatchForProjectDir: Project directory found", "directory", claudeProjectDir)
    95→	return startProjectWatcher(claudeProjectDir)
    96→}
    97→
    98→// startProjectWatcher starts watching a specific project directory
    99→func startProjectWatcher(claudeProjectDir string) error {
   100→	slog.Info("startProjectWatcher: Creating file watcher", "directory", claudeProjectDir)
   101→
   102→	// Create a new watcher
   103→	watcher, err := fsnotify.NewWatcher()
   104→	if err != nil {
   105→		return fmt.Errorf("failed to create file watcher: %v", err)
   106→	}
   107→
   108→	// Increment wait group before starting goroutine
   109→	watcherWg.Add(1)
   110→
   111→	// Start watching in a goroutine
   112→	go func() {
   113→		// Decrement wait group when done
   114→		defer watcherWg.Done()
   115→
   116→		// Log when goroutine starts
   117→		slog.Info("startProjectWatcher: Goroutine started")
   118→
   119→		// Defer cleanup
   120→		defer func() {
   121→			slog.Info("startProjectWatcher: Goroutine exiting, closing watcher")
   122→			_ = watcher.Close() // Best effort cleanup; errors here are not recoverable
   123→		}()
   124→
   125→		// Check if project directory already exists
   126→		if _, err := os.Stat(claudeProjectDir); err == nil {
   127→			slog.Info("startProjectWatcher: Project directory exists", "directory", claudeProjectDir)
   128→			// Claude Code triggers file system events when it starts writing, so we'll catch the session on the first write event.
   129→			slog.Info("startProjectWatcher: Waiting for JSONL file system events")
   130→		} else {
   131→			// Project directory doesn't exist yet, watch parent directory (or other error)
   132→			parentDir := filepath.Dir(claudeProjectDir)
   133→			projectName := filepath.Base(claudeProjectDir)
   134→			slog.Warn("startProjectWatcher: Cannot access project directory, watching parent",
   135→				"error", err,
   136→				"parentDir", parentDir,
   137→				"projectName", projectName)
   138→
   139→			// Add parent directory to watcher
   140→			if err := watcher.Add(parentDir); err != nil {
   141→				log.UserError("Error watching parent directory: %v", err)
   142→				slog.Error("startProjectWatcher: Failed to watch parent directory", "error", err)
   143→				return
   144→			}
   145→
   146→			// Wait for project directory to be created
   147→			waitingForCreation := true
   148→			slog.Info("startProjectWatcher: Now watching for events in parent directory")
   149→			for waitingForCreation {
   150→				select {
   151→				case <-watcherCtx.Done():
   152→					slog.Info("startProjectWatcher: Context cancelled while waiting for directory creation")
   153→					return
   154→				case event, ok := <-watcher.Events:
   155→					if !ok {
   156→						slog.Info("startProjectWatcher: Watcher events channel closed")
   157→						return
   158→					}
   159→					slog.Info("startProjectWatcher: Parent directory event",
   160→						"operation", event.Op.String(),
   161→						"path", event.Name,
   162→						"lookingFor", projectName)
   163→					eventBaseName := filepath.Base(event.Name)
   164→					slog.Info("startProjectWatcher: Event basename comparison",
   165→						"basename", eventBaseName,
   166→						"comparingWith", projectName,
   167→						"equalFold", strings.EqualFold(eventBaseName, projectName))
   168→					if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), projectName) {
   169→						slog.Info("startProjectWatcher: Detected project directory creation",
   170→							"path", event.Name)
   171→						slog.Info("startProjectWatcher: Initial scan disabled; waiting for JSONL events")
   172→						// Use the actual created directory name from the event
   173→						claudeProjectDir = filepath.Join(parentDir, filepath.Base(event.Name))
   174→						// Remove parent directory and continue to watch project directory
   175→						_ = watcher.Remove(parentDir) // OK if this fails; we're moving to project dir
   176→						waitingForCreation = false
   177→					}
   178→				case err, ok := <-watcher.Errors:
   179→					if !ok {
   180→						slog.Info("startProjectWatcher: Watcher errors channel closed")
   181→						return
   182→					}
   183→					log.UserWarn("Watcher error while waiting for project directory: %v", err)
   184→					slog.Error("startProjectWatcher: Watcher error", "error", err)
   185→				}
   186→			}
   187→		}
   188→
   189→		// Add the project directory to the watcher
   190→		// Re-stat to get the actual directory name with correct case
   191→		actualProjectDir := claudeProjectDir
   192→		if entries, err := os.ReadDir(filepath.Dir(claudeProjectDir)); err == nil {
   193→			baseName := filepath.Base(claudeProjectDir)
   194→			for _, entry := range entries {
   195→				if strings.EqualFold(entry.Name(), baseName) {
   196→					actualProjectDir = filepath.Join(filepath.Dir(claudeProjectDir), entry.Name())
   197→					break
   198→				}
   199→			}
   200→		}
   201→		slog.Info("startProjectWatcher: Now monitoring project directory for changes",
   202→			"directory", actualProjectDir)
   203→		if err := watcher.Add(actualProjectDir); err != nil {
   204→			log.UserWarn("Error watching project directory: %v", err)
   205→			slog.Error("startProjectWatcher: Failed to monitor directory", "error", err)
   206→			return
   207→		}
   208→		slog.Info("startProjectWatcher: Successfully monitoring project directory for future changes")
   209→
   210→		// Watch for file events
   211→		for {
   212→			select {
   213→			case <-watcherCtx.Done():
   214→				slog.Info("startProjectWatcher: Context cancelled, stopping watcher")
   215→				return
   216→			case event, ok := <-watcher.Events:
   217→				if !ok {
   218→					return
   219→				}
   220→
   221→				// Only process JSONL files
   222→				if !strings.HasSuffix(event.Name, ".jsonl") {
   223→					continue
   224→				}
   225→
   226→				if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) {
   227→					continue
   228→				}
   229→
   230→				// Handle different event types
   231→				switch {
   232→				case event.Has(fsnotify.Create):
   233→					slog.Info("New JSONL file created", "file", event.Name)
   234→					scanJSONLFiles(claudeProjectDir, event.Name)
   235→				case event.Has(fsnotify.Write):
   236→					slog.Info("JSONL file modified", "file", event.Name)
   237→					slog.Info("Triggering scan due to file modification")
   238→					scanJSONLFiles(claudeProjectDir, event.Name)
   239→				}
   240→
   241→			case err, ok := <-watcher.Errors:
   242→				if !ok {
   243→					return
   244→				}
   245→				log.UserError("Watcher error: %v", err)
   246→			}
   247→		}
   248→	}()
   249→
   250→	return nil
   251→}
   252→
   253→// scanJSONLFiles scans JSONL files and optionally filters processing to a specific changed file
   254→func scanJSONLFiles(claudeProjectDir string, changedFile ...string) {
   255→	// Ensure logs are flushed even if we panic
   256→	defer func() {
   257→		if r := recover(); r != nil {
   258→			log.UserWarn("PANIC in ScanJSONLFiles: %v", r)
   259→			slog.Error("ScanJSONLFiles: PANIC recovered", "panic", r)
   260→		}
   261→	}()
   262→
   263→	slog.Info("ScanJSONLFiles: === START SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   264→	var targetFile string
   265→	if len(changedFile) > 0 && changedFile[0] != "" {
   266→		targetFile = changedFile[0]
   267→		slog.Info("ScanJSONLFiles: Scanning JSONL files with changed file",
   268→			"directory", claudeProjectDir,
   269→			"changedFile", targetFile)
   270→	} else {
   271→		slog.Info("ScanJSONLFiles: Scanning JSONL files", "directory", claudeProjectDir)
   272→	}
   273→	// Parse files and create history files:
   274→	parser := NewJSONLParser()
   275→	var targetSessionUuid string
   276→
   277→	// Set the target file for conditional debug output
   278→	if targetFile != "" {
   279→		SetDebugTargetFile(targetFile)
   280→		defer ClearDebugTargetFile()
   281→
   282→		sessionID, err := extractSessionIDFromFile(targetFile)
   283→		if err != nil {
   284→			slog.Warn("ScanJSONLFiles: Failed to extract session ID from file",
   285→				"file", targetFile,
   286→				"error", err)
   287→			slog.Info("ScanJSONLFiles: Skipping scan due to file read error", "file", targetFile)
   288→			return
   289→		}
   290→		if sessionID == "" {
   291→			slog.Info("ScanJSONLFiles: Skipping scan; session ID not present yet", "file", targetFile)
   292→			return
   293→		}
   294→		targetSessionUuid = sessionID
   295→		slog.Info("ScanJSONLFiles: Extracted session ID from changed file",
   296→			"sessionUuid", targetSessionUuid,
   297→			"file", targetFile)
   298→	}
   299→
   300→	var parseErr error
   301→	if targetSessionUuid != "" {
   302→		parseErr = parser.ParseProjectSessionsForSession(claudeProjectDir, true, targetSessionUuid)
   303→	} else {
   304→		parseErr = parser.ParseProjectSessions(claudeProjectDir, true)
   305→	}
   306→	if parseErr != nil {
   307→		log.UserWarn("Error parsing project sessions: %v", parseErr)
   308→		slog.Error("ScanJSONLFiles: Error parsing project sessions", "error", parseErr)
   309→		return
   310→	}
   311→
   312→	// Process JSONL sessions (isAutosave = true, silent = false for autosave)
   313→	slog.Info("ScanJSONLFiles: Processing sessions",
   314→		"sessionCount", len(parser.Sessions),
   315→		"targetSessionUuid", targetSessionUuid)
   316→
   317→	// Get the session callback
   318→	callback := getWatcherCallback()
   319→	if callback == nil {
   320→		slog.Error("ScanJSONLFiles: No callback provided - this should not happen")
   321→		return
   322→	}
   323→
   324→	slog.Info("ScanJSONLFiles: Processing sessions with callback")
   325→	// Process sessions and call the callback for each
   326→	for _, session := range parser.Sessions {
   327→		// Skip empty sessions
   328→		if len(session.Records) == 0 {
   329→			continue
   330→		}
   331→
   332→		// Skip if we're targeting a specific session and this isn't it
   333→		if targetSessionUuid != "" && session.SessionUuid != targetSessionUuid {
   334→			continue
   335→		}
   336→
   337→		// Convert to AgentChatSession (workspaceRoot extracted from records' cwd field)
   338→		agentSession := convertToAgentChatSession(session, "", getWatcherDebugRaw())
   339→		if agentSession != nil {
   340→			slog.Info("ScanJSONLFiles: Calling callback for session", "sessionId", agentSession.SessionID)
   341→			// Call the callback in a goroutine to avoid blocking
   342→			go func(s *spi.AgentChatSession) {
   343→				defer func() {
   344→					if r := recover(); r != nil {
   345→						slog.Error("ScanJSONLFiles: Callback panicked", "panic", r)
   346→					}
   347→				}()
   348→				callback(s)
   349→			}(agentSession)
   350→		}
   351→	}
   352→	slog.Info("ScanJSONLFiles: Processing complete")
   353→	slog.Info("ScanJSONLFiles: === END SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   354→}
   355→
   356→// WatchForClaudeSetup watches for the creation of Claude directories
   357→func WatchForClaudeSetup() error {
   358→	slog.Info("WatchForClaudeSetup: Starting Claude directory setup watcher")
   359→	homeDir, err := os.UserHomeDir()
   360→	if err != nil {
   361→		return fmt.Errorf("failed to get user home directory: %v", err)
   362→	}
   363→
   364→	claudeDir := filepath.Join(homeDir, ".claude")
   365→	projectsDir := filepath.Join(claudeDir, "projects")
   366→	slog.Info("WatchForClaudeSetup: Directories",
   367→		"homeDir", homeDir,
   368→		"claudeDir", claudeDir,
   369→		"projectsDir", projectsDir)
   370→
   371→	// Determine what to watch
   372→	var watchDir string
   373→	var watchingFor string
   374→
   375→	if _, err := os.Stat(claudeDir); os.IsNotExist(err) {
   376→		// .claude doesn't exist, watch home directory
   377→		watchDir = homeDir
   378→		watchingFor = ".claude"
   379→		slog.Warn("WatchForClaudeSetup: .claude directory does not exist")
   380→		slog.Info("Claude directory not found, watching for creation of ~/.claude\n")
   381→	} else {
   382→		// .claude exists but projects doesn't, watch .claude
   383→		watchDir = claudeDir
   384→		watchingFor = "projects"
   385→		slog.Warn("WatchForClaudeSetup: .claude directory exists, checking for projects")
   386→		slog.Info("Claude directory found, watching for creation of ~/.claude/projects\n")
   387→	}
   388→	slog.Info("WatchForClaudeSetup: Will watch directory",
   389→		"watchDir", watchDir,
   390→		"watchingFor", watchingFor)
   391→
   392→	// Create watcher
   393→	watcher, err := fsnotify.NewWatcher()
   394→	if err != nil {
   395→		log.UserWarn("Failed to create file watcher: %v", err)
   396→		slog.Error("WatchForClaudeSetup: Failed to create file watcher", "error", err)
   397→		return fmt.Errorf("failed to create file watcher: %v", err)
   398→	}
   399→
   400→	// Add directory to watch
   401→	slog.Info("WatchForClaudeSetup: Adding directory to watcher", "directory", watchDir)
   402→	if err := watcher.Add(watchDir); err != nil {
   403→		_ = watcher.Close() // Clean up on error; close errors less important than Add error
   404→		return fmt.Errorf("failed to watch directory %s: %v", watchDir, err)
   405→	}
   406→	slog.Info("WatchForClaudeSetup: Successfully started watching", "directory", watchDir)
   407→
   408→	// Start watching in a goroutine
   409→	go func() {
   410→		defer func() { _ = watcher.Close() }() // Cleanup on exit; errors not recoverable
   411→
   412→		for {
   413→			select {
   414→			case event, ok := <-watcher.Events:
   415→				if !ok {
   416→					return
   417→				}
   418→
   419→				slog.Info("WatchForClaudeSetup: Received event",
   420→					"operation", event.Op.String(),
   421→					"path", event.Name)
   422→				// Check if this is the directory we're waiting for (case-insensitive)
   423→				if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), watchingFor) {
   424→					slog.Info("Detected creation", "path", event.Name)
   425→					slog.Info("WatchForClaudeSetup: Target directory created", "path", event.Name)
   426→
   427→					// Wait a second to let things settle
   428→					slog.Info("WatchForClaudeSetup: Waiting 1 second for things to settle")
   429→					time.Sleep(1 * time.Second)
   430→
   431→					// Check what we should do next
   432→					if watchingFor == ".claude" {
   433→						slog.Info("WatchForClaudeSetup: .claude was created, checking if projects exists")
   434→						// We were watching for .claude, now check if projects exists
   435→						if _, err := os.Stat(projectsDir); os.IsNotExist(err) {
   436→							slog.Info("WatchForClaudeSetup: projects directory does not exist, switching watcher")
   437→							// Need to watch for projects directory
   438→							_ = watcher.Remove(watchDir) // OK if fails; switching watch targets
   439→							watchDir = claudeDir
   440→							watchingFor = "projects"
   441→							slog.Info("WatchForClaudeSetup: Switching to watch",
   442→								"watchDir", watchDir,
   443→								"watchingFor", watchingFor)
   444→							if err := watcher.Add(watchDir); err != nil {
   445→								log.UserWarn("Error switching to watch .claude directory: %v", err)
   446→								slog.Error("WatchForClaudeSetup: Failed to switch watcher", "error", err)
   447→								return
   448→							}
   449→							slog.Info("Now watching for creation of ~/.claude/projects\n")
   450→							continue
   451→						} else {
   452→							slog.Info("WatchForClaudeSetup: projects directory already exists!")
   453→						}
   454→					}
   455→
   456→					// If we get here, projects directory should exist
   457→					slog.Info("WatchForClaudeSetup: Projects directory should now exist, cleaning up watcher")
   458→					// Remove the current watcher
   459→					_ = watcher.Remove(watchDir) // OK if fails; we're transitioning to project watcher
   460→
   461→					// Start the normal project watcher
   462→					slog.Info("Claude projects directory now exists, starting normal file watcher\n")
   463→					// Try to get the project directory again
   464→					slog.Info("WatchForClaudeSetup: Getting project directory name")
   465→					if projectDir, err := GetClaudeCodeProjectDir(""); err == nil {
   466→						slog.Info("WatchForClaudeSetup: Project directory will be", "directory", projectDir)
   467→						if err := startProjectWatcher(projectDir); err != nil {
   468→							log.UserWarn("Error starting project watcher: %v", err)
   469→							slog.Error("WatchForClaudeSetup: Failed to start project watcher", "error", err)
   470→						} else {
   471→							slog.Info("WatchForClaudeSetup: Successfully started project watcher")
   472→						}
   473→					} else {
   474→						log.UserWarn("Error getting project directory after Claude setup: %v", err)
   475→						slog.Error("WatchForClaudeSetup: Failed to get project directory", "error", err)
   476→					}
   477→					return
   478→				}
   479→
   480→			case err, ok := <-watcher.Errors:
   481→				if !ok {
   482→					return
   483→				}
   484→				log.UserWarn("Watcher error: %v", err)
   485→				slog.Error("WatchForClaudeSetup: Watcher error", "error", err)
   486→			}
   487→		}
   488→	}()
   489→
   490→	return nil
   491→}
   492→
   493→// convertToAgentChatSession converts a Session to an AgentChatSession
   494→// Returns nil if the session is warmup-only (no real messages)
   495→func convertToAgentChatSession(session Session, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
   496→	// Skip empty sessions (no records)
   497→	if len(session.Records) == 0 {
   498→		return nil
   499→	}
   500→
   501→	// Write debug files first (even for warmup-only sessions)
   502→	_ = make(map[int]int) // recordToFileNumber no longer needed
   503→	if debugRaw {
   504→		// Write debug files
   505→		writeDebugRawFiles(session)
   506→	}
   507→
   508→	// Filter warmup messages
   509→	filteredRecords := filterWarmupMessages(session.Records)
   510→
   511→	// Skip if no real messages remain after filtering warmup
   512→	if len(filteredRecords) == 0 {
   513→		slog.Debug("Skipping warmup-only session", "sessionId", session.SessionUuid)
   514→		return nil
   515→	}
   516→
   517→	// Create session with filtered records
   518→	filteredSession := Session{
   519→		SessionUuid: session.SessionUuid,
   520→		Records:     filteredRecords,
   521→	}
   522→
   523→	// Get timestamp from root record
   524→	rootRecord := filteredSession.Records[0]
   525→	timestamp, ok := rootRecord.Data["timestamp"].(string)
   526→	if !ok {
   527→		slog.Warn("convertToAgentChatSession: No timestamp found in root record")
   528→		return nil
   529→	}
   530→
   531→	// Get the slug
   532→	slug := FileSlugFromRootRecord(filteredSession)
   533→
   534→	// Generate SessionData from filtered session
   535→	sessionData, err := GenerateAgentSession(filteredSession, workspaceRoot)
   536→	if err != nil {
   537→		slog.Error("Failed to generate SessionData", "sessionId", session.SessionUuid, "error", err)
   538→		return nil
   539→	}
   540→
   541→	// Convert session records to JSONL format for raw data
   542→	// Note: Uses unfiltered session.Records (not filteredSession.Records) to preserve
   543→	// all records including warmup messages in the raw data for complete audit trail
   544→	var rawDataBuilder strings.Builder
   545→	for _, record := range session.Records {
   546→		jsonBytes, _ := json.Marshal(record.Data)
   547→		rawDataBuilder.Write(jsonBytes)
   548→		rawDataBuilder.WriteString("\n")
   549→	}
   550→
   551→	return &spi.AgentChatSession{
   552→		SessionID:   session.SessionUuid,
   553→		CreatedAt:   timestamp, // ISO 8601 timestamp
   554→		Slug:        slug,
   555→		SessionData: sessionData,
   556→		RawData:     rawDataBuilder.String(),
   557→	}
   558→}
   559→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:48Z)**_

<think><details><summary>Thought Process</summary>
Now I have a clear picture. Let me also check how the Droid provider structures its directory watching to understand if the Factory Droid sessions directory has a similar structure to Claude Code or if it's flat (no subdirectories).

Let me also read the provider.go file for Droid to understand the integration patterns.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:49Z)**_

Let me also check the path utilities and provider integration for the Droid provider.

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:50Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/path_utils.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"fmt"
     5→	"io/fs"
     6→	"os"
     7→	"path/filepath"
     8→	"sort"
     9→)
    10→
    11→const (
    12→	factoryRootDir     = ".factory"
    13→	factorySessionsDir = "sessions"
    14→)
    15→
    16→type sessionFile struct {
    17→	Path     string
    18→	ModTime  int64
    19→	FileName string
    20→}
    21→
    22→func resolveSessionsDir() (string, error) {
    23→	home, err := os.UserHomeDir()
    24→	if err != nil {
    25→		return "", fmt.Errorf("droidcli: cannot resolve home dir: %w", err)
    26→	}
    27→	dir := filepath.Join(home, factoryRootDir, factorySessionsDir)
    28→	return dir, nil
    29→}
    30→
    31→func listSessionFiles() ([]sessionFile, error) {
    32→	dir, err := resolveSessionsDir()
    33→	if err != nil {
    34→		return nil, err
    35→	}
    36→	files := make([]sessionFile, 0, 64)
    37→	walker := func(path string, d fs.DirEntry, walkErr error) error {
    38→		if walkErr != nil {
    39→			return nil
    40→		}
    41→		if d.IsDir() {
    42→			return nil
    43→		}
    44→		if filepath.Ext(d.Name()) != ".jsonl" {
    45→			return nil
    46→		}
    47→		info, err := d.Info()
    48→		if err != nil {
    49→			return nil
    50→		}
    51→		files = append(files, sessionFile{
    52→			Path:     path,
    53→			ModTime:  info.ModTime().UnixNano(),
    54→			FileName: d.Name(),
    55→		})
    56→		return nil
    57→	}
    58→	if err := filepath.WalkDir(dir, walker); err != nil {
    59→		if os.IsNotExist(err) {
    60→			return []sessionFile{}, nil
    61→		}
    62→		return nil, fmt.Errorf("droidcli: unable to read sessions dir: %w", err)
    63→	}
    64→	sort.Slice(files, func(i, j int) bool {
    65→		return files[i].ModTime > files[j].ModTime
    66→	})
    67→	return files, nil
    68→}
    69→
    70→func findSessionFileByID(sessionID string) (string, error) {
    71→	files, err := listSessionFiles()
    72→	if err != nil {
    73→		return "", err
    74→	}
    75→	for _, file := range files {
    76→		candidate := file.FileName
    77→		if candidate == sessionID || trimExt(candidate) == sessionID {
    78→			return file.Path, nil
    79→		}
    80→	}
    81→	return "", nil
    82→}
    83→
    84→func trimExt(name string) string {
    85→	ext := filepath.Ext(name)
    86→	if ext == "" {
    87→		return name
    88→	}
    89→	return name[:len(name)-len(ext)]
    90→}
    91→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:51Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/provider.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"bytes"
     5→	"context"
     6→	"encoding/json"
     7→	"errors"
     8→	"fmt"
     9→	"log/slog"
    10→	"os"
    11→	"os/exec"
    12→	"path/filepath"
    13→	"regexp"
    14→	"strings"
    15→
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    18→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    19→)
    20→
    21→const defaultFactoryCommand = "droid"
    22→
    23→type Provider struct{}
    24→
    25→func NewProvider() *Provider {
    26→	return &Provider{}
    27→}
    28→
    29→func (p *Provider) Name() string {
    30→	return "Factory Droid CLI"
    31→}
    32→
    33→func (p *Provider) Check(customCommand string) spi.CheckResult {
    34→	cmdName, _ := parseDroidCommand(customCommand)
    35→	isCustom := strings.TrimSpace(customCommand) != ""
    36→	versionFlag := "--version"
    37→
    38→	resolved, err := exec.LookPath(cmdName)
    39→	if err != nil {
    40→		msg := buildCheckErrorMessage("not_found", cmdName, isCustom, "")
    41→		trackCheckFailure("droid", isCustom, cmdName, "", classifyDroidPath(cmdName, ""), versionFlag, "", "not_found", err.Error())
    42→		return spi.CheckResult{Success: false, Location: "", ErrorMessage: msg}
    43→	}
    44→	pathType := classifyDroidPath(cmdName, resolved)
    45→
    46→	var stdout, stderr bytes.Buffer
    47→	cmd := exec.Command(resolved, versionFlag)
    48→	cmd.Stdout = &stdout
    49→	cmd.Stderr = &stderr
    50→	if err := cmd.Run(); err != nil {
    51→		errorType := classifyCheckError(err)
    52→		stderrOutput := strings.TrimSpace(stderr.String())
    53→		msg := buildCheckErrorMessage(errorType, resolved, isCustom, stderrOutput)
    54→		trackCheckFailure("droid", isCustom, cmdName, resolved, pathType, versionFlag, stderrOutput, errorType, err.Error())
    55→		return spi.CheckResult{Success: false, Location: resolved, ErrorMessage: msg}
    56→	}
    57→
    58→	versionOutput := sanitizeDroidVersion(stdout.String())
    59→	version := extractDroidVersion(versionOutput)
    60→	if version == "" {
    61→		version = strings.TrimSpace(versionOutput)
    62→	}
    63→	trackCheckSuccess("droid", isCustom, cmdName, resolved, pathType, version, versionFlag)
    64→	return spi.CheckResult{Success: true, Version: version, Location: resolved}
    65→}
    66→
    67→func (p *Provider) DetectAgent(projectPath string, helpOutput bool) bool {
    68→	files, err := listSessionFiles()
    69→	if err != nil {
    70→		if helpOutput {
    71→			log.UserWarn("Factory Droid detection failed: %v", err)
    72→		}
    73→		return false
    74→	}
    75→	if len(files) == 0 {
    76→		if helpOutput {
    77→			printDetectionHelp()
    78→		}
    79→		return false
    80→	}
    81→	if projectPath == "" {
    82→		return true
    83→	}
    84→	for _, file := range files {
    85→		if sessionMentionsProject(file.Path, projectPath) {
    86→			return true
    87→		}
    88→	}
    89→	if helpOutput {
    90→		printDetectionHelp()
    91→	}
    92→	return false
    93→}
    94→
    95→func (p *Provider) GetAgentChatSessions(projectPath string, debugRaw bool) ([]spi.AgentChatSession, error) {
    96→	files, err := listSessionFiles()
    97→	if err != nil {
    98→		return nil, err
    99→	}
   100→	result := make([]spi.AgentChatSession, 0, len(files))
   101→	normalizedProject := strings.TrimSpace(projectPath)
   102→
   103→	for _, file := range files {
   104→		if normalizedProject != "" && !sessionMentionsProject(file.Path, normalizedProject) {
   105→			continue
   106→		}
   107→		session, err := parseFactorySession(file.Path)
   108→		if err != nil {
   109→			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
   110→			continue
   111→		}
   112→		chat := convertToAgentSession(session, projectPath, debugRaw)
   113→		if chat != nil {
   114→			result = append(result, *chat)
   115→		}
   116→	}
   117→	return result, nil
   118→}
   119→
   120→func (p *Provider) GetAgentChatSession(projectPath string, sessionID string, debugRaw bool) (*spi.AgentChatSession, error) {
   121→	path, err := findSessionFileByID(sessionID)
   122→	if err != nil || path == "" {
   123→		return nil, err
   124→	}
   125→	if strings.TrimSpace(projectPath) != "" && !sessionMentionsProject(path, projectPath) {
   126→		return nil, nil
   127→	}
   128→	session, err := parseFactorySession(path)
   129→	if err != nil {
   130→		return nil, err
   131→	}
   132→	return convertToAgentSession(session, projectPath, debugRaw), nil
   133→}
   134→
   135→func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   136→	if sessionCallback == nil {
   137→		return ExecuteDroid(customCommand, resumeSessionID)
   138→	}
   139→
   140→	ctx, cancel := context.WithCancel(context.Background())
   141→	defer cancel()
   142→
   143→	watchErr := make(chan error, 1)
   144→	go func() {
   145→		watchErr <- watchSessions(ctx, projectPath, debugRaw, sessionCallback)
   146→	}()
   147→
   148→	err := ExecuteDroid(customCommand, resumeSessionID)
   149→	cancel()
   150→
   151→	if werr := <-watchErr; werr != nil && !errors.Is(werr, context.Canceled) {
   152→		slog.Warn("droidcli: watcher stopped with error", "error", werr)
   153→	}
   154→
   155→	if err != nil {
   156→		return fmt.Errorf("factory droid CLI execution failed: %w", err)
   157→	}
   158→	return nil
   159→}
   160→
   161→func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   162→	if sessionCallback == nil {
   163→		return fmt.Errorf("session callback is required")
   164→	}
   165→	return watchSessions(ctx, projectPath, debugRaw, sessionCallback)
   166→}
   167→
   168→func convertToAgentSession(session *fdSession, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
   169→	if session == nil {
   170→		return nil
   171→	}
   172→	if len(session.Blocks) == 0 {
   173→		return nil
   174→	}
   175→	sessionData, err := GenerateAgentSession(session, workspaceRoot)
   176→	if err != nil {
   177→		slog.Debug("droidcli: skipping session due to conversion error", "sessionId", session.ID, "error", err)
   178→		return nil
   179→	}
   180→	created := strings.TrimSpace(sessionData.CreatedAt)
   181→	chat := &spi.AgentChatSession{
   182→		SessionID:   session.ID,
   183→		CreatedAt:   created,
   184→		Slug:        session.Slug,
   185→		SessionData: sessionData,
   186→		RawData:     session.RawData,
   187→	}
   188→	if debugRaw {
   189→		if err := writeFactoryDebugRaw(session); err != nil {
   190→			slog.Debug("droidcli: debug raw failed", "sessionId", session.ID, "error", err)
   191→		}
   192→	}
   193→	return chat
   194→}
   195→
   196→func classifyCheckError(err error) string {
   197→	var execErr *exec.Error
   198→	var pathErr *os.PathError
   199→	switch {
   200→	case errors.As(err, &execErr) && execErr.Err == exec.ErrNotFound:
   201→		return "not_found"
   202→	case errors.As(err, &pathErr) && errors.Is(pathErr.Err, os.ErrPermission):
   203→		return "permission_denied"
   204→	case errors.Is(err, os.ErrPermission):
   205→		return "permission_denied"
   206→	default:
   207→		return "version_failed"
   208→	}
   209→}
   210→
   211→func buildCheckErrorMessage(errorType string, command string, isCustom bool, stderr string) string {
   212→	var builder strings.Builder
   213→	switch errorType {
   214→	case "not_found":
   215→		builder.WriteString("Factory Droid CLI was not found.\n\n")
   216→		if isCustom {
   217→			builder.WriteString("• Verify the custom path you provided is executable.\n")
   218→			builder.WriteString(fmt.Sprintf("• Provided command: %s\n", command))
   219→		} else {
   220→			builder.WriteString("• Install the Factory CLI and ensure `droid` is on your PATH.\n")
   221→			builder.WriteString("• Re-run `specstory check droid` after installation.\n")
   222→		}
   223→	case "permission_denied":
   224→		builder.WriteString("SpecStory cannot execute the Factory CLI due to permissions.\n\n")
   225→		builder.WriteString(fmt.Sprintf("Try: chmod +x %s\n", command))
   226→	default:
   227→		builder.WriteString("`droid --version` failed.\n\n")
   228→		if stderr != "" {
   229→			builder.WriteString("Error output:\n")
   230→			builder.WriteString(stderr)
   231→			builder.WriteString("\n\n")
   232→		}
   233→		builder.WriteString("Run `droid --version` manually to diagnose, then retry.")
   234→	}
   235→	return builder.String()
   236→}
   237→
   238→var ansiRegexp = regexp.MustCompile(`\x1b\[[0-9;]*[A-Za-z]`)
   239→
   240→func sanitizeDroidVersion(raw string) string {
   241→	clean := strings.ReplaceAll(raw, "\r", "")
   242→	clean = ansiRegexp.ReplaceAllString(clean, "")
   243→	return clean
   244→}
   245→
   246→func extractDroidVersion(raw string) string {
   247→	lines := strings.Split(raw, "\n")
   248→	var filtered []string
   249→	for _, line := range lines {
   250→		line = strings.TrimSpace(line)
   251→		if line == "" {
   252→			continue
   253→		}
   254→		filtered = append(filtered, line)
   255→	}
   256→	if len(filtered) == 0 {
   257→		return ""
   258→	}
   259→	return filtered[len(filtered)-1]
   260→}
   261→
   262→func trackCheckSuccess(provider string, custom bool, commandPath string, resolvedPath string, pathType string, version string, versionFlag string) {
   263→	props := analytics.Properties{
   264→		"provider":       provider,
   265→		"custom_command": custom,
   266→		"command_path":   commandPath,
   267→		"resolved_path":  resolvedPath,
   268→		"path_type":      pathType,
   269→		"version":        version,
   270→		"version_flag":   versionFlag,
   271→	}
   272→	analytics.TrackEvent(analytics.EventCheckInstallSuccess, props)
   273→}
   274→
   275→func trackCheckFailure(provider string, custom bool, commandPath string, resolvedPath string, pathType string, versionFlag string, stderrOutput string, errorType string, message string) {
   276→	props := analytics.Properties{
   277→		"provider":       provider,
   278→		"custom_command": custom,
   279→		"command_path":   commandPath,
   280→		"resolved_path":  resolvedPath,
   281→		"path_type":      pathType,
   282→		"version_flag":   versionFlag,
   283→		"error_type":     errorType,
   284→		"error_message":  message,
   285→	}
   286→	if stderrOutput != "" {
   287→		props["stderr"] = stderrOutput
   288→	}
   289→	analytics.TrackEvent(analytics.EventCheckInstallFailed, props)
   290→}
   291→
   292→func classifyDroidPath(command string, resolvedPath string) string {
   293→	if resolvedPath == "" {
   294→		if filepath.IsAbs(command) {
   295→			return "absolute_path"
   296→		}
   297→		return "unknown"
   298→	}
   299→	resolvedLower := strings.ToLower(resolvedPath)
   300→	if strings.Contains(resolvedLower, "homebrew") || strings.Contains(resolvedLower, "/opt/homebrew/") {
   301→		return "homebrew"
   302→	}
   303→	if strings.Contains(resolvedLower, "/.local/bin/") {
   304→		return "user_local"
   305→	}
   306→	if strings.Contains(resolvedLower, "/.factory/") {
   307→		return "factory_local"
   308→	}
   309→	if filepath.IsAbs(command) {
   310→		return "absolute_path"
   311→	}
   312→	return "system_path"
   313→}
   314→
   315→func printDetectionHelp() {
   316→	log.UserMessage("No Factory Droid sessions found under ~/.factory/sessions yet.\n")
   317→	log.UserMessage("Run the Factory CLI inside this project to create a JSONL session, then rerun `specstory sync droid`.\n")
   318→}
   319→
   320→func sessionMentionsProject(filePath string, projectPath string) bool {
   321→	projectPath = strings.TrimSpace(projectPath)
   322→	if projectPath == "" {
   323→		return false
   324→	}
   325→
   326→	canonicalProject := canonicalizePath(projectPath)
   327→	if sessionRoot := extractSessionWorkspaceRoot(filePath); sessionRoot != "" {
   328→		canonicalRoot := canonicalizePath(sessionRoot)
   329→		if canonicalProject != "" && canonicalRoot != "" {
   330→			return canonicalRoot == canonicalProject
   331→		}
   332→		return strings.TrimSpace(sessionRoot) == projectPath
   333→	}
   334→
   335→	return sessionMentionsProjectText(filePath, projectPath)
   336→}
   337→
   338→func extractSessionWorkspaceRoot(filePath string) string {
   339→	file, err := os.Open(filePath)
   340→	if err != nil {
   341→		return ""
   342→	}
   343→	defer func() {
   344→		_ = file.Close()
   345→	}()
   346→
   347→	var workspaceRoot string
   348→	scanErr := scanLines(file, func(line string) error {
   349→		trimmed := strings.TrimSpace(line)
   350→		if trimmed == "" {
   351→			return nil
   352→		}
   353→		var env jsonlEnvelope
   354→		if err := json.Unmarshal([]byte(trimmed), &env); err != nil {
   355→			return nil
   356→		}
   357→		if env.Type != "session_start" {
   358→			return nil
   359→		}
   360→		var event sessionStartEvent
   361→		if err := json.Unmarshal([]byte(trimmed), &event); err != nil {
   362→			return nil
   363→		}
   364→		workspaceRoot = firstNonEmpty(event.CWD, event.WorkspaceRoot, event.Session.CWD, event.Session.WorkspaceRoot)
   365→		return errStopScan
   366→	})
   367→	if scanErr != nil && !errors.Is(scanErr, errStopScan) {
   368→		return ""
   369→	}
   370→
   371→	return strings.TrimSpace(workspaceRoot)
   372→}
   373→
   374→func canonicalizePath(path string) string {
   375→	trimmed := strings.TrimSpace(path)
   376→	if trimmed == "" {
   377→		return ""
   378→	}
   379→	canonical, err := spi.GetCanonicalPath(trimmed)
   380→	if err == nil {
   381→		return canonical
   382→	}
   383→	if abs, absErr := filepath.Abs(trimmed); absErr == nil {
   384→		return filepath.Clean(abs)
   385→	}
   386→	return filepath.Clean(trimmed)
   387→}
   388→
   389→func sessionMentionsProjectText(filePath string, projectPath string) bool {
   390→	file, err := os.Open(filePath)
   391→	if err != nil {
   392→		return false
   393→	}
   394→	defer func() {
   395→		_ = file.Close()
   396→	}()
   397→	needle := strings.TrimSpace(projectPath)
   398→	short := filepath.Base(projectPath)
   399→	foundLines := 0
   400→	err = scanLines(file, func(line string) error {
   401→		if needle != "" && strings.Contains(line, needle) {
   402→			return errStopScan
   403→		}
   404→		if short != "" && strings.Contains(line, short) {
   405→			foundLines++
   406→			if foundLines > 2 {
   407→				return errStopScan
   408→			}
   409→		}
   410→		return nil
   411→	})
   412→
   413→	if err != nil && !errors.Is(err, errStopScan) {
   414→		slog.Warn("error scanning session file", "path", filePath, "err", err)
   415→		return false
   416→	}
   417→
   418→	return errors.Is(err, errStopScan)
   419→}
   420→
   421→func writeFactoryDebugRaw(session *fdSession) error {
   422→	if session == nil {
   423→		return nil
   424→	}
   425→	dir := spi.GetDebugDir(session.ID)
   426→	if err := os.MkdirAll(dir, 0o755); err != nil {
   427→		return fmt.Errorf("droidcli: unable to create debug dir: %w", err)
   428→	}
   429→	if err := os.WriteFile(filepath.Join(dir, "session.jsonl"), []byte(session.RawData), 0o644); err != nil {
   430→		return fmt.Errorf("droidcli: unable to write debug raw: %w", err)
   431→	}
   432→	meta := fmt.Sprintf("Session: %s\nTitle: %s\nCreated: %s\nBlocks: %d\n", session.ID, session.Title, session.CreatedAt, len(session.Blocks))
   433→	return os.WriteFile(filepath.Join(dir, "summary.txt"), []byte(meta), 0o644)
   434→}
   435→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-29 15:59:59Z)**_

<think><details><summary>Thought Process</summary>
Now I have a complete picture. Let me launch a Plan agent to design the implementation approach.

Key observations:
1. **Droid's current structure**: `~/.factory/sessions/` with `.jsonl` files (potentially recursive via `filepath.WalkDir`)
2. **Claude Code pattern**: Uses fsnotify with global context/WaitGroup, thread-safe callbacks, handles parent directory watching when target doesn't exist
3. **The Droid provider** has simpler integration compared to Claude Code - it passes context directly to `watchSessions()` rather than using package-level globals

I need to design a solution that:
1. Replaces the ticker-based polling with fsnotify
2. Handles the case where `~/.factory/sessions/` might not exist yet
3. Watches for new subdirectories if the sessions directory has a hierarchical structure
4. Maintains compatibility with the existing provider interface (`WatchAgent` and `ExecAgentAndWatch`)
5. Follows the existing patterns in the codebase

Let me launch a Plan agent to design the implementation.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:00:00Z)**_

Now I have a complete understanding of both implementations. Let me launch a Plan agent to design the implementation approach.

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:00:13Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Design fsnotify migration plan
```
[Request interrupted by user for tool use]
```
</details></tool-use>

_**Agent - sidechain (2026-01-29 16:00:13Z)**_

Design an implementation plan for migrating the Droid provider from polling-based file watching to fsnotify event-based watching.

## Current State

**Droid provider** (`pkg/providers/droidcli/watcher.go`):
- Uses `time.NewTicker(1 * time.Second)` polling
- Watches `~/.factory/sessions/` directory
- Uses `listSessionFiles()` with `filepath.WalkDir` to find `.jsonl` files (recursive)
- Tracks processed files via `watchState.lastProcessed` map (filepath -> ModTime)
- Context-based cancellation
- `scanAndProcessSessions()` iterates all files on each tick, comparing ModTime

**Claude Code provider** (`pkg/providers/claudecode/watcher.go`) - reference implementation:
- Uses fsnotify for event-based watching
- Package-level globals: `watcherCtx`, `watcherCancel`, `watcherWg`, `watcherCallback`, `watcherMutex`
- Thread-safe callback management via `SetWatcherCallback()`, `getWatcherCallback()`
- `StopWatcher()` for graceful shutdown
- Handles case where project directory doesn't exist (watches parent dir)
- Event filtering: only processes `.jsonl` files with Create/Write events

## Key Differences

1. **Integration style**: Claude Code uses package-level globals; Droid passes context directly to `watchSessions()`
2. **Directory structure**: Droid uses `~/.factory/sessions/` which may have subdirectories
3. **Provider methods**: Both implement `WatchAgent()` and `ExecAgentAndWatch()` from SPI

## Design Requirements

1. Replace polling with fsnotify event-based watching
2. Handle case where `~/.factory/sessions/` doesn't exist yet (watch `~/.factory` for creation)
3. Watch subdirectories recursively if needed (sessions may be in nested folders)
4. Maintain backward compatibility with existing provider interface
5. Follow existing patterns - decide whether to use Claude Code's package-level globals pattern or keep the current context-passing pattern
6. Include proper cleanup and error handling

## Questions to Address

1. Should the Droid provider adopt the Claude Code pattern with package-level globals, or adapt fsnotify to work with the current context-passing pattern?
2. How should subdirectory watching be handled - watch all subdirs upfront, or add watches dynamically as directories are created?
3. Should there be any debouncing for rapid file changes?

Please provide a detailed implementation plan with:
- Recommended approach and rationale
- Files to modify
- Key functions to add/change
- Code structure outline

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:16Z)**_

I'll explore the codebase to understand the current implementations and design an implementation plan for migrating the Droid provider from polling to fsnotify.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:16Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/watcher.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"time"
     8→
     9→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    10→)
    11→
    12→const droidWatchInterval = 1 * time.Second
    13→
    14→type watchState struct {
    15→	lastProcessed map[string]int64
    16→}
    17→
    18→func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
    19→	if sessionCallback == nil {
    20→		return fmt.Errorf("session callback is required")
    21→	}
    22→
    23→	state := &watchState{lastProcessed: make(map[string]int64)}
    24→	if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    25→		return err
    26→	}
    27→
    28→	ticker := time.NewTicker(droidWatchInterval)
    29→	defer ticker.Stop()
    30→
    31→	for {
    32→		select {
    33→		case <-ctx.Done():
    34→			return ctx.Err()
    35→		case <-ticker.C:
    36→			if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
    37→				slog.Debug("droidcli: scan failed", "error", err)
    38→			}
    39→		}
    40→	}
    41→}
    42→
    43→func scanAndProcessSessions(projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) error {
    44→	files, err := listSessionFiles()
    45→	if err != nil {
    46→		return err
    47→	}
    48→
    49→	for _, file := range files {
    50→		if last, ok := state.lastProcessed[file.Path]; ok && last >= file.ModTime {
    51→			continue
    52→		}
    53→		if projectPath != "" && !sessionMentionsProject(file.Path, projectPath) {
    54→			continue
    55→		}
    56→		session, err := parseFactorySession(file.Path)
    57→		if err != nil {
    58→			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
    59→			continue
    60→		}
    61→		chat := convertToAgentSession(session, projectPath, debugRaw)
    62→		if chat == nil {
    63→			continue
    64→		}
    65→		state.lastProcessed[file.Path] = file.ModTime
    66→		dispatchSession(sessionCallback, chat)
    67→	}
    68→	return nil
    69→}
    70→
    71→func dispatchSession(sessionCallback func(*spi.AgentChatSession), session *spi.AgentChatSession) {
    72→	if sessionCallback == nil || session == nil {
    73→		return
    74→	}
    75→	go func() {
    76→		defer func() {
    77→			if r := recover(); r != nil {
    78→				slog.Error("droidcli: session callback panicked", "panic", r)
    79→			}
    80→		}()
    81→		sessionCallback(session)
    82→	}()
    83→}
    84→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:17Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/claudecode/watcher.go`
```
     1→package claudecode
     2→
     3→import (
     4→	"context"
     5→	"encoding/json"
     6→	"fmt"
     7→	"log/slog"
     8→	"os"
     9→	"path/filepath"
    10→	"strings"
    11→	"sync"
    12→	"time"
    13→
    14→	"github.com/fsnotify/fsnotify"
    15→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    17→)
    18→
    19→var (
    20→	watcherCtx      context.Context
    21→	watcherCancel   context.CancelFunc
    22→	watcherWg       sync.WaitGroup
    23→	watcherCallback func(*spi.AgentChatSession) // Callback for session updates
    24→	watcherDebugRaw bool                        // Whether to write debug raw data files
    25→	watcherMutex    sync.RWMutex                // Protects watcherCallback and watcherDebugRaw
    26→)
    27→
    28→func init() {
    29→	watcherCtx, watcherCancel = context.WithCancel(context.Background())
    30→}
    31→
    32→// SetWatcherCallback sets the callback function for session updates
    33→func SetWatcherCallback(callback func(*spi.AgentChatSession)) {
    34→	watcherMutex.Lock()
    35→	defer watcherMutex.Unlock()
    36→	watcherCallback = callback
    37→	slog.Info("SetWatcherCallback: Callback set", "isNil", callback == nil)
    38→}
    39→
    40→// ClearWatcherCallback clears the callback function
    41→func ClearWatcherCallback() {
    42→	watcherMutex.Lock()
    43→	defer watcherMutex.Unlock()
    44→	watcherCallback = nil
    45→	slog.Info("ClearWatcherCallback: Callback cleared")
    46→}
    47→
    48→// SetWatcherDebugRaw sets whether to write debug raw data files
    49→func SetWatcherDebugRaw(debugRaw bool) {
    50→	watcherMutex.Lock()
    51→	defer watcherMutex.Unlock()
    52→	watcherDebugRaw = debugRaw
    53→	slog.Debug("SetWatcherDebugRaw: Debug raw set", "debugRaw", debugRaw)
    54→}
    55→
    56→// getWatcherDebugRaw returns the current debug raw setting (thread-safe)
    57→func getWatcherDebugRaw() bool {
    58→	watcherMutex.RLock()
    59→	defer watcherMutex.RUnlock()
    60→	return watcherDebugRaw
    61→}
    62→
    63→// getWatcherCallback returns the current callback function (thread-safe)
    64→func getWatcherCallback() func(*spi.AgentChatSession) {
    65→	watcherMutex.RLock()
    66→	defer watcherMutex.RUnlock()
    67→	return watcherCallback
    68→}
    69→
    70→// StopWatcher gracefully stops the watcher goroutine
    71→func StopWatcher() {
    72→	slog.Info("StopWatcher: Signaling watcher to stop")
    73→	watcherCancel()
    74→	slog.Info("StopWatcher: Waiting for watcher goroutine to finish")
    75→	watcherWg.Wait()
    76→	slog.Info("StopWatcher: Watcher stopped")
    77→}
    78→
    79→// WatchForProjectDir watches for a project directory that matches the current working directory
    80→func WatchForProjectDir() error {
    81→	slog.Info("WatchForProjectDir: Determining project directory to monitor")
    82→	claudeProjectDir, err := GetClaudeCodeProjectDir("")
    83→	if err != nil {
    84→		slog.Error("WatchForProjectDir: Failed to get project directory", "error", err)
    85→		// Check if error is specifically about missing Claude projects directory
    86→		if strings.Contains(err.Error(), "claude projects directory not found") {
    87→			slog.Error("WatchForProjectDir: Claude projects directory not found while starting setup watcher")
    88→			// Start watching for Claude directory creation
    89→			return WatchForClaudeSetup()
    90→		}
    91→		return fmt.Errorf("failed to get project directory: %v", err)
    92→	}
    93→
    94→	slog.Info("WatchForProjectDir: Project directory found", "directory", claudeProjectDir)
    95→	return startProjectWatcher(claudeProjectDir)
    96→}
    97→
    98→// startProjectWatcher starts watching a specific project directory
    99→func startProjectWatcher(claudeProjectDir string) error {
   100→	slog.Info("startProjectWatcher: Creating file watcher", "directory", claudeProjectDir)
   101→
   102→	// Create a new watcher
   103→	watcher, err := fsnotify.NewWatcher()
   104→	if err != nil {
   105→		return fmt.Errorf("failed to create file watcher: %v", err)
   106→	}
   107→
   108→	// Increment wait group before starting goroutine
   109→	watcherWg.Add(1)
   110→
   111→	// Start watching in a goroutine
   112→	go func() {
   113→		// Decrement wait group when done
   114→		defer watcherWg.Done()
   115→
   116→		// Log when goroutine starts
   117→		slog.Info("startProjectWatcher: Goroutine started")
   118→
   119→		// Defer cleanup
   120→		defer func() {
   121→			slog.Info("startProjectWatcher: Goroutine exiting, closing watcher")
   122→			_ = watcher.Close() // Best effort cleanup; errors here are not recoverable
   123→		}()
   124→
   125→		// Check if project directory already exists
   126→		if _, err := os.Stat(claudeProjectDir); err == nil {
   127→			slog.Info("startProjectWatcher: Project directory exists", "directory", claudeProjectDir)
   128→			// Claude Code triggers file system events when it starts writing, so we'll catch the session on the first write event.
   129→			slog.Info("startProjectWatcher: Waiting for JSONL file system events")
   130→		} else {
   131→			// Project directory doesn't exist yet, watch parent directory (or other error)
   132→			parentDir := filepath.Dir(claudeProjectDir)
   133→			projectName := filepath.Base(claudeProjectDir)
   134→			slog.Warn("startProjectWatcher: Cannot access project directory, watching parent",
   135→				"error", err,
   136→				"parentDir", parentDir,
   137→				"projectName", projectName)
   138→
   139→			// Add parent directory to watcher
   140→			if err := watcher.Add(parentDir); err != nil {
   141→				log.UserError("Error watching parent directory: %v", err)
   142→				slog.Error("startProjectWatcher: Failed to watch parent directory", "error", err)
   143→				return
   144→			}
   145→
   146→			// Wait for project directory to be created
   147→			waitingForCreation := true
   148→			slog.Info("startProjectWatcher: Now watching for events in parent directory")
   149→			for waitingForCreation {
   150→				select {
   151→				case <-watcherCtx.Done():
   152→					slog.Info("startProjectWatcher: Context cancelled while waiting for directory creation")
   153→					return
   154→				case event, ok := <-watcher.Events:
   155→					if !ok {
   156→						slog.Info("startProjectWatcher: Watcher events channel closed")
   157→						return
   158→					}
   159→					slog.Info("startProjectWatcher: Parent directory event",
   160→						"operation", event.Op.String(),
   161→						"path", event.Name,
   162→						"lookingFor", projectName)
   163→					eventBaseName := filepath.Base(event.Name)
   164→					slog.Info("startProjectWatcher: Event basename comparison",
   165→						"basename", eventBaseName,
   166→						"comparingWith", projectName,
   167→						"equalFold", strings.EqualFold(eventBaseName, projectName))
   168→					if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), projectName) {
   169→						slog.Info("startProjectWatcher: Detected project directory creation",
   170→							"path", event.Name)
   171→						slog.Info("startProjectWatcher: Initial scan disabled; waiting for JSONL events")
   172→						// Use the actual created directory name from the event
   173→						claudeProjectDir = filepath.Join(parentDir, filepath.Base(event.Name))
   174→						// Remove parent directory and continue to watch project directory
   175→						_ = watcher.Remove(parentDir) // OK if this fails; we're moving to project dir
   176→						waitingForCreation = false
   177→					}
   178→				case err, ok := <-watcher.Errors:
   179→					if !ok {
   180→						slog.Info("startProjectWatcher: Watcher errors channel closed")
   181→						return
   182→					}
   183→					log.UserWarn("Watcher error while waiting for project directory: %v", err)
   184→					slog.Error("startProjectWatcher: Watcher error", "error", err)
   185→				}
   186→			}
   187→		}
   188→
   189→		// Add the project directory to the watcher
   190→		// Re-stat to get the actual directory name with correct case
   191→		actualProjectDir := claudeProjectDir
   192→		if entries, err := os.ReadDir(filepath.Dir(claudeProjectDir)); err == nil {
   193→			baseName := filepath.Base(claudeProjectDir)
   194→			for _, entry := range entries {
   195→				if strings.EqualFold(entry.Name(), baseName) {
   196→					actualProjectDir = filepath.Join(filepath.Dir(claudeProjectDir), entry.Name())
   197→					break
   198→				}
   199→			}
   200→		}
   201→		slog.Info("startProjectWatcher: Now monitoring project directory for changes",
   202→			"directory", actualProjectDir)
   203→		if err := watcher.Add(actualProjectDir); err != nil {
   204→			log.UserWarn("Error watching project directory: %v", err)
   205→			slog.Error("startProjectWatcher: Failed to monitor directory", "error", err)
   206→			return
   207→		}
   208→		slog.Info("startProjectWatcher: Successfully monitoring project directory for future changes")
   209→
   210→		// Watch for file events
   211→		for {
   212→			select {
   213→			case <-watcherCtx.Done():
   214→				slog.Info("startProjectWatcher: Context cancelled, stopping watcher")
   215→				return
   216→			case event, ok := <-watcher.Events:
   217→				if !ok {
   218→					return
   219→				}
   220→
   221→				// Only process JSONL files
   222→				if !strings.HasSuffix(event.Name, ".jsonl") {
   223→					continue
   224→				}
   225→
   226→				if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) {
   227→					continue
   228→				}
   229→
   230→				// Handle different event types
   231→				switch {
   232→				case event.Has(fsnotify.Create):
   233→					slog.Info("New JSONL file created", "file", event.Name)
   234→					scanJSONLFiles(claudeProjectDir, event.Name)
   235→				case event.Has(fsnotify.Write):
   236→					slog.Info("JSONL file modified", "file", event.Name)
   237→					slog.Info("Triggering scan due to file modification")
   238→					scanJSONLFiles(claudeProjectDir, event.Name)
   239→				}
   240→
   241→			case err, ok := <-watcher.Errors:
   242→				if !ok {
   243→					return
   244→				}
   245→				log.UserError("Watcher error: %v", err)
   246→			}
   247→		}
   248→	}()
   249→
   250→	return nil
   251→}
   252→
   253→// scanJSONLFiles scans JSONL files and optionally filters processing to a specific changed file
   254→func scanJSONLFiles(claudeProjectDir string, changedFile ...string) {
   255→	// Ensure logs are flushed even if we panic
   256→	defer func() {
   257→		if r := recover(); r != nil {
   258→			log.UserWarn("PANIC in ScanJSONLFiles: %v", r)
   259→			slog.Error("ScanJSONLFiles: PANIC recovered", "panic", r)
   260→		}
   261→	}()
   262→
   263→	slog.Info("ScanJSONLFiles: === START SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   264→	var targetFile string
   265→	if len(changedFile) > 0 && changedFile[0] != "" {
   266→		targetFile = changedFile[0]
   267→		slog.Info("ScanJSONLFiles: Scanning JSONL files with changed file",
   268→			"directory", claudeProjectDir,
   269→			"changedFile", targetFile)
   270→	} else {
   271→		slog.Info("ScanJSONLFiles: Scanning JSONL files", "directory", claudeProjectDir)
   272→	}
   273→	// Parse files and create history files:
   274→	parser := NewJSONLParser()
   275→	var targetSessionUuid string
   276→
   277→	// Set the target file for conditional debug output
   278→	if targetFile != "" {
   279→		SetDebugTargetFile(targetFile)
   280→		defer ClearDebugTargetFile()
   281→
   282→		sessionID, err := extractSessionIDFromFile(targetFile)
   283→		if err != nil {
   284→			slog.Warn("ScanJSONLFiles: Failed to extract session ID from file",
   285→				"file", targetFile,
   286→				"error", err)
   287→			slog.Info("ScanJSONLFiles: Skipping scan due to file read error", "file", targetFile)
   288→			return
   289→		}
   290→		if sessionID == "" {
   291→			slog.Info("ScanJSONLFiles: Skipping scan; session ID not present yet", "file", targetFile)
   292→			return
   293→		}
   294→		targetSessionUuid = sessionID
   295→		slog.Info("ScanJSONLFiles: Extracted session ID from changed file",
   296→			"sessionUuid", targetSessionUuid,
   297→			"file", targetFile)
   298→	}
   299→
   300→	var parseErr error
   301→	if targetSessionUuid != "" {
   302→		parseErr = parser.ParseProjectSessionsForSession(claudeProjectDir, true, targetSessionUuid)
   303→	} else {
   304→		parseErr = parser.ParseProjectSessions(claudeProjectDir, true)
   305→	}
   306→	if parseErr != nil {
   307→		log.UserWarn("Error parsing project sessions: %v", parseErr)
   308→		slog.Error("ScanJSONLFiles: Error parsing project sessions", "error", parseErr)
   309→		return
   310→	}
   311→
   312→	// Process JSONL sessions (isAutosave = true, silent = false for autosave)
   313→	slog.Info("ScanJSONLFiles: Processing sessions",
   314→		"sessionCount", len(parser.Sessions),
   315→		"targetSessionUuid", targetSessionUuid)
   316→
   317→	// Get the session callback
   318→	callback := getWatcherCallback()
   319→	if callback == nil {
   320→		slog.Error("ScanJSONLFiles: No callback provided - this should not happen")
   321→		return
   322→	}
   323→
   324→	slog.Info("ScanJSONLFiles: Processing sessions with callback")
   325→	// Process sessions and call the callback for each
   326→	for _, session := range parser.Sessions {
   327→		// Skip empty sessions
   328→		if len(session.Records) == 0 {
   329→			continue
   330→		}
   331→
   332→		// Skip if we're targeting a specific session and this isn't it
   333→		if targetSessionUuid != "" && session.SessionUuid != targetSessionUuid {
   334→			continue
   335→		}
   336→
   337→		// Convert to AgentChatSession (workspaceRoot extracted from records' cwd field)
   338→		agentSession := convertToAgentChatSession(session, "", getWatcherDebugRaw())
   339→		if agentSession != nil {
   340→			slog.Info("ScanJSONLFiles: Calling callback for session", "sessionId", agentSession.SessionID)
   341→			// Call the callback in a goroutine to avoid blocking
   342→			go func(s *spi.AgentChatSession) {
   343→				defer func() {
   344→					if r := recover(); r != nil {
   345→						slog.Error("ScanJSONLFiles: Callback panicked", "panic", r)
   346→					}
   347→				}()
   348→				callback(s)
   349→			}(agentSession)
   350→		}
   351→	}
   352→	slog.Info("ScanJSONLFiles: Processing complete")
   353→	slog.Info("ScanJSONLFiles: === END SCAN ===", "timestamp", time.Now().Format(time.RFC3339))
   354→}
   355→
   356→// WatchForClaudeSetup watches for the creation of Claude directories
   357→func WatchForClaudeSetup() error {
   358→	slog.Info("WatchForClaudeSetup: Starting Claude directory setup watcher")
   359→	homeDir, err := os.UserHomeDir()
   360→	if err != nil {
   361→		return fmt.Errorf("failed to get user home directory: %v", err)
   362→	}
   363→
   364→	claudeDir := filepath.Join(homeDir, ".claude")
   365→	projectsDir := filepath.Join(claudeDir, "projects")
   366→	slog.Info("WatchForClaudeSetup: Directories",
   367→		"homeDir", homeDir,
   368→		"claudeDir", claudeDir,
   369→		"projectsDir", projectsDir)
   370→
   371→	// Determine what to watch
   372→	var watchDir string
   373→	var watchingFor string
   374→
   375→	if _, err := os.Stat(claudeDir); os.IsNotExist(err) {
   376→		// .claude doesn't exist, watch home directory
   377→		watchDir = homeDir
   378→		watchingFor = ".claude"
   379→		slog.Warn("WatchForClaudeSetup: .claude directory does not exist")
   380→		slog.Info("Claude directory not found, watching for creation of ~/.claude\n")
   381→	} else {
   382→		// .claude exists but projects doesn't, watch .claude
   383→		watchDir = claudeDir
   384→		watchingFor = "projects"
   385→		slog.Warn("WatchForClaudeSetup: .claude directory exists, checking for projects")
   386→		slog.Info("Claude directory found, watching for creation of ~/.claude/projects\n")
   387→	}
   388→	slog.Info("WatchForClaudeSetup: Will watch directory",
   389→		"watchDir", watchDir,
   390→		"watchingFor", watchingFor)
   391→
   392→	// Create watcher
   393→	watcher, err := fsnotify.NewWatcher()
   394→	if err != nil {
   395→		log.UserWarn("Failed to create file watcher: %v", err)
   396→		slog.Error("WatchForClaudeSetup: Failed to create file watcher", "error", err)
   397→		return fmt.Errorf("failed to create file watcher: %v", err)
   398→	}
   399→
   400→	// Add directory to watch
   401→	slog.Info("WatchForClaudeSetup: Adding directory to watcher", "directory", watchDir)
   402→	if err := watcher.Add(watchDir); err != nil {
   403→		_ = watcher.Close() // Clean up on error; close errors less important than Add error
   404→		return fmt.Errorf("failed to watch directory %s: %v", watchDir, err)
   405→	}
   406→	slog.Info("WatchForClaudeSetup: Successfully started watching", "directory", watchDir)
   407→
   408→	// Start watching in a goroutine
   409→	go func() {
   410→		defer func() { _ = watcher.Close() }() // Cleanup on exit; errors not recoverable
   411→
   412→		for {
   413→			select {
   414→			case event, ok := <-watcher.Events:
   415→				if !ok {
   416→					return
   417→				}
   418→
   419→				slog.Info("WatchForClaudeSetup: Received event",
   420→					"operation", event.Op.String(),
   421→					"path", event.Name)
   422→				// Check if this is the directory we're waiting for (case-insensitive)
   423→				if event.Has(fsnotify.Create) && strings.EqualFold(filepath.Base(event.Name), watchingFor) {
   424→					slog.Info("Detected creation", "path", event.Name)
   425→					slog.Info("WatchForClaudeSetup: Target directory created", "path", event.Name)
   426→
   427→					// Wait a second to let things settle
   428→					slog.Info("WatchForClaudeSetup: Waiting 1 second for things to settle")
   429→					time.Sleep(1 * time.Second)
   430→
   431→					// Check what we should do next
   432→					if watchingFor == ".claude" {
   433→						slog.Info("WatchForClaudeSetup: .claude was created, checking if projects exists")
   434→						// We were watching for .claude, now check if projects exists
   435→						if _, err := os.Stat(projectsDir); os.IsNotExist(err) {
   436→							slog.Info("WatchForClaudeSetup: projects directory does not exist, switching watcher")
   437→							// Need to watch for projects directory
   438→							_ = watcher.Remove(watchDir) // OK if fails; switching watch targets
   439→							watchDir = claudeDir
   440→							watchingFor = "projects"
   441→							slog.Info("WatchForClaudeSetup: Switching to watch",
   442→								"watchDir", watchDir,
   443→								"watchingFor", watchingFor)
   444→							if err := watcher.Add(watchDir); err != nil {
   445→								log.UserWarn("Error switching to watch .claude directory: %v", err)
   446→								slog.Error("WatchForClaudeSetup: Failed to switch watcher", "error", err)
   447→								return
   448→							}
   449→							slog.Info("Now watching for creation of ~/.claude/projects\n")
   450→							continue
   451→						} else {
   452→							slog.Info("WatchForClaudeSetup: projects directory already exists!")
   453→						}
   454→					}
   455→
   456→					// If we get here, projects directory should exist
   457→					slog.Info("WatchForClaudeSetup: Projects directory should now exist, cleaning up watcher")
   458→					// Remove the current watcher
   459→					_ = watcher.Remove(watchDir) // OK if fails; we're transitioning to project watcher
   460→
   461→					// Start the normal project watcher
   462→					slog.Info("Claude projects directory now exists, starting normal file watcher\n")
   463→					// Try to get the project directory again
   464→					slog.Info("WatchForClaudeSetup: Getting project directory name")
   465→					if projectDir, err := GetClaudeCodeProjectDir(""); err == nil {
   466→						slog.Info("WatchForClaudeSetup: Project directory will be", "directory", projectDir)
   467→						if err := startProjectWatcher(projectDir); err != nil {
   468→							log.UserWarn("Error starting project watcher: %v", err)
   469→							slog.Error("WatchForClaudeSetup: Failed to start project watcher", "error", err)
   470→						} else {
   471→							slog.Info("WatchForClaudeSetup: Successfully started project watcher")
   472→						}
   473→					} else {
   474→						log.UserWarn("Error getting project directory after Claude setup: %v", err)
   475→						slog.Error("WatchForClaudeSetup: Failed to get project directory", "error", err)
   476→					}
   477→					return
   478→				}
   479→
   480→			case err, ok := <-watcher.Errors:
   481→				if !ok {
   482→					return
   483→				}
   484→				log.UserWarn("Watcher error: %v", err)
   485→				slog.Error("WatchForClaudeSetup: Watcher error", "error", err)
   486→			}
   487→		}
   488→	}()
   489→
   490→	return nil
   491→}
   492→
   493→// convertToAgentChatSession converts a Session to an AgentChatSession
   494→// Returns nil if the session is warmup-only (no real messages)
   495→func convertToAgentChatSession(session Session, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
   496→	// Skip empty sessions (no records)
   497→	if len(session.Records) == 0 {
   498→		return nil
   499→	}
   500→
   501→	// Write debug files first (even for warmup-only sessions)
   502→	_ = make(map[int]int) // recordToFileNumber no longer needed
   503→	if debugRaw {
   504→		// Write debug files
   505→		writeDebugRawFiles(session)
   506→	}
   507→
   508→	// Filter warmup messages
   509→	filteredRecords := filterWarmupMessages(session.Records)
   510→
   511→	// Skip if no real messages remain after filtering warmup
   512→	if len(filteredRecords) == 0 {
   513→		slog.Debug("Skipping warmup-only session", "sessionId", session.SessionUuid)
   514→		return nil
   515→	}
   516→
   517→	// Create session with filtered records
   518→	filteredSession := Session{
   519→		SessionUuid: session.SessionUuid,
   520→		Records:     filteredRecords,
   521→	}
   522→
   523→	// Get timestamp from root record
   524→	rootRecord := filteredSession.Records[0]
   525→	timestamp, ok := rootRecord.Data["timestamp"].(string)
   526→	if !ok {
   527→		slog.Warn("convertToAgentChatSession: No timestamp found in root record")
   528→		return nil
   529→	}
   530→
   531→	// Get the slug
   532→	slug := FileSlugFromRootRecord(filteredSession)
   533→
   534→	// Generate SessionData from filtered session
   535→	sessionData, err := GenerateAgentSession(filteredSession, workspaceRoot)
   536→	if err != nil {
   537→		slog.Error("Failed to generate SessionData", "sessionId", session.SessionUuid, "error", err)
   538→		return nil
   539→	}
   540→
   541→	// Convert session records to JSONL format for raw data
   542→	// Note: Uses unfiltered session.Records (not filteredSession.Records) to preserve
   543→	// all records including warmup messages in the raw data for complete audit trail
   544→	var rawDataBuilder strings.Builder
   545→	for _, record := range session.Records {
   546→		jsonBytes, _ := json.Marshal(record.Data)
   547→		rawDataBuilder.Write(jsonBytes)
   548→		rawDataBuilder.WriteString("\n")
   549→	}
   550→
   551→	return &spi.AgentChatSession{
   552→		SessionID:   session.SessionUuid,
   553→		CreatedAt:   timestamp, // ISO 8601 timestamp
   554→		Slug:        slug,
   555→		SessionData: sessionData,
   556→		RawData:     rawDataBuilder.String(),
   557→	}
   558→}
   559→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:18Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/spi/spi.go`
```
<tool_use_error>File does not exist.</tool_use_error>
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:21Z)**_

Let me find the SPI file and explore more of the Droid provider structure.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:22Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `./` pattern `**/spi*.go`
```
No files found
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:22Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `./` pattern `**/droidcli/*.go`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/agent_session.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/droid_exec.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/types.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/watcher.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/markdown_tools_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/provider_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/parser_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/agent_session_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/providers/droidcli/markdown_tools.go
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:25Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `./pkg/spi` pattern `**/*.go`
```
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/cmdline.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/cmdline_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/filename_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/path_utils_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/schema/types.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/schema/types_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/path_utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/provider.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/spi/factory/registry.go
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:26Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/provider.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"bytes"
     5→	"context"
     6→	"encoding/json"
     7→	"errors"
     8→	"fmt"
     9→	"log/slog"
    10→	"os"
    11→	"os/exec"
    12→	"path/filepath"
    13→	"regexp"
    14→	"strings"
    15→
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    18→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    19→)
    20→
    21→const defaultFactoryCommand = "droid"
    22→
    23→type Provider struct{}
    24→
    25→func NewProvider() *Provider {
    26→	return &Provider{}
    27→}
    28→
    29→func (p *Provider) Name() string {
    30→	return "Factory Droid CLI"
    31→}
    32→
    33→func (p *Provider) Check(customCommand string) spi.CheckResult {
    34→	cmdName, _ := parseDroidCommand(customCommand)
    35→	isCustom := strings.TrimSpace(customCommand) != ""
    36→	versionFlag := "--version"
    37→
    38→	resolved, err := exec.LookPath(cmdName)
    39→	if err != nil {
    40→		msg := buildCheckErrorMessage("not_found", cmdName, isCustom, "")
    41→		trackCheckFailure("droid", isCustom, cmdName, "", classifyDroidPath(cmdName, ""), versionFlag, "", "not_found", err.Error())
    42→		return spi.CheckResult{Success: false, Location: "", ErrorMessage: msg}
    43→	}
    44→	pathType := classifyDroidPath(cmdName, resolved)
    45→
    46→	var stdout, stderr bytes.Buffer
    47→	cmd := exec.Command(resolved, versionFlag)
    48→	cmd.Stdout = &stdout
    49→	cmd.Stderr = &stderr
    50→	if err := cmd.Run(); err != nil {
    51→		errorType := classifyCheckError(err)
    52→		stderrOutput := strings.TrimSpace(stderr.String())
    53→		msg := buildCheckErrorMessage(errorType, resolved, isCustom, stderrOutput)
    54→		trackCheckFailure("droid", isCustom, cmdName, resolved, pathType, versionFlag, stderrOutput, errorType, err.Error())
    55→		return spi.CheckResult{Success: false, Location: resolved, ErrorMessage: msg}
    56→	}
    57→
    58→	versionOutput := sanitizeDroidVersion(stdout.String())
    59→	version := extractDroidVersion(versionOutput)
    60→	if version == "" {
    61→		version = strings.TrimSpace(versionOutput)
    62→	}
    63→	trackCheckSuccess("droid", isCustom, cmdName, resolved, pathType, version, versionFlag)
    64→	return spi.CheckResult{Success: true, Version: version, Location: resolved}
    65→}
    66→
    67→func (p *Provider) DetectAgent(projectPath string, helpOutput bool) bool {
    68→	files, err := listSessionFiles()
    69→	if err != nil {
    70→		if helpOutput {
    71→			log.UserWarn("Factory Droid detection failed: %v", err)
    72→		}
    73→		return false
    74→	}
    75→	if len(files) == 0 {
    76→		if helpOutput {
    77→			printDetectionHelp()
    78→		}
    79→		return false
    80→	}
    81→	if projectPath == "" {
    82→		return true
    83→	}
    84→	for _, file := range files {
    85→		if sessionMentionsProject(file.Path, projectPath) {
    86→			return true
    87→		}
    88→	}
    89→	if helpOutput {
    90→		printDetectionHelp()
    91→	}
    92→	return false
    93→}
    94→
    95→func (p *Provider) GetAgentChatSessions(projectPath string, debugRaw bool) ([]spi.AgentChatSession, error) {
    96→	files, err := listSessionFiles()
    97→	if err != nil {
    98→		return nil, err
    99→	}
   100→	result := make([]spi.AgentChatSession, 0, len(files))
   101→	normalizedProject := strings.TrimSpace(projectPath)
   102→
   103→	for _, file := range files {
   104→		if normalizedProject != "" && !sessionMentionsProject(file.Path, normalizedProject) {
   105→			continue
   106→		}
   107→		session, err := parseFactorySession(file.Path)
   108→		if err != nil {
   109→			slog.Debug("droidcli: skipping session", "path", file.Path, "error", err)
   110→			continue
   111→		}
   112→		chat := convertToAgentSession(session, projectPath, debugRaw)
   113→		if chat != nil {
   114→			result = append(result, *chat)
   115→		}
   116→	}
   117→	return result, nil
   118→}
   119→
   120→func (p *Provider) GetAgentChatSession(projectPath string, sessionID string, debugRaw bool) (*spi.AgentChatSession, error) {
   121→	path, err := findSessionFileByID(sessionID)
   122→	if err != nil || path == "" {
   123→		return nil, err
   124→	}
   125→	if strings.TrimSpace(projectPath) != "" && !sessionMentionsProject(path, projectPath) {
   126→		return nil, nil
   127→	}
   128→	session, err := parseFactorySession(path)
   129→	if err != nil {
   130→		return nil, err
   131→	}
   132→	return convertToAgentSession(session, projectPath, debugRaw), nil
   133→}
   134→
   135→func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   136→	if sessionCallback == nil {
   137→		return ExecuteDroid(customCommand, resumeSessionID)
   138→	}
   139→
   140→	ctx, cancel := context.WithCancel(context.Background())
   141→	defer cancel()
   142→
   143→	watchErr := make(chan error, 1)
   144→	go func() {
   145→		watchErr <- watchSessions(ctx, projectPath, debugRaw, sessionCallback)
   146→	}()
   147→
   148→	err := ExecuteDroid(customCommand, resumeSessionID)
   149→	cancel()
   150→
   151→	if werr := <-watchErr; werr != nil && !errors.Is(werr, context.Canceled) {
   152→		slog.Warn("droidcli: watcher stopped with error", "error", werr)
   153→	}
   154→
   155→	if err != nil {
   156→		return fmt.Errorf("factory droid CLI execution failed: %w", err)
   157→	}
   158→	return nil
   159→}
   160→
   161→func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   162→	if sessionCallback == nil {
   163→		return fmt.Errorf("session callback is required")
   164→	}
   165→	return watchSessions(ctx, projectPath, debugRaw, sessionCallback)
   166→}
   167→
   168→func convertToAgentSession(session *fdSession, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
   169→	if session == nil {
   170→		return nil
   171→	}
   172→	if len(session.Blocks) == 0 {
   173→		return nil
   174→	}
   175→	sessionData, err := GenerateAgentSession(session, workspaceRoot)
   176→	if err != nil {
   177→		slog.Debug("droidcli: skipping session due to conversion error", "sessionId", session.ID, "error", err)
   178→		return nil
   179→	}
   180→	created := strings.TrimSpace(sessionData.CreatedAt)
   181→	chat := &spi.AgentChatSession{
   182→		SessionID:   session.ID,
   183→		CreatedAt:   created,
   184→		Slug:        session.Slug,
   185→		SessionData: sessionData,
   186→		RawData:     session.RawData,
   187→	}
   188→	if debugRaw {
   189→		if err := writeFactoryDebugRaw(session); err != nil {
   190→			slog.Debug("droidcli: debug raw failed", "sessionId", session.ID, "error", err)
   191→		}
   192→	}
   193→	return chat
   194→}
   195→
   196→func classifyCheckError(err error) string {
   197→	var execErr *exec.Error
   198→	var pathErr *os.PathError
   199→	switch {
   200→	case errors.As(err, &execErr) && execErr.Err == exec.ErrNotFound:
   201→		return "not_found"
   202→	case errors.As(err, &pathErr) && errors.Is(pathErr.Err, os.ErrPermission):
   203→		return "permission_denied"
   204→	case errors.Is(err, os.ErrPermission):
   205→		return "permission_denied"
   206→	default:
   207→		return "version_failed"
   208→	}
   209→}
   210→
   211→func buildCheckErrorMessage(errorType string, command string, isCustom bool, stderr string) string {
   212→	var builder strings.Builder
   213→	switch errorType {
   214→	case "not_found":
   215→		builder.WriteString("Factory Droid CLI was not found.\n\n")
   216→		if isCustom {
   217→			builder.WriteString("• Verify the custom path you provided is executable.\n")
   218→			builder.WriteString(fmt.Sprintf("• Provided command: %s\n", command))
   219→		} else {
   220→			builder.WriteString("• Install the Factory CLI and ensure `droid` is on your PATH.\n")
   221→			builder.WriteString("• Re-run `specstory check droid` after installation.\n")
   222→		}
   223→	case "permission_denied":
   224→		builder.WriteString("SpecStory cannot execute the Factory CLI due to permissions.\n\n")
   225→		builder.WriteString(fmt.Sprintf("Try: chmod +x %s\n", command))
   226→	default:
   227→		builder.WriteString("`droid --version` failed.\n\n")
   228→		if stderr != "" {
   229→			builder.WriteString("Error output:\n")
   230→			builder.WriteString(stderr)
   231→			builder.WriteString("\n\n")
   232→		}
   233→		builder.WriteString("Run `droid --version` manually to diagnose, then retry.")
   234→	}
   235→	return builder.String()
   236→}
   237→
   238→var ansiRegexp = regexp.MustCompile(`\x1b\[[0-9;]*[A-Za-z]`)
   239→
   240→func sanitizeDroidVersion(raw string) string {
   241→	clean := strings.ReplaceAll(raw, "\r", "")
   242→	clean = ansiRegexp.ReplaceAllString(clean, "")
   243→	return clean
   244→}
   245→
   246→func extractDroidVersion(raw string) string {
   247→	lines := strings.Split(raw, "\n")
   248→	var filtered []string
   249→	for _, line := range lines {
   250→		line = strings.TrimSpace(line)
   251→		if line == "" {
   252→			continue
   253→		}
   254→		filtered = append(filtered, line)
   255→	}
   256→	if len(filtered) == 0 {
   257→		return ""
   258→	}
   259→	return filtered[len(filtered)-1]
   260→}
   261→
   262→func trackCheckSuccess(provider string, custom bool, commandPath string, resolvedPath string, pathType string, version string, versionFlag string) {
   263→	props := analytics.Properties{
   264→		"provider":       provider,
   265→		"custom_command": custom,
   266→		"command_path":   commandPath,
   267→		"resolved_path":  resolvedPath,
   268→		"path_type":      pathType,
   269→		"version":        version,
   270→		"version_flag":   versionFlag,
   271→	}
   272→	analytics.TrackEvent(analytics.EventCheckInstallSuccess, props)
   273→}
   274→
   275→func trackCheckFailure(provider string, custom bool, commandPath string, resolvedPath string, pathType string, versionFlag string, stderrOutput string, errorType string, message string) {
   276→	props := analytics.Properties{
   277→		"provider":       provider,
   278→		"custom_command": custom,
   279→		"command_path":   commandPath,
   280→		"resolved_path":  resolvedPath,
   281→		"path_type":      pathType,
   282→		"version_flag":   versionFlag,
   283→		"error_type":     errorType,
   284→		"error_message":  message,
   285→	}
   286→	if stderrOutput != "" {
   287→		props["stderr"] = stderrOutput
   288→	}
   289→	analytics.TrackEvent(analytics.EventCheckInstallFailed, props)
   290→}
   291→
   292→func classifyDroidPath(command string, resolvedPath string) string {
   293→	if resolvedPath == "" {
   294→		if filepath.IsAbs(command) {
   295→			return "absolute_path"
   296→		}
   297→		return "unknown"
   298→	}
   299→	resolvedLower := strings.ToLower(resolvedPath)
   300→	if strings.Contains(resolvedLower, "homebrew") || strings.Contains(resolvedLower, "/opt/homebrew/") {
   301→		return "homebrew"
   302→	}
   303→	if strings.Contains(resolvedLower, "/.local/bin/") {
   304→		return "user_local"
   305→	}
   306→	if strings.Contains(resolvedLower, "/.factory/") {
   307→		return "factory_local"
   308→	}
   309→	if filepath.IsAbs(command) {
   310→		return "absolute_path"
   311→	}
   312→	return "system_path"
   313→}
   314→
   315→func printDetectionHelp() {
   316→	log.UserMessage("No Factory Droid sessions found under ~/.factory/sessions yet.\n")
   317→	log.UserMessage("Run the Factory CLI inside this project to create a JSONL session, then rerun `specstory sync droid`.\n")
   318→}
   319→
   320→func sessionMentionsProject(filePath string, projectPath string) bool {
   321→	projectPath = strings.TrimSpace(projectPath)
   322→	if projectPath == "" {
   323→		return false
   324→	}
   325→
   326→	canonicalProject := canonicalizePath(projectPath)
   327→	if sessionRoot := extractSessionWorkspaceRoot(filePath); sessionRoot != "" {
   328→		canonicalRoot := canonicalizePath(sessionRoot)
   329→		if canonicalProject != "" && canonicalRoot != "" {
   330→			return canonicalRoot == canonicalProject
   331→		}
   332→		return strings.TrimSpace(sessionRoot) == projectPath
   333→	}
   334→
   335→	return sessionMentionsProjectText(filePath, projectPath)
   336→}
   337→
   338→func extractSessionWorkspaceRoot(filePath string) string {
   339→	file, err := os.Open(filePath)
   340→	if err != nil {
   341→		return ""
   342→	}
   343→	defer func() {
   344→		_ = file.Close()
   345→	}()
   346→
   347→	var workspaceRoot string
   348→	scanErr := scanLines(file, func(line string) error {
   349→		trimmed := strings.TrimSpace(line)
   350→		if trimmed == "" {
   351→			return nil
   352→		}
   353→		var env jsonlEnvelope
   354→		if err := json.Unmarshal([]byte(trimmed), &env); err != nil {
   355→			return nil
   356→		}
   357→		if env.Type != "session_start" {
   358→			return nil
   359→		}
   360→		var event sessionStartEvent
   361→		if err := json.Unmarshal([]byte(trimmed), &event); err != nil {
   362→			return nil
   363→		}
   364→		workspaceRoot = firstNonEmpty(event.CWD, event.WorkspaceRoot, event.Session.CWD, event.Session.WorkspaceRoot)
   365→		return errStopScan
   366→	})
   367→	if scanErr != nil && !errors.Is(scanErr, errStopScan) {
   368→		return ""
   369→	}
   370→
   371→	return strings.TrimSpace(workspaceRoot)
   372→}
   373→
   374→func canonicalizePath(path string) string {
   375→	trimmed := strings.TrimSpace(path)
   376→	if trimmed == "" {
   377→		return ""
   378→	}
   379→	canonical, err := spi.GetCanonicalPath(trimmed)
   380→	if err == nil {
   381→		return canonical
   382→	}
   383→	if abs, absErr := filepath.Abs(trimmed); absErr == nil {
   384→		return filepath.Clean(abs)
   385→	}
   386→	return filepath.Clean(trimmed)
   387→}
   388→
   389→func sessionMentionsProjectText(filePath string, projectPath string) bool {
   390→	file, err := os.Open(filePath)
   391→	if err != nil {
   392→		return false
   393→	}
   394→	defer func() {
   395→		_ = file.Close()
   396→	}()
   397→	needle := strings.TrimSpace(projectPath)
   398→	short := filepath.Base(projectPath)
   399→	foundLines := 0
   400→	err = scanLines(file, func(line string) error {
   401→		if needle != "" && strings.Contains(line, needle) {
   402→			return errStopScan
   403→		}
   404→		if short != "" && strings.Contains(line, short) {
   405→			foundLines++
   406→			if foundLines > 2 {
   407→				return errStopScan
   408→			}
   409→		}
   410→		return nil
   411→	})
   412→
   413→	if err != nil && !errors.Is(err, errStopScan) {
   414→		slog.Warn("error scanning session file", "path", filePath, "err", err)
   415→		return false
   416→	}
   417→
   418→	return errors.Is(err, errStopScan)
   419→}
   420→
   421→func writeFactoryDebugRaw(session *fdSession) error {
   422→	if session == nil {
   423→		return nil
   424→	}
   425→	dir := spi.GetDebugDir(session.ID)
   426→	if err := os.MkdirAll(dir, 0o755); err != nil {
   427→		return fmt.Errorf("droidcli: unable to create debug dir: %w", err)
   428→	}
   429→	if err := os.WriteFile(filepath.Join(dir, "session.jsonl"), []byte(session.RawData), 0o644); err != nil {
   430→		return fmt.Errorf("droidcli: unable to write debug raw: %w", err)
   431→	}
   432→	meta := fmt.Sprintf("Session: %s\nTitle: %s\nCreated: %s\nBlocks: %d\n", session.ID, session.Title, session.CreatedAt, len(session.Blocks))
   433→	return os.WriteFile(filepath.Join(dir, "summary.txt"), []byte(meta), 0o644)
   434→}
   435→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:26Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/path_utils.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"fmt"
     5→	"io/fs"
     6→	"os"
     7→	"path/filepath"
     8→	"sort"
     9→)
    10→
    11→const (
    12→	factoryRootDir     = ".factory"
    13→	factorySessionsDir = "sessions"
    14→)
    15→
    16→type sessionFile struct {
    17→	Path     string
    18→	ModTime  int64
    19→	FileName string
    20→}
    21→
    22→func resolveSessionsDir() (string, error) {
    23→	home, err := os.UserHomeDir()
    24→	if err != nil {
    25→		return "", fmt.Errorf("droidcli: cannot resolve home dir: %w", err)
    26→	}
    27→	dir := filepath.Join(home, factoryRootDir, factorySessionsDir)
    28→	return dir, nil
    29→}
    30→
    31→func listSessionFiles() ([]sessionFile, error) {
    32→	dir, err := resolveSessionsDir()
    33→	if err != nil {
    34→		return nil, err
    35→	}
    36→	files := make([]sessionFile, 0, 64)
    37→	walker := func(path string, d fs.DirEntry, walkErr error) error {
    38→		if walkErr != nil {
    39→			return nil
    40→		}
    41→		if d.IsDir() {
    42→			return nil
    43→		}
    44→		if filepath.Ext(d.Name()) != ".jsonl" {
    45→			return nil
    46→		}
    47→		info, err := d.Info()
    48→		if err != nil {
    49→			return nil
    50→		}
    51→		files = append(files, sessionFile{
    52→			Path:     path,
    53→			ModTime:  info.ModTime().UnixNano(),
    54→			FileName: d.Name(),
    55→		})
    56→		return nil
    57→	}
    58→	if err := filepath.WalkDir(dir, walker); err != nil {
    59→		if os.IsNotExist(err) {
    60→			return []sessionFile{}, nil
    61→		}
    62→		return nil, fmt.Errorf("droidcli: unable to read sessions dir: %w", err)
    63→	}
    64→	sort.Slice(files, func(i, j int) bool {
    65→		return files[i].ModTime > files[j].ModTime
    66→	})
    67→	return files, nil
    68→}
    69→
    70→func findSessionFileByID(sessionID string) (string, error) {
    71→	files, err := listSessionFiles()
    72→	if err != nil {
    73→		return "", err
    74→	}
    75→	for _, file := range files {
    76→		candidate := file.FileName
    77→		if candidate == sessionID || trimExt(candidate) == sessionID {
    78→			return file.Path, nil
    79→		}
    80→	}
    81→	return "", nil
    82→}
    83→
    84→func trimExt(name string) string {
    85→	ext := filepath.Ext(name)
    86→	if ext == "" {
    87→		return name
    88→	}
    89→	return name[:len(name)-len(ext)]
    90→}
    91→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:30Z)**_

Now let me read the SPI provider interface and look at how Claude Code's provider integrates with its watcher.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:31Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/spi/provider.go`
```
     1→package spi
     2→
     3→import (
     4→	"context"
     5→
     6→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/schema"
     7→)
     8→
     9→// CheckResult contains the result of a provider check operation
    10→type CheckResult struct {
    11→	Success      bool   // Whether the check succeeded
    12→	Version      string // Version of the provider (empty on failure)
    13→	Location     string // File path/location of the provider executable
    14→	ErrorMessage string // Error message if check failed (empty on success)
    15→}
    16→
    17→// AgentChatSession represents a chat session from an AI coding agent
    18→type AgentChatSession struct {
    19→	SessionID   string              // Stable and unique identifier for the session (often a UUID)
    20→	CreatedAt   string              // Stable ISO 8601 timestamp when session was created
    21→	Slug        string              // Stable human-readable but file name safe slug, often derived from first user message
    22→	SessionData *schema.SessionData // Structured session data in unified format
    23→	RawData     string              // Raw session data (e.g., JSON blobs for Cursor CLI, JSONL for Claude Code and Codex CLI, etc.)
    24→}
    25→
    26→// Provider defines the interface that all agent coding tool providers must implement
    27→type Provider interface {
    28→	// Name returns the human-readable name of the provider (e.g., "Claude Code", "Cursor CLI", "Codex CLI")
    29→	Name() string
    30→
    31→	// Check verifies if the provider is properly installed and returns version info
    32→	// customCommand: empty string = use detected/default binary path, non-empty = use this specific command/path
    33→	Check(customCommand string) CheckResult
    34→
    35→	// DetectAgent checks if the provider's agent has been used in the given project path
    36→	// projectPath: Agent's working directory
    37→	// helpOutput: if true AND no activity is found, the provider should output helpful guidance
    38→	// Returns true if the agent has created artifacts/sessions in the specified path
    39→	DetectAgent(projectPath string, helpOutput bool) bool
    40→
    41→	// GetAgentChatSession retrieves a single chat session by ID for the given project path
    42→	// projectPath: Agent's working directory
    43→	// sessionID: specific session identifier to retrieve (always provided, never empty)
    44→	// debugRaw: if true, provider should write provider-specific raw debug files to .specstory/debug/<sessionID>/
    45→	//           (e.g., numbered JSON files). The unified session-data.json is written centrally by the CLI.
    46→	// Returns nil if the session is not found, error for actual errors
    47→	GetAgentChatSession(projectPath string, sessionID string, debugRaw bool) (*AgentChatSession, error)
    48→
    49→	// GetAgentChatSessions retrieves all chat sessions for the given project path
    50→	// projectPath: Agent's working directory
    51→	// debugRaw: if true, provider should write provider-specific raw debug files to .specstory/debug/<sessionID>/
    52→	//           (e.g., numbered JSON files). The unified session-data.json is written centrally by the CLI.
    53→	// Returns a slice of AgentChatSession structs containing session data
    54→	GetAgentChatSessions(projectPath string, debugRaw bool) ([]AgentChatSession, error)
    55→
    56→	// ExecAgentAndWatch executes the agent in interactive mode and watches for session updates
    57→	// Blocks until the agent exits, calling sessionCallback for each new/updated session
    58→	// projectPath: Agent's working directory
    59→	// customCommand: empty string = use detected/default binary with default args, non-empty = use this specific command/path
    60→	// resumeSessionID: empty string = start new session, non-empty = resume this specific session ID
    61→	// debugRaw: if true, provider should write provider-specific raw debug files to .specstory/debug/<sessionID>/
    62→	//           (e.g., numbered JSON files). The unified session-data.json is written centrally by the CLI.
    63→	// sessionCallback is called with each session update (provider should not block on callback)
    64→	// The implementation should handle its own file watching and session tracking
    65→	ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*AgentChatSession)) error
    66→
    67→	// WatchAgent watches for agent activity and calls the callback with an updated AgentChatSession
    68→	// Does NOT execute the agent - only watches for new activity
    69→	// Runs until error or context cancellation
    70→	// ctx: Context for cancellation and timeout control
    71→	// projectPath: Agent's working directory
    72→	// debugRaw: if true, provider should write provider-specific raw debug files to .specstory/debug/<sessionID>/
    73→	//           (e.g., numbered JSON files). The unified session-data.json is written centrally by the CLI.
    74→	// sessionCallback: called with AgentChatSession on each update (provider should not block on callback)
    75→	// The implementation should handle its own file watching and session tracking
    76→	WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*AgentChatSession)) error
    77→}
    78→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:32Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/claudecode/provider.go`
```
     1→package claudecode
     2→
     3→import (
     4→	"bytes"
     5→	"context"
     6→	"encoding/json"
     7→	"errors"
     8→	"fmt"
     9→	"log/slog"
    10→	"os"
    11→	"os/exec"
    12→	"path/filepath"
    13→	"strings"
    14→
    15→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    18→)
    19→
    20→// Provider implements the SPI Provider interface for Claude Code
    21→type Provider struct{}
    22→
    23→// NewProvider creates a new Claude Code provider instance
    24→func NewProvider() *Provider {
    25→	return &Provider{}
    26→}
    27→
    28→// filterWarmupMessages removes warmup messages (sidechain messages before first real message)
    29→func filterWarmupMessages(records []JSONLRecord) []JSONLRecord {
    30→	// Find first non-sidechain message
    31→	firstRealMessageIndex := -1
    32→	for i, record := range records {
    33→		if isSidechain, ok := record.Data["isSidechain"].(bool); !ok || !isSidechain {
    34→			firstRealMessageIndex = i
    35→			break
    36→		}
    37→	}
    38→
    39→	// No real messages found
    40→	if firstRealMessageIndex == -1 {
    41→		return []JSONLRecord{}
    42→	}
    43→
    44→	// Return records starting from first real message
    45→	return records[firstRealMessageIndex:]
    46→}
    47→
    48→// processSession filters warmup messages and converts a Session to an AgentChatSession
    49→// Returns nil if the session is warmup-only (no real messages)
    50→func processSession(session Session, workspaceRoot string, debugRaw bool) *spi.AgentChatSession {
    51→	// Write debug files first (even for warmup-only sessions)
    52→	if debugRaw {
    53→		// Write debug files and get the record-to-file mapping
    54→		_ = writeDebugRawFiles(session) // Unused but needed for side effect
    55→	}
    56→
    57→	// Filter warmup messages
    58→	filteredRecords := filterWarmupMessages(session.Records)
    59→
    60→	// Skip if no real messages remain after filtering warmup
    61→	if len(filteredRecords) == 0 {
    62→		slog.Debug("Skipping warmup-only session", "sessionId", session.SessionUuid)
    63→		return nil
    64→	}
    65→
    66→	// Create session with filtered records
    67→	filteredSession := Session{
    68→		SessionUuid: session.SessionUuid,
    69→		Records:     filteredRecords,
    70→	}
    71→
    72→	// Get timestamp from root record
    73→	rootRecord := filteredSession.Records[0]
    74→	timestamp := rootRecord.Data["timestamp"].(string)
    75→
    76→	// Get the slug
    77→	slug := FileSlugFromRootRecord(filteredSession)
    78→
    79→	// Generate SessionData from filtered session
    80→	sessionData, err := GenerateAgentSession(filteredSession, workspaceRoot)
    81→	if err != nil {
    82→		slog.Error("Failed to generate SessionData", "sessionId", session.SessionUuid, "error", err)
    83→		return nil
    84→	}
    85→
    86→	// Convert session records to JSONL format for raw data
    87→	// Note: Uses unfiltered session.Records (not filteredSession.Records) to preserve
    88→	// all records including warmup messages in the raw data for complete audit trail
    89→	var rawDataBuilder strings.Builder
    90→	for _, record := range session.Records {
    91→		jsonBytes, _ := json.Marshal(record.Data)
    92→		rawDataBuilder.Write(jsonBytes)
    93→		rawDataBuilder.WriteString("\n")
    94→	}
    95→
    96→	return &spi.AgentChatSession{
    97→		SessionID:   session.SessionUuid,
    98→		CreatedAt:   timestamp, // ISO 8601 timestamp
    99→		Slug:        slug,
   100→		SessionData: sessionData,
   101→		RawData:     rawDataBuilder.String(),
   102→	}
   103→}
   104→
   105→// Name returns the human-readable name of this provider
   106→func (p *Provider) Name() string {
   107→	return "Claude Code"
   108→}
   109→
   110→// buildCheckErrorMessage creates a user-facing error message tailored to the failure type.
   111→func buildCheckErrorMessage(errorType string, claudeCmd string, isCustom bool, stderrOutput string) string {
   112→	var errorMsg strings.Builder
   113→
   114→	switch errorType {
   115→	case "not_found":
   116→		errorMsg.WriteString(fmt.Sprintf("  🔍 Could not find Claude Code at: %s\n", claudeCmd))
   117→		errorMsg.WriteString("\n")
   118→		errorMsg.WriteString("  💡 Here's how to fix this:\n")
   119→		errorMsg.WriteString("\n")
   120→		if isCustom {
   121→			errorMsg.WriteString("     The specified path doesn't exist. Please check:\n")
   122→			errorMsg.WriteString(fmt.Sprintf("     • Is Claude Code installed at %s?\n", claudeCmd))
   123→			errorMsg.WriteString("     • Did you type the path correctly?")
   124→		} else {
   125→			errorMsg.WriteString("     1. Make sure Claude Code is installed:\n")
   126→			errorMsg.WriteString("        • Visit https://docs.claude.com/en/docs/claude-code/quickstart\n")
   127→			errorMsg.WriteString("\n")
   128→			errorMsg.WriteString("     2. If it's already installed, try:\n")
   129→			errorMsg.WriteString("        • Check if 'claude' is in your PATH\n")
   130→			errorMsg.WriteString("        • Use -c flag to specify the full path\n")
   131→			errorMsg.WriteString("        • Example: specstory check claude -c \"~/.claude/local/claude\"")
   132→		}
   133→	case "permission_denied":
   134→		errorMsg.WriteString(fmt.Sprintf("  🔒 Permission denied when trying to run: %s\n", claudeCmd))
   135→		errorMsg.WriteString("\n")
   136→		errorMsg.WriteString("  💡 Here's how to fix this:\n")
   137→		errorMsg.WriteString(fmt.Sprintf("     • Check file permissions: chmod +x %s\n", claudeCmd))
   138→		errorMsg.WriteString("     • Try running with elevated permissions if needed")
   139→	case "unexpected_output":
   140→		errorMsg.WriteString(fmt.Sprintf("  ⚠️  Unexpected output from 'claude -v': %s\n", strings.TrimSpace(stderrOutput)))
   141→		errorMsg.WriteString("\n")
   142→		errorMsg.WriteString("  💡 This might not be Claude Code. Expected output containing '(Claude Code)'.\n")
   143→		errorMsg.WriteString("     • Make sure you have Claude Code installed, not a different 'claude' command\n")
   144→		errorMsg.WriteString("     • Visit https://docs.anthropic.com/en/docs/claude-code/quickstart for installation")
   145→	default:
   146→		errorMsg.WriteString("  ⚠️  Error running 'claude -v'\n")
   147→		if stderrOutput != "" {
   148→			errorMsg.WriteString(fmt.Sprintf("  📋 Error details: %s\n", stderrOutput))
   149→		}
   150→		errorMsg.WriteString("\n")
   151→		errorMsg.WriteString("  💡 Troubleshooting tips:\n")
   152→		errorMsg.WriteString("     • Make sure Claude Code is properly installed\n")
   153→		errorMsg.WriteString("     • Try running 'claude -v' directly in your terminal\n")
   154→		errorMsg.WriteString("     • Check https://docs.claude.com/en/docs/claude-code/quickstart for installation help")
   155→	}
   156→
   157→	return errorMsg.String()
   158→}
   159→
   160→// Check verifies Claude Code installation and returns version info
   161→func (p *Provider) Check(customCommand string) spi.CheckResult {
   162→	// Parse the command (no resume session for version check)
   163→	claudeCmd, _ := parseClaudeCommand(customCommand, "")
   164→
   165→	// Determine if custom command was used
   166→	isCustomCommand := customCommand != ""
   167→
   168→	// Resolve the actual path of the command
   169→	resolvedPath := claudeCmd
   170→	if !filepath.IsAbs(claudeCmd) {
   171→		// Try to find the command in PATH
   172→		if path, err := exec.LookPath(claudeCmd); err == nil {
   173→			resolvedPath = path
   174→		}
   175→	}
   176→
   177→	// Run claude -v to check version (ignore custom args for version check)
   178→	cmd := exec.Command(claudeCmd, "-v")
   179→	var out bytes.Buffer
   180→	var errOut bytes.Buffer
   181→	cmd.Stdout = &out
   182→	cmd.Stderr = &errOut
   183→
   184→	if err := cmd.Run(); err != nil {
   185→		// Track installation check failure
   186→		errorType := "unknown"
   187→
   188→		var execErr *exec.Error
   189→		var pathErr *os.PathError
   190→
   191→		// Check error types in order of specificity
   192→		switch {
   193→		case errors.As(err, &execErr) && execErr.Err == exec.ErrNotFound:
   194→			errorType = "not_found"
   195→		case errors.As(err, &pathErr):
   196→			if errors.Is(pathErr.Err, os.ErrNotExist) {
   197→				errorType = "not_found"
   198→			} else if errors.Is(pathErr.Err, os.ErrPermission) {
   199→				errorType = "permission_denied"
   200→			}
   201→		case errors.Is(err, os.ErrPermission):
   202→			errorType = "permission_denied"
   203→		}
   204→
   205→		stderrOutput := strings.TrimSpace(errOut.String())
   206→		analytics.TrackEvent(analytics.EventCheckInstallFailed, analytics.Properties{
   207→			"provider":       "claude",
   208→			"custom_command": isCustomCommand,
   209→			"command_path":   claudeCmd,
   210→			"error_type":     errorType,
   211→			"error_message":  err.Error(),
   212→		})
   213→
   214→		errorMessage := buildCheckErrorMessage(errorType, claudeCmd, isCustomCommand, stderrOutput)
   215→
   216→		return spi.CheckResult{
   217→			Success:      false,
   218→			Version:      "",
   219→			Location:     resolvedPath,
   220→			ErrorMessage: errorMessage,
   221→		}
   222→	}
   223→
   224→	// Check if output contains "Claude Code"
   225→	output := out.String()
   226→	if !strings.Contains(output, "(Claude Code)") {
   227→		// Track unexpected output error
   228→		analytics.TrackEvent(analytics.EventCheckInstallFailed, analytics.Properties{
   229→			"provider":       "claude",
   230→			"custom_command": isCustomCommand,
   231→			"command_path":   claudeCmd,
   232→			"error_type":     "unexpected_output",
   233→			"output":         strings.TrimSpace(output),
   234→		})
   235→
   236→		errorMessage := buildCheckErrorMessage("unexpected_output", claudeCmd, isCustomCommand, output)
   237→
   238→		return spi.CheckResult{
   239→			Success:      false,
   240→			Version:      "",
   241→			Location:     resolvedPath,
   242→			ErrorMessage: errorMessage,
   243→		}
   244→	}
   245→
   246→	// Success! Track it
   247→	pathType := getPathType(claudeCmd, resolvedPath)
   248→	analytics.TrackEvent(analytics.EventCheckInstallSuccess, analytics.Properties{
   249→		"provider":       "claude",
   250→		"custom_command": isCustomCommand,
   251→		"command_path":   resolvedPath,
   252→		"path_type":      pathType,
   253→		"version":        strings.TrimSpace(output),
   254→	})
   255→
   256→	return spi.CheckResult{
   257→		Success:      true,
   258→		Version:      strings.TrimSpace(output),
   259→		Location:     resolvedPath,
   260→		ErrorMessage: "",
   261→	}
   262→}
   263→
   264→// DetectAgent checks if Claude Code has been used in the given project directory
   265→func (p *Provider) DetectAgent(projectPath string, helpOutput bool) bool {
   266→	// Get the Claude Code project directory for the given path
   267→	claudeProjectPath, err := GetClaudeCodeProjectDir(projectPath)
   268→	if err != nil {
   269→		slog.Debug("DetectAgent: Failed to get Claude Code project directory", "error", err)
   270→		return false
   271→	}
   272→
   273→	// Check if the Claude Code project directory exists
   274→	if info, err := os.Stat(claudeProjectPath); err == nil && info.IsDir() {
   275→		slog.Debug("DetectAgent: Claude Code project found", "path", claudeProjectPath)
   276→		return true
   277→	}
   278→
   279→	slog.Debug("DetectAgent: No Claude Code project found", "expected_path", claudeProjectPath)
   280→
   281→	// If helpOutput is requested, provide helpful guidance
   282→	if helpOutput {
   283→		fmt.Println() // Add visual separation
   284→		log.UserWarn("No Claude Code project found for this directory.\n")
   285→		log.UserMessage("Claude Code hasn't created a project folder for your current directory yet.\n")
   286→		log.UserMessage("This happens when Claude Code hasn't been run in this directory.\n\n")
   287→		log.UserMessage("To fix this:\n")
   288→		log.UserMessage("  1. Run 'specstory run' to start Claude Code in this directory\n")
   289→		log.UserMessage("  2. Or run Claude Code directly with `claude`, then try syncing again\n\n")
   290→		log.UserMessage("Expected project folder: %s\n", claudeProjectPath)
   291→		fmt.Println() // Add trailing newline
   292→	}
   293→
   294→	return false
   295→}
   296→
   297→// GetAgentChatSessions retrieves all chat sessions for the given project path
   298→func (p *Provider) GetAgentChatSessions(projectPath string, debugRaw bool) ([]spi.AgentChatSession, error) {
   299→	// Get the Claude Code project directory
   300→	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
   301→	if err != nil {
   302→		return nil, err
   303→	}
   304→
   305→	// Check if project directory exists
   306→	if _, err := os.Stat(claudeProjectDir); os.IsNotExist(err) {
   307→		return []spi.AgentChatSession{}, nil // No sessions if no project
   308→	}
   309→
   310→	// Parse JSONL files
   311→	parser := NewJSONLParser()
   312→	err = parser.ParseProjectSessions(claudeProjectDir, true) // silent = true
   313→	if err != nil {
   314→		return nil, err
   315→	}
   316→
   317→	// Convert sessions to AgentChatSession structs
   318→	result := make([]spi.AgentChatSession, 0, len(parser.Sessions))
   319→	for _, session := range parser.Sessions {
   320→		// Skip empty sessions (no records)
   321→		if len(session.Records) == 0 {
   322→			continue
   323→		}
   324→
   325→		// Process session (filter warmup, generate SessionData)
   326→		chatSession := processSession(session, projectPath, debugRaw)
   327→		if chatSession != nil {
   328→			result = append(result, *chatSession)
   329→		}
   330→	}
   331→
   332→	return result, nil
   333→}
   334→
   335→// GetAgentChatSession retrieves a single chat session by ID for the given project path
   336→func (p *Provider) GetAgentChatSession(projectPath string, sessionID string, debugRaw bool) (*spi.AgentChatSession, error) {
   337→	// Get the Claude Code project directory
   338→	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
   339→	if err != nil {
   340→		return nil, err
   341→	}
   342→
   343→	// Check if project directory exists
   344→	if _, err := os.Stat(claudeProjectDir); os.IsNotExist(err) {
   345→		return nil, nil // No sessions if no project
   346→	}
   347→
   348→	// Parse only the session we're looking for
   349→	parser := NewJSONLParser()
   350→	err = parser.ParseSingleSession(claudeProjectDir, sessionID)
   351→	if err != nil {
   352→		// If session not found, return nil (not an error)
   353→		if strings.Contains(err.Error(), "not found") {
   354→			return nil, nil
   355→		}
   356→		return nil, err
   357→	}
   358→
   359→	// Find the session
   360→	sessionPointer := parser.FindSession(sessionID)
   361→	if sessionPointer == nil {
   362→		return nil, nil
   363→	}
   364→	session := *sessionPointer
   365→
   366→	// Skip empty sessions (no records)
   367→	if len(session.Records) == 0 {
   368→		return nil, nil
   369→	}
   370→
   371→	// Process session (filter warmup, generate SessionData)
   372→	return processSession(session, projectPath, debugRaw), nil
   373→}
   374→
   375→// ExecAgentAndWatch executes Claude Code in interactive mode and watches for session updates
   376→func (p *Provider) ExecAgentAndWatch(projectPath string, customCommand string, resumeSessionID string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   377→	slog.Info("ExecAgentAndWatch: Starting Claude Code execution and monitoring",
   378→		"projectPath", projectPath,
   379→		"customCommand", customCommand,
   380→		"resumeSessionID", resumeSessionID,
   381→		"debugRaw", debugRaw)
   382→
   383→	// Validate resume session ID if provided (Claude Code uses UUID format)
   384→	if resumeSessionID != "" {
   385→		resumeSessionID = strings.TrimSpace(resumeSessionID)
   386→		// Simple UUID validation for Claude Code sessions
   387→		if len(resumeSessionID) != 36 || !strings.Contains(resumeSessionID, "-") {
   388→			return fmt.Errorf("invalid session ID format for Claude Code: %s (must be a UUID)", resumeSessionID)
   389→		}
   390→		slog.Info("Resuming Claude Code session", "sessionId", resumeSessionID)
   391→	}
   392→
   393→	// Set up the callback which enables real-time markdown generation and cloud sync during
   394→	// interactive sessions. As Claude Code writes JSONL updates, the watcher detects
   395→	// changes and invokes this callback, allowing immediate processing without blocking
   396→	// the agent's execution. The defer ensures cleanup when the agent exits.
   397→	SetWatcherCallback(sessionCallback)
   398→	defer ClearWatcherCallback()
   399→
   400→	// Set debug raw mode for the watcher
   401→	SetWatcherDebugRaw(debugRaw)
   402→
   403→	// Start watching for project directory in the background
   404→	slog.Info("Initializing project directory monitoring...")
   405→
   406→	if err := WatchForProjectDir(); err != nil {
   407→		// Log the error but don't fail - watcher might work later
   408→		slog.Error("Failed to start project directory watcher", "error", err)
   409→	}
   410→
   411→	// Execute Claude Code - this blocks until Claude exits
   412→	slog.Info("Executing Claude Code", "command", customCommand)
   413→	err := ExecuteClaude(customCommand, resumeSessionID)
   414→
   415→	// Stop the watcher goroutine before returning
   416→	slog.Info("Claude Code has exited, stopping watcher")
   417→	StopWatcher()
   418→
   419→	// Return any execution error
   420→	if err != nil {
   421→		return fmt.Errorf("claude Code execution failed: %w", err)
   422→	}
   423→
   424→	return nil
   425→}
   426→
   427→// WatchAgent watches for Claude Code agent activity and calls the callback with AgentChatSession
   428→// Does NOT execute the agent - only watches for existing activity
   429→// Runs until error or context cancellation
   430→func (p *Provider) WatchAgent(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
   431→	slog.Info("WatchAgent: Starting Claude Code activity monitoring",
   432→		"projectPath", projectPath,
   433→		"debugRaw", debugRaw)
   434→
   435→	// The watcher callback directly passes AgentChatSession (which now contains SessionData)
   436→	wrappedCallback := func(agentChatSession *spi.AgentChatSession) {
   437→		slog.Debug("WatchAgent: Received AgentChatSession",
   438→			"sessionID", agentChatSession.SessionID,
   439→			"hasSessionData", agentChatSession.SessionData != nil)
   440→
   441→		// Call the user's callback with the AgentChatSession
   442→		sessionCallback(agentChatSession)
   443→	}
   444→
   445→	// Set up the callback for the watcher
   446→	SetWatcherCallback(wrappedCallback)
   447→	defer ClearWatcherCallback()
   448→
   449→	// Set debug raw mode for the watcher
   450→	SetWatcherDebugRaw(debugRaw)
   451→
   452→	// Get the Claude Code project directory for the specified project path
   453→	slog.Info("WatchAgent: Initializing project directory monitoring...")
   454→
   455→	claudeProjectDir, err := GetClaudeCodeProjectDir(projectPath)
   456→	if err != nil {
   457→		slog.Error("WatchAgent: Failed to get Claude Code project directory", "error", err)
   458→		return fmt.Errorf("failed to get project directory: %w", err)
   459→	}
   460→
   461→	slog.Info("WatchAgent: Project directory found", "directory", claudeProjectDir)
   462→
   463→	if err := startProjectWatcher(claudeProjectDir); err != nil {
   464→		slog.Error("WatchAgent: Failed to start project watcher", "error", err)
   465→		return fmt.Errorf("failed to start watcher: %w", err)
   466→	}
   467→
   468→	// Block until context is cancelled
   469→	// The watcher runs in a background goroutine and will continue
   470→	// until context is cancelled or the process exits
   471→	slog.Info("WatchAgent: Watcher started, blocking until context cancelled")
   472→
   473→	// Wait for context cancellation
   474→	<-ctx.Done()
   475→
   476→	slog.Info("WatchAgent: Context cancelled, stopping watcher")
   477→	StopWatcher()
   478→
   479→	return ctx.Err()
   480→}
   481→
   482→// findFirstUserMessage finds the first user message in a session for slug generation
   483→// Returns empty string if no suitable user message is found
   484→func findFirstUserMessage(session Session) string {
   485→	for _, record := range session.Records {
   486→		// Check if this is a user message
   487→		if recordType, ok := record.Data["type"].(string); !ok || recordType != "user" {
   488→			continue
   489→		}
   490→
   491→		// Skip meta user messages
   492→		if isMeta, ok := record.Data["isMeta"].(bool); ok && isMeta {
   493→			continue
   494→		}
   495→
   496→		// Extract content from message
   497→		if message, ok := record.Data["message"].(map[string]interface{}); ok {
   498→			if content, ok := message["content"].(string); ok && content != "" {
   499→				// Skip messages containing "warmup" (case-insensitive)
   500→				if strings.Contains(strings.ToLower(content), "warmup") {
   501→					continue
   502→				}
   503→				return content
   504→			}
   505→		}
   506→	}
   507→	return ""
   508→}
   509→
   510→// FileSlugFromRootRecord generates the slug part of the filename from the session
   511→// Returns the human-readable slug derived from the first user message, or empty string if none
   512→func FileSlugFromRootRecord(session Session) string {
   513→	// Find the first user message and generate slug from it
   514→	firstUserMessage := findFirstUserMessage(session)
   515→	slog.Debug("FileSlugFromRootRecord: First user message",
   516→		"sessionId", session.SessionUuid,
   517→		"message", firstUserMessage)
   518→
   519→	slug := spi.GenerateFilenameFromUserMessage(firstUserMessage)
   520→	slog.Debug("FileSlugFromRootRecord: Generated slug",
   521→		"sessionId", session.SessionUuid,
   522→		"slug", slug)
   523→
   524→	return slug
   525→}
   526→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:37Z)**_

Now let me check if there are any tests for the Droid watcher and examine how fsnotify handles recursive watching.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:39Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/parser.go`
```
     1→package droidcli
     2→
     3→import (
     4→	"bufio"
     5→	"encoding/json"
     6→	"errors"
     7→	"fmt"
     8→	"io"
     9→	"log/slog"
    10→	"os"
    11→	"path/filepath"
    12→	"regexp"
    13→	"strings"
    14→
    15→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    16→)
    17→
    18→type jsonlEnvelope struct {
    19→	Type string `json:"type"`
    20→}
    21→
    22→type sessionStartEvent struct {
    23→	Type          string `json:"type"`
    24→	Timestamp     string `json:"timestamp"`
    25→	ID            string `json:"id"`
    26→	Title         string `json:"title"`
    27→	SessionTitle  string `json:"sessionTitle"`
    28→	CreatedAt     string `json:"created_at"`
    29→	CWD           string `json:"cwd"`
    30→	WorkspaceRoot string `json:"workspace_root"`
    31→	Session       struct {
    32→		ID            string `json:"id"`
    33→		Title         string `json:"title"`
    34→		CreatedAt     string `json:"created_at"`
    35→		CWD           string `json:"cwd"`
    36→		WorkspaceRoot string `json:"workspace_root"`
    37→	} `json:"session"`
    38→}
    39→
    40→type messageEvent struct {
    41→	Type      string          `json:"type"`
    42→	ID        string          `json:"id"`
    43→	Timestamp string          `json:"timestamp"`
    44→	Message   messagePayload  `json:"message"`
    45→	Metadata  json.RawMessage `json:"metadata"`
    46→}
    47→
    48→type messagePayload struct {
    49→	Role    string           `json:"role"`
    50→	Model   string           `json:"model"`
    51→	Content []contentPayload `json:"content"`
    52→}
    53→
    54→type contentPayload struct {
    55→	Type            string          `json:"type"`
    56→	Text            string          `json:"text"`
    57→	ID              string          `json:"id"`
    58→	Name            string          `json:"name"`
    59→	Input           json.RawMessage `json:"input"`
    60→	ToolUseID       string          `json:"tool_use_id"`
    61→	Content         json.RawMessage `json:"content"`
    62→	IsError         bool            `json:"is_error"`
    63→	RiskLevel       string          `json:"riskLevel"`
    64→	RiskLevelReason string          `json:"riskLevelReason"`
    65→}
    66→
    67→type todoEvent struct {
    68→	Type      string       `json:"type"`
    69→	Timestamp string       `json:"timestamp"`
    70→	Todos     []fdTodoItem `json:"todos"`
    71→}
    72→
    73→type compactionEvent struct {
    74→	Type      string    `json:"type"`
    75→	Timestamp string    `json:"timestamp"`
    76→	Summary   fdSummary `json:"summary"`
    77→}
    78→
    79→// parseFactorySession converts a Factory Droid JSONL transcript into an fdSession.
    80→func parseFactorySession(filePath string) (*fdSession, error) {
    81→	file, err := os.Open(filePath)
    82→	if err != nil {
    83→		return nil, fmt.Errorf("droidcli: unable to open session %s: %w", filePath, err)
    84→	}
    85→	defer func() {
    86→		_ = file.Close()
    87→	}()
    88→
    89→	session := &fdSession{Blocks: make([]fdBlock, 0, 64)}
    90→	toolIndex := make(map[string]*fdToolCall)
    91→	var rawBuilder strings.Builder
    92→	var firstUserText string
    93→	var firstTimestamp string
    94→
    95→	scanErr := scanLines(file, func(line string) error {
    96→		rawBuilder.WriteString(line)
    97→		rawBuilder.WriteByte('\n')
    98→
    99→		trimmed := strings.TrimSpace(line)
   100→		if trimmed == "" {
   101→			return nil
   102→		}
   103→
   104→		var env jsonlEnvelope
   105→		if err := json.Unmarshal([]byte(trimmed), &env); err != nil {
   106→			slog.Debug("droidcli: skipping malformed JSONL line", "error", err, "file", filePath)
   107→			return nil
   108→		}
   109→
   110→		switch env.Type {
   111→		case "session_start":
   112→			var event sessionStartEvent
   113→			if err := json.Unmarshal([]byte(trimmed), &event); err != nil {
   114→				slog.Debug("droidcli: skipping malformed session_start event", "error", err, "file", filePath)
   115→				return nil
   116→			}
   117→			session.ID = fallback(session.ID, firstNonEmpty(event.ID, event.Session.ID))
   118→			session.Title = fallback(session.Title, firstNonEmpty(event.Title, event.Session.Title, event.SessionTitle))
   119→			session.CreatedAt = fallback(session.CreatedAt, firstNonEmpty(event.CreatedAt, event.Session.CreatedAt, event.Timestamp))
   120→			session.WorkspaceRoot = fallback(session.WorkspaceRoot, firstNonEmpty(event.CWD, event.WorkspaceRoot, event.Session.CWD, event.Session.WorkspaceRoot))
   121→		case "message":
   122→			var event messageEvent
   123→			if err := json.Unmarshal([]byte(trimmed), &event); err != nil {
   124→				slog.Debug("droidcli: skipping malformed message event", "error", err, "file", filePath)
   125→				return nil
   126→			}
   127→			if firstTimestamp == "" {
   128→				firstTimestamp = normalizeEventTimestamp(event.Timestamp)
   129→			}
   130→			handleMessageEvent(session, &event, toolIndex)
   131→			if strings.EqualFold(event.Message.Role, "user") {
   132→				if firstUserText == "" {
   133→					firstUserText = firstUserContent(event.Message.Content)
   134→				}
   135→			}
   136→		case "todo_state":
   137→			var event todoEvent
   138→			if err := json.Unmarshal([]byte(trimmed), &event); err != nil {
   139→				slog.Debug("droidcli: skipping malformed todo_state event", "error", err, "file", filePath)
   140→				return nil
   141→			}
   142→			if firstTimestamp == "" {
   143→				firstTimestamp = normalizeEventTimestamp(event.Timestamp)
   144→			}
   145→			if len(event.Todos) == 0 {
   146→				return nil
   147→			}
   148→			session.Blocks = append(session.Blocks, fdBlock{
   149→				Kind:      blockTodo,
   150→				Role:      "agent",
   151→				Timestamp: event.Timestamp,
   152→				Todo: &fdTodoState{
   153→					Items: append([]fdTodoItem(nil), event.Todos...),
   154→				},
   155→			})
   156→		case "compaction_state":
   157→			var event compactionEvent
   158→			if err := json.Unmarshal([]byte(trimmed), &event); err != nil {
   159→				slog.Debug("droidcli: skipping malformed compaction_state event", "error", err, "file", filePath)
   160→				return nil
   161→			}
   162→			if firstTimestamp == "" {
   163→				firstTimestamp = normalizeEventTimestamp(event.Timestamp)
   164→			}
   165→			if strings.TrimSpace(event.Summary.Body) == "" {
   166→				return nil
   167→			}
   168→			session.Blocks = append(session.Blocks, fdBlock{
   169→				Kind:      blockSummary,
   170→				Role:      "agent",
   171→				Timestamp: event.Timestamp,
   172→				Summary:   &event.Summary,
   173→			})
   174→		}
   175→
   176→		return nil
   177→	})
   178→	if scanErr != nil {
   179→		return nil, fmt.Errorf("droidcli: failed scanning %s: %w", filePath, scanErr)
   180→	}
   181→
   182→	if session.ID == "" {
   183→		session.ID = strings.TrimSuffix(filepath.Base(filePath), filepath.Ext(filePath))
   184→	}
   185→
   186→	if session.CreatedAt == "" {
   187→		session.CreatedAt = fallback(firstTimestamp, deriveTimestampFromFilename(filePath))
   188→	}
   189→
   190→	session.Slug = slugFromContent(firstUserText, session.Title, session.CreatedAt)
   191→	session.RawData = rawBuilder.String()
   192→
   193→	return session, nil
   194→}
   195→
   196→func handleMessageEvent(session *fdSession, event *messageEvent, toolIndex map[string]*fdToolCall) {
   197→	role := strings.ToLower(strings.TrimSpace(event.Message.Role))
   198→	if role == "" {
   199→		role = "agent"
   200→	}
   201→	model := strings.TrimSpace(event.Message.Model)
   202→
   203→	for _, block := range event.Message.Content {
   204→		switch block.Type {
   205→		case "text":
   206→			appendTextBlock(session, role, model, event.Timestamp, block.Text, false, event.ID)
   207→		case "reasoning", "thinking", "thought":
   208→			appendTextBlock(session, role, model, event.Timestamp, block.Text, true, event.ID)
   209→		case "tool_use":
   210→			tool := &fdToolCall{
   211→				ID:           block.ID,
   212→				Name:         block.Name,
   213→				Input:        block.Input,
   214→				RiskLevel:    block.RiskLevel,
   215→				RiskReason:   block.RiskLevelReason,
   216→				InvocationAt: event.Timestamp,
   217→			}
   218→			session.Blocks = append(session.Blocks, fdBlock{
   219→				Kind:      blockTool,
   220→				Role:      role,
   221→				MessageID: strings.TrimSpace(event.ID),
   222→				Timestamp: event.Timestamp,
   223→				Model:     model,
   224→				Tool:      tool,
   225→			})
   226→			if tool.ID != "" {
   227→				toolIndex[tool.ID] = tool
   228→			}
   229→		case "tool_result":
   230→			result := &fdToolResult{
   231→				Content: decodeContent(block.Content),
   232→				IsError: block.IsError,
   233→			}
   234→			if ref := toolIndex[block.ToolUseID]; ref != nil {
   235→				ref.Result = result
   236→			} else {
   237→				session.Blocks = append(session.Blocks, fdBlock{
   238→					Kind:      blockTool,
   239→					Role:      role,
   240→					MessageID: strings.TrimSpace(event.ID),
   241→					Timestamp: event.Timestamp,
   242→					Model:     model,
   243→					Tool: &fdToolCall{
   244→						ID:           block.ToolUseID,
   245→						Name:         "tool_result",
   246→						Result:       result,
   247→						InvocationAt: event.Timestamp,
   248→					},
   249→				})
   250→			}
   251→		}
   252→	}
   253→}
   254→
   255→func appendTextBlock(session *fdSession, role, model, timestamp, rawText string, reasoning bool, messageID string) {
   256→	text := strings.TrimSpace(rawText)
   257→	if text == "" {
   258→		return
   259→	}
   260→	session.Blocks = append(session.Blocks, fdBlock{
   261→		Kind:        blockText,
   262→		Role:        role,
   263→		MessageID:   strings.TrimSpace(messageID),
   264→		Timestamp:   timestamp,
   265→		Model:       model,
   266→		Text:        text,
   267→		IsReasoning: reasoning,
   268→	})
   269→}
   270→
   271→func firstUserContent(blocks []contentPayload) string {
   272→	for _, block := range blocks {
   273→		if block.Type != "text" {
   274→			continue
   275→		}
   276→		text := strings.TrimSpace(block.Text)
   277→		text = cleanUserText(text)
   278→		if text != "" {
   279→			return text
   280→		}
   281→	}
   282→	return ""
   283→}
   284→
   285→func decodeContent(raw json.RawMessage) string {
   286→	if len(raw) == 0 || string(raw) == "null" {
   287→		return ""
   288→	}
   289→	var str string
   290→	if err := json.Unmarshal(raw, &str); err == nil {
   291→		return str
   292→	}
   293→	var arr []map[string]any
   294→	if err := json.Unmarshal(raw, &arr); err == nil {
   295→		var builder strings.Builder
   296→		for _, item := range arr {
   297→			if text, ok := item["text"].(string); ok && strings.TrimSpace(text) != "" {
   298→				if builder.Len() > 0 {
   299→					builder.WriteString("\n")
   300→				}
   301→				builder.WriteString(text)
   302→			}
   303→		}
   304→		return builder.String()
   305→	}
   306→	var obj map[string]any
   307→	if err := json.Unmarshal(raw, &obj); err == nil {
   308→		if text, ok := obj["text"].(string); ok {
   309→			return text
   310→		}
   311→		bytes, err := json.Marshal(obj)
   312→		if err == nil {
   313→			return string(bytes)
   314→		}
   315→	}
   316→	return string(raw)
   317→}
   318→
   319→func slugFromContent(text string, title string, created string) string {
   320→	if slug := spi.GenerateFilenameFromUserMessage(text); slug != "" {
   321→		return slug
   322→	}
   323→	if slug := spi.GenerateFilenameFromUserMessage(title); slug != "" {
   324→		return slug
   325→	}
   326→	if created != "" {
   327→		return strings.ToLower(strings.ReplaceAll(created, ":", "-"))
   328→	}
   329→	return "factory-session"
   330→}
   331→
   332→func deriveTimestampFromFilename(path string) string {
   333→	base := strings.TrimSuffix(filepath.Base(path), filepath.Ext(path))
   334→	return base
   335→}
   336→
   337→func fallback(current, candidate string) string {
   338→	if strings.TrimSpace(current) != "" {
   339→		return current
   340→	}
   341→	return strings.TrimSpace(candidate)
   342→}
   343→
   344→func firstNonEmpty(values ...string) string {
   345→	for _, value := range values {
   346→		if strings.TrimSpace(value) != "" {
   347→			return strings.TrimSpace(value)
   348→		}
   349→	}
   350→	return ""
   351→}
   352→
   353→func normalizeEventTimestamp(ts string) string {
   354→	return strings.TrimSpace(ts)
   355→}
   356→
   357→// Scanner utilities for reading JSONL files
   358→
   359→const (
   360→	kb                    = 1024
   361→	mb                    = 1024 * kb
   362→	maxReasonableLineSize = 250 * mb
   363→)
   364→
   365→var errStopScan = errors.New("stop scan")
   366→
   367→func scanLines(reader io.Reader, handle func(line string) error) error {
   368→	buf := bufio.NewReader(reader)
   369→	lineNumber := 0
   370→
   371→	for {
   372→		line, err := buf.ReadString('\n')
   373→		if err != nil && !errors.Is(err, io.EOF) {
   374→			return err
   375→		}
   376→
   377→		if err == io.EOF && line == "" {
   378→			break
   379→		}
   380→
   381→		lineNumber++
   382→		if len(line) > maxReasonableLineSize {
   383→			return fmt.Errorf("line %d exceeds reasonable size limit (%d MB)", lineNumber, maxReasonableLineSize/mb)
   384→		}
   385→
   386→		line = strings.TrimRight(line, "\n")
   387→		line = strings.TrimRight(line, "\r")
   388→		if line == "" {
   389→			if err == io.EOF {
   390→				break
   391→			}
   392→			continue
   393→		}
   394→
   395→		if handleErr := handle(line); handleErr != nil {
   396→			return handleErr
   397→		}
   398→
   399→		if err == io.EOF {
   400→			break
   401→		}
   402→	}
   403→
   404→	return nil
   405→}
   406→
   407→// Text cleaning utilities
   408→
   409→var systemReminderPattern = regexp.MustCompile(`(?s)`)
   410→
   411→func cleanUserText(text string) string {
   412→	clean := systemReminderPattern.ReplaceAllString(text, "")
   413→	return strings.TrimSpace(clean)
   414→}
   415→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:00:40Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Check if fsnotify is already a dependency

`go mod graph | grep fsnotify`
```
github.com/specstoryai/getspecstory/specstory-cli github.com/fsnotify/fsnotify@v1.9.0
github.com/fsnotify/fsnotify@v1.9.0 golang.org/x/sys@v0.13.0
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:01:40Z)**_

Let me also check the types file and explore how subdirectories might be structured in the Factory sessions directory.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:01:41Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/providers/droidcli/types.go`
```
     1→package droidcli
     2→
     3→import "encoding/json"
     4→
     5→// fdBlockKind describes the semantic type of a parsed session chunk.
     6→type fdBlockKind int
     7→
     8→const (
     9→	blockText fdBlockKind = iota
    10→	blockTool
    11→	blockTodo
    12→	blockSummary
    13→)
    14→
    15→// fdBlock represents a normalized slice of the Factory Droid transcript.
    16→type fdBlock struct {
    17→	Kind        fdBlockKind
    18→	Role        string
    19→	MessageID   string
    20→	Timestamp   string
    21→	Model       string
    22→	Text        string
    23→	IsReasoning bool
    24→	Tool        *fdToolCall
    25→	Todo        *fdTodoState
    26→	Summary     *fdSummary
    27→}
    28→
    29→// fdToolCall captures a tool invocation plus its result.
    30→type fdToolCall struct {
    31→	ID           string
    32→	Name         string
    33→	Input        json.RawMessage
    34→	RiskLevel    string
    35→	RiskReason   string
    36→	Result       *fdToolResult
    37→	InvocationAt string
    38→}
    39→
    40→// fdToolResult contains the textual output of a tool.
    41→type fdToolResult struct {
    42→	Content string
    43→	IsError bool
    44→}
    45→
    46→// fdTodoState tracks todo list snapshots emitted by the agent.
    47→type fdTodoState struct {
    48→	Items []fdTodoItem
    49→}
    50→
    51→// fdTodoItem represents a single todo entry.
    52→type fdTodoItem struct {
    53→	Description string
    54→	Status      string
    55→}
    56→
    57→// fdSummary stores compaction summary text from Factory Droid.
    58→type fdSummary struct {
    59→	Title string
    60→	Body  string
    61→}
    62→
    63→// fdSession aggregates parsed metadata and blocks.
    64→type fdSession struct {
    65→	ID            string
    66→	Title         string
    67→	CreatedAt     string
    68→	WorkspaceRoot string
    69→	Blocks        []fdBlock
    70→	Slug          string
    71→	RawData       string
    72→}
    73→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-29 16:01:42Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Check structure of Factory sessions directory

`ls -la ~/.factory/sessions/ 2>/dev/null || echo "Factory sessions directory does not exist"`
```
Permission for this tool use was denied. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). Try a different approach or report the limitation to complete your task.
```
</details></tool-use>

_**Agent - sidechain (2026-01-29 16:02:48Z)**_

[Request interrupted by user]

---

_**User (2026-01-29 16:02:48Z)**_

[Request interrupted by user for tool use]

_**User (2026-01-29 16:02:49Z)**_

what does go mod graph do?

---

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:02:52Z)**_

<think><details><summary>Thought Process</summary>
The user is asking a quick question about the `go mod graph` command. This is a straightforward Go tooling question - I can answer directly without needing to search or explore.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:02:55Z)**_

`go mod graph` prints the module dependency graph in text form. Each line shows a dependency relationship:

```
module@version dependency@version
```

For example:
```
github.com/myproject golang.org/x/text@v0.3.0
golang.org/x/text@v0.3.0 golang.org/x/tools@v0.1.0
```

This shows:
- `myproject` depends on `golang.org/x/text@v0.3.0`
- `golang.org/x/text@v0.3.0` depends on `golang.org/x/tools@v0.1.0`

Common uses:
- Debugging dependency issues
- Understanding why a specific module version is included
- Piping to `grep` to find specific dependencies: `go mod graph | grep fsnotify`

---

_**User (2026-01-29 16:03:06Z)**_

proceed

---

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:03:12Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to proceed with the planning. I was in the middle of launching a Plan agent when it was interrupted. Let me continue with the planning process.

I already have a good understanding of the codebase from my exploration. Let me now write the plan directly based on my analysis rather than launching another agent.

Based on my exploration:

1. **Droid provider current state**: Uses 1-second polling with `time.NewTicker`
2. **Claude Code pattern**: Uses fsnotify with package-level globals for context, WaitGroup, and callback management
3. **Key consideration**: Whether to adopt Claude Code's pattern or adapt fsnotify to work with Droid's simpler context-passing approach

I think the best approach is to adapt fsnotify while keeping Droid's simpler context-passing pattern (rather than introducing package-level globals). This is cleaner and the Droid provider's integration is already well-structured for this.

Let me write the plan file now.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:03:13Z)**_

Let me write the implementation plan based on my analysis.

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:03:39Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# Plan: Migrate Droid Provider from Polling to fsnotify

## Overview

Replace the 1-second polling mechanism in the Droid provider with fsnotify event-based file watching, matching the approach used by Claude Code, Codex, and Gemini providers.

## Current State

- **File**: `pkg/providers/droidcli/watcher.go`
- **Mechanism**: `time.NewTicker(1 * time.Second)` polls all files every second
- **Directory**: `~/.factory/sessions/` (recursive via `filepath.WalkDir`)
- **Change detection**: Compares file ModTime against `lastProcessed` map

## Recommended Approach

Keep Droid's simpler context-passing pattern (no package-level globals) while adding fsnotify. This is cleaner than Claude Code's pattern and sufficient for Droid's use case.

### Key Design Decisions

1. **Context-passing over globals**: Keep passing context directly to `watchSessions()` rather than adopting Claude Code's package-level globals pattern. The current integration is clean and works well.

2. **Recursive directory watching**: Add watches to the sessions directory and all subdirectories. Dynamically add watches when new directories are created.

3. **Directory pre-existence handling**: If `~/.factory/sessions/` doesn't exist, watch `~/.factory/` (or create the sessions dir watch when `.factory` is created).

4. **No debouncing needed**: fsnotify naturally batches rapid changes, and processing is idempotent (same file reprocessed = same result).

## Files to Modify

1. `pkg/providers/droidcli/watcher.go` - Main changes

## Implementation Plan

### Step 1: Add fsnotify import

Add `"github.com/fsnotify/fsnotify"` to imports (already a project dependency).

### Step 2: Rewrite `watchSessions()` function

Replace the ticker-based loop with fsnotify event handling:

\```go
func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
    if sessionCallback == nil {
        return fmt.Errorf("session callback is required")
    }

    sessionsDir, err := resolveSessionsDir()
    if err != nil {
        return err
    }

    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        return fmt.Errorf("droidcli: failed to create watcher: %w", err)
    }
    defer watcher.Close()

    state := &watchState{lastProcessed: make(map[string]int64)}

    // Initial scan
    if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
        slog.Debug("droidcli: initial scan failed", "error", err)
    }

    // Setup directory watching (handles non-existent dirs)
    if err := setupDirectoryWatches(watcher, sessionsDir); err != nil {
        slog.Debug("droidcli: setup watches failed", "error", err)
    }

    // Event loop
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case event, ok := <-watcher.Events:
            if !ok {
                return nil
            }
            handleWatchEvent(event, watcher, sessionsDir, projectPath, debugRaw, sessionCallback, state)
        case err, ok := <-watcher.Errors:
            if !ok {
                return nil
            }
            slog.Debug("droidcli: watcher error", "error", err)
        }
    }
}
\```

### Step 3: Add helper functions

**`setupDirectoryWatches()`** - Add watches to sessions dir and subdirectories:

\```go
func setupDirectoryWatches(watcher *fsnotify.Watcher, sessionsDir string) error {
    // Check if sessions directory exists
    if _, err := os.Stat(sessionsDir); os.IsNotExist(err) {
        // Watch parent (.factory) for sessions dir creation
        parentDir := filepath.Dir(sessionsDir)
        if _, err := os.Stat(parentDir); os.IsNotExist(err) {
            // Watch home for .factory creation
            homeDir := filepath.Dir(parentDir)
            return watcher.Add(homeDir)
        }
        return watcher.Add(parentDir)
    }

    // Watch sessions dir and all subdirectories
    return filepath.WalkDir(sessionsDir, func(path string, d fs.DirEntry, err error) error {
        if err != nil {
            return nil
        }
        if d.IsDir() {
            if watchErr := watcher.Add(path); watchErr != nil {
                slog.Debug("droidcli: failed to watch directory", "path", path, "error", watchErr)
            }
        }
        return nil
    })
}
\```

**`handleWatchEvent()`** - Process fsnotify events:

\```go
func handleWatchEvent(event fsnotify.Event, watcher *fsnotify.Watcher, sessionsDir string, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) {
    // Handle directory creation - add new watch
    if event.Has(fsnotify.Create) {
        if info, err := os.Stat(event.Name); err == nil && info.IsDir() {
            _ = watcher.Add(event.Name)

            // Check if this is the sessions directory being created
            if event.Name == sessionsDir {
                _ = setupDirectoryWatches(watcher, sessionsDir)
            }
            return
        }
    }

    // Only process .jsonl files
    if !strings.HasSuffix(event.Name, ".jsonl") {
        return
    }

    // Only process Create and Write events
    if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) {
        return
    }

    slog.Debug("droidcli: jsonl file event", "op", event.Op.String(), "file", event.Name)

    // Process the specific file that changed
    processSessionFile(event.Name, projectPath, debugRaw, sessionCallback, state)
}
\```

**`processSessionFile()`** - Process a single changed file:

\```go
func processSessionFile(filePath string, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) {
    info, err := os.Stat(filePath)
    if err != nil {
        return
    }

    modTime := info.ModTime().UnixNano()
    if last, ok := state.lastProcessed[filePath]; ok && last >= modTime {
        return
    }

    if projectPath != "" && !sessionMentionsProject(filePath, projectPath) {
        return
    }

    session, err := parseFactorySession(filePath)
    if err != nil {
        slog.Debug("droidcli: skipping session", "path", filePath, "error", err)
        return
    }

    chat := convertToAgentSession(session, projectPath, debugRaw)
    if chat == nil {
        return
    }

    state.lastProcessed[filePath] = modTime
    dispatchSession(sessionCallback, chat)
}
\```

### Step 4: Update imports

Add to imports in `watcher.go`:
- `"github.com/fsnotify/fsnotify"`
- `"io/fs"`
- `"os"`
- `"path/filepath"`
- `"strings"`

## Verification

1. **Build**: `go build -o specstory`
2. **Lint**: `golangci-lint run`
3. **Test**: `go test -v ./pkg/providers/droidcli/...`
4. **Manual test**:
   - Run `./specstory run droid` with a Factory Droid session
   - Verify file changes trigger processing without 1-second delay
   - Verify new sessions are detected immediately

```
```
File created successfully at: /Users/sean/.claude/plans/scalable-herding-platypus.md
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:03:43Z)**_

<think><details><summary>Thought Process</summary>
I've written the plan. Now I should call ExitPlanMode to request user approval of the plan.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:03:45Z)**_

I've created the implementation plan. The key decisions are:

1. **Keep the simpler context-passing pattern** - No need to adopt Claude Code's package-level globals; Droid's current integration is cleaner
2. **Handle missing directories gracefully** - Watch parent directories when `~/.factory/sessions/` doesn't exist yet
3. **Dynamic subdirectory watching** - Add watches as new directories are created
4. **Single file processing** - On events, process only the changed file rather than scanning all files

_**Agent (claude-opus-4-5-20251101 2026-01-29 16:03:45Z)**_

<tool-use data-tool-type="generic" data-tool-name="ExitPlanMode"><details>
<summary>Tool use: **ExitPlanMode**</summary>

**Input:**

- plan: `# Plan: Migrate Droid Provider from Polling to fsnotify

## Overview

Replace the 1-second polling mechanism in the Droid provider with fsnotify event-based file watching, matching the approach used by Claude Code, Codex, and Gemini providers.

## Current State

- **File**: `pkg/providers/droidcli/watcher.go`
- **Mechanism**: `time.NewTicker(1 * time.Second)` polls all files every second
- **Directory**: `~/.factory/sessions/` (recursive via `filepath.WalkDir`)
- **Change detection**: Compares file ModTime against `lastProcessed` map

## Recommended Approach

Keep Droid's simpler context-passing pattern (no package-level globals) while adding fsnotify. This is cleaner than Claude Code's pattern and sufficient for Droid's use case.

### Key Design Decisions

1. **Context-passing over globals**: Keep passing context directly to `watchSessions()` rather than adopting Claude Code's package-level globals pattern. The current integration is clean and works well.

2. **Recursive directory watching**: Add watches to the sessions directory and all subdirectories. Dynamically add watches when new directories are created.

3. **Directory pre-existence handling**: If `~/.factory/sessions/` doesn't exist, watch `~/.factory/` (or create the sessions dir watch when `.factory` is created).

4. **No debouncing needed**: fsnotify naturally batches rapid changes, and processing is idempotent (same file reprocessed = same result).

## Files to Modify

1. `pkg/providers/droidcli/watcher.go` - Main changes

## Implementation Plan

### Step 1: Add fsnotify import

Add `"github.com/fsnotify/fsnotify"` to imports (already a project dependency).

### Step 2: Rewrite `watchSessions()` function

Replace the ticker-based loop with fsnotify event handling:

```go
func watchSessions(ctx context.Context, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession)) error {
    if sessionCallback == nil {
        return fmt.Errorf("session callback is required")
    }

    sessionsDir, err := resolveSessionsDir()
    if err != nil {
        return err
    }

    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        return fmt.Errorf("droidcli: failed to create watcher: %w", err)
    }
    defer watcher.Close()

    state := &watchState{lastProcessed: make(map[string]int64)}

    // Initial scan
    if err := scanAndProcessSessions(projectPath, debugRaw, sessionCallback, state); err != nil {
        slog.Debug("droidcli: initial scan failed", "error", err)
    }

    // Setup directory watching (handles non-existent dirs)
    if err := setupDirectoryWatches(watcher, sessionsDir); err != nil {
        slog.Debug("droidcli: setup watches failed", "error", err)
    }

    // Event loop
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case event, ok := <-watcher.Events:
            if !ok {
                return nil
            }
            handleWatchEvent(event, watcher, sessionsDir, projectPath, debugRaw, sessionCallback, state)
        case err, ok := <-watcher.Errors:
            if !ok {
                return nil
            }
            slog.Debug("droidcli: watcher error", "error", err)
        }
    }
}
```

### Step 3: Add helper functions

**`setupDirectoryWatches()`** - Add watches to sessions dir and subdirectories:

```go
func setupDirectoryWatches(watcher *fsnotify.Watcher, sessionsDir string) error {
    // Check if sessions directory exists
    if _, err := os.Stat(sessionsDir); os.IsNotExist(err) {
        // Watch parent (.factory) for sessions dir creation
        parentDir := filepath.Dir(sessionsDir)
        if _, err := os.Stat(parentDir); os.IsNotExist(err) {
            // Watch home for .factory creation
            homeDir := filepath.Dir(parentDir)
            return watcher.Add(homeDir)
        }
        return watcher.Add(parentDir)
    }

    // Watch sessions dir and all subdirectories
    return filepath.WalkDir(sessionsDir, func(path string, d fs.DirEntry, err error) error {
        if err != nil {
            return nil
        }
        if d.IsDir() {
            if watchErr := watcher.Add(path); watchErr != nil {
                slog.Debug("droidcli: failed to watch directory", "path", path, "error", watchErr)
            }
        }
        return nil
    })
}
```

**`handleWatchEvent()`** - Process fsnotify events:

```go
func handleWatchEvent(event fsnotify.Event, watcher *fsnotify.Watcher, sessionsDir string, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) {
    // Handle directory creation - add new watch
    if event.Has(fsnotify.Create) {
        if info, err := os.Stat(event.Name); err == nil && info.IsDir() {
            _ = watcher.Add(event.Name)

            // Check if this is the sessions directory being created
            if event.Name == sessionsDir {
                _ = setupDirectoryWatches(watcher, sessionsDir)
            }
            return
        }
    }

    // Only process .jsonl files
    if !strings.HasSuffix(event.Name, ".jsonl") {
        return
    }

    // Only process Create and Write events
    if !event.Has(fsnotify.Create) && !event.Has(fsnotify.Write) {
        return
    }

    slog.Debug("droidcli: jsonl file event", "op", event.Op.String(), "file", event.Name)

    // Process the specific file that changed
    processSessionFile(event.Name, projectPath, debugRaw, sessionCallback, state)
}
```

**`processSessionFile()`** - Process a single changed file:

```go
func processSessionFile(filePath string, projectPath string, debugRaw bool, sessionCallback func(*spi.AgentChatSession), state *watchState) {
    info, err := os.Stat(filePath)
    if err != nil {
        return
    }

    modTime := info.ModTime().UnixNano()
    if last, ok := state.lastProcessed[filePath]; ok && last >= modTime {
        return
    }

    if projectPath != "" && !sessionMentionsProject(filePath, projectPath) {
        return
    }

    session, err := parseFactorySession(filePath)
    if err != nil {
        slog.Debug("droidcli: skipping session", "path", filePath, "error", err)
        return
    }

    chat := convertToAgentSession(session, projectPath, debugRaw)
    if chat == nil {
        return
    }

    state.lastProcessed[filePath] = modTime
    dispatchSession(sessionCallback, chat)
}
```

### Step 4: Update imports

Add to imports in `watcher.go`:
- `"github.com/fsnotify/fsnotify"`
- `"io/fs"`
- `"os"`
- `"path/filepath"`
- `"strings"`

## Verification

1. **Build**: `go build -o specstory`
2. **Lint**: `golangci-lint run`
3. **Test**: `go test -v ./pkg/providers/droidcli/...`
4. **Manual test**:
   - Run `./specstory run droid` with a Factory Droid session
   - Verify file changes trigger processing without 1-second delay
   - Verify new sessions are detected immediately
`

</details></tool-use>
