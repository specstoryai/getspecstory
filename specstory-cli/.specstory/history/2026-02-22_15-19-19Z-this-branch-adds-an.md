<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-02-22 15:19:19Z

<!-- Claude Code Session ca840fc9-f560-413f-acd5-249e54d818a6 (2026-02-22 15:19:19Z) -->

_**User (2026-02-22 15:19:19Z)**_

This branch adds an (optional) TOML config file for the CLI.

The priority is flags -> local project file -> ~ file

BUT.. no one is going to discover this config file, or know the right content/format for it.

Do estas ne bona.

So, at startup (any command) we want to check for the ~ config file, and if one isn't there create a default one, with everything we read from the config file there, but commented out.

---

_**Agent (claude-opus-4-6 2026-02-22 15:19:23Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to plan a feature where the CLI automatically creates a default config file in the home directory (`~`) if one doesn't exist. The config file should contain all configurable options but commented out, so users can discover and customize it.

Let me explore the codebase to understand the current config file implementation.
</details></think>

_**Agent (claude-opus-4-6 2026-02-22 15:19:23Z)**_

I'll explore the codebase to understand the current config file implementation and how it's used.

_**Agent (claude-opus-4-6 2026-02-22 15:20:13Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Explore config package

```text
Perfect! Now I have a comprehensive understanding. Let me create a thorough report:

## Configuration System Analysis for SpecStory CLI

I've thoroughly explored the configuration system in the SpecStory CLI. Here's a comprehensive breakdown:

### 1. Config File Structure (TOML Format)

All configurable fields are defined in `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go`:

**Root-level options:**
- `output_dir` (string) - Custom output directory for markdown and debug files

**Nested sections:**

**`[version_check]`**
- `enabled` (boolean pointer, default: true) - Check for newer versions on startup

**`[cloud_sync]`**
- `enabled` (boolean pointer, default: true) - Enable syncing to SpecStory Cloud

**`[local_sync]`**
- `enabled` (boolean pointer, default: true) - Write local markdown files. When false, equivalent to `--only-cloud-sync`

**`[logging]`**
- `console` (boolean pointer, default: false) - Output error/warn/info to stdout
- `log` (boolean pointer, default: false) - Write logs to `.specstory/debug/debug.log`
- `debug` (boolean pointer, default: false) - Enable debug-level output (requires console or log)
- `silent` (boolean pointer, default: false) - Suppress all non-error output

**`[analytics]`**
- `enabled` (boolean pointer, default: true) - Send anonymous usage analytics

### 2. Configuration Loading Priority Order

From highest to lowest priority:
1. **CLI flags** (e.g., `--console`, `--no-cloud-sync`)
2. **Local project config** - `.specstory/cli-config.toml` (in current working directory)
3. **User-level config** - `~/.specstory/cli-config.toml` (in home directory)

This is implemented in the `Load()` function at lines 105-144 of `config.go`.

### 3. Home Directory Config Path Definition

The home directory path is defined in the `getUserConfigPath()` function (lines 146-154 of `config.go`):

```go
func getUserConfigPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		slog.Debug("Could not determine home directory", "error", err)
		return ""
	}
	return filepath.Join(home, SpecStoryDir, ConfigFileName)
}
```

**Constants used:**
- `SpecStoryDir = ".specstory"` (line 24)
- `ConfigFileName = "cli-config.toml"` (line 22)

So the full path becomes: `~/.specstory/cli-config.toml`

The local project config path (from `getLocalConfigPath()`, lines 156-164) is: `.specstory/cli-config.toml` in the current working directory.

### 4. All Configurable Options Summary

| Section | Option | TOML Type | Default | Description |
|---------|--------|-----------|---------|-------------|
| (root) | `output_dir` | string | (empty) | Custom output directory path |
| `[version_check]` | `enabled` | boolean | true | Version check on startup |
| `[cloud_sync]` | `enabled` | boolean | true | Cloud sync to SpecStory |
| `[local_sync]` | `enabled` | boolean | true | Local markdown file writes |
| `[logging]` | `console` | boolean | false | Console logging to stdout |
| `[logging]` | `log` | boolean | false | File logging to debug.log |
| `[logging]` | `debug` | boolean | false | Debug-level output |
| `[logging]` | `silent` | boolean | false | Suppress non-error output |
| `[analytics]` | `enabled` | boolean | true | Usage analytics collection |

### 5. How Config is Used Throughout the Codebase

**In `main.go` (lines 1194-1224):**
- Config is loaded early (before logging setup) so TOML settings can affect logging behavior
- CLI flags are passed to `config.Load()` as `CLIOverrides` 
- After loading, config values are applied back to flag variables for the rest of the code
- This allows the rest of the codebase to use the unified flag variables without explicitly checking config

**Config getter methods** (all with predictable defaults):
- `GetOutputDir()` - Returns empty string if not set
- `IsVersionCheckEnabled()` - Defaults to true
- `IsCloudSyncEnabled()` - Defaults to true
- `IsLocalSyncEnabled()` - Defaults to true
- `IsConsoleEnabled()` - Defaults to false
- `IsLogEnabled()` - Defaults to false
- `IsDebugEnabled()` - Defaults to false
- `IsSilentEnabled()` - Defaults to false
- `IsAnalyticsEnabled()` - Defaults to true

### 6. Example Configuration File

From README.md (lines 96-126), a complete example:

```toml
# Custom output directory for markdown and debug files
output_dir = "/path/to/output"

[version_check]
enabled = true

[cloud_sync]
enabled = true

[local_sync]
enabled = true

[logging]
console = false
log = false
debug = false
silent = false

[analytics]
enabled = true
```

### 7. Config Loading Behavior Details

- **Missing files**: Not treated as errors. If a config file doesn't exist, it's simply skipped with debug logging.
- **Parse errors**: Returned to the caller as errors. Invalid TOML syntax causes the Load() function to return an error.
- **Field merging**: TOML files are decoded using `DecodeFile()` which merges fields - later calls overwrite earlier values.
- **Boolean pointers**: Config uses `*bool` so that `nil` (not set) can be distinguished from explicit `false`.
- **Graceful degradation**: If config loading fails, main.go falls back to an empty config (lines 1207-1210) and logs the error after logging is set up.

### 8. Testing Coverage

The config package has comprehensive test coverage in `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go`:

- **TestLoadPrecedence** - Verifies priority order (project overrides user config)
- **TestCLIOverrides** - Validates all CLI flags override config file settings
- **TestParseErrorHandling** - Ensures TOML parse errors are returned
- **TestMissingFileHandling** - Confirms missing files don't cause errors
- **TestDefaultValues** - Tests all default values when no config exists

### 9. Documentation

The configuration system is documented in:
- **README.md** (lines 82-141) - User-facing documentation with examples and configuration options table
- **CLAUDE.md** (project instructions) - References config file handling as part of the project technical details
- **config.go** (lines 1-9) - Clear inline documentation of priority and file locations

This is a clean, well-designed configuration system with excellent separation of concerns and comprehensive testing.
agentId: a13a7db (for resuming to continue this agent's work if needed)
<usage>total_tokens: 57328
tool_uses: 20
duration_ms: 45088</usage>
```
</details></tool-use>

_**Agent - sidechain (2026-02-22 15:19:28Z)**_

Thoroughly explore the pkg/config/ directory and understand:
1. What the config file structure looks like (TOML format, all fields)
2. How config files are loaded (priority order, file paths)
3. Where the home directory config file path is defined
4. What all configurable options are
5. How the config is used throughout the codebase

Also look at any existing TOML config examples or documentation.

Search for all references to the config package across the codebase to understand how it's consumed.

Exclude the .specstory directory from all searches.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:29Z)**_

I'll thoroughly explore the config directory and search for all references to understand the configuration system. Let me start with a systematic approach.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:29Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `pkg/config/**`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:29Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/*.toml`

```text
No files found
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:31Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find all Go files in config package

`find /Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config -type f -name "*.go"`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:19:57Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Explore CLI startup flow

```text
Perfect! I now have a comprehensive understanding of the CLI startup flow. Let me provide a detailed report.

## CLI Startup Flow Analysis

I've explored the complete startup sequence and identified exactly where config is loaded and where you could hook in logic to check for and create a default config file. Here's what I found:

### 1. **Entry Point: `main.go` (lines 1162-1456)**

The startup sequence is:

**Step 1: Early Flag Parsing (lines 1163-1192)**
- Manual parsing of critical flags (`--no-usage-analytics`, `--console`, `--log`, `--debug`, `--silent`, `--no-version-check`, `--output-dir`)
- This happens before Cobra's normal parsing to handle flags that affect early initialization

**Step 2: Config Loading (lines 1194-1210)**
```go
cfg, cfgErr := config.Load(&config.CLIOverrides{...})
```
- Happens AFTER early flag parsing, BEFORE logging setup
- Loads config from:
  1. User-level: `~/.specstory/cli-config.toml` (lowest priority)
  2. Local project: `.specstory/cli-config.toml` (overwrites user config)
  3. CLI flags (highest priority, applied after file loading)
- Returns error if config file exists but has parsing errors (required behavior)
- Returns nil error if config file is missing (missing files are skipped)

**Step 3: Apply Config to Flag Variables (lines 1212-1224)**
- Merges loaded config with already-parsed CLI flags

**Step 4: Logger Setup (lines 1226-1237)**
- Sets up logging (console/file) based on config + CLI flags

**Step 5: Command Creation (lines 1239-1268)**
- Creates all commands (`run`, `watch`, `sync`, `list`, `check`, `version`, `login`, `logout`)
- Each command is created dynamically with provider information

**Step 6: Flag Definition (lines 1270-1304)**
- Defines persistent and command-specific flags on the root and sub-commands

**Step 7: Analytics Initialization (lines 1306-1318)**

**Step 8: Version Check (line 1326)**

**Step 9: Defer Cleanup (lines 1329-1415)**

**Step 10: Command Execution via Cobra (line 1417)**

### 2. **Config Loading: `pkg/config/config.go`**

The `Load()` function (lines 105-143):

```go
func Load(cliOverrides *CLIOverrides) (*Config, error) {
    cfg := &Config{}
    
    // Load user-level config first (lowest priority)
    userConfigPath := getUserConfigPath()  // ~/.specstory/cli-config.toml
    
    // Load local project config (overwrites user-level)
    localConfigPath := getLocalConfigPath()  // .specstory/cli-config.toml
    
    // Apply CLI flag overrides (highest priority)
    
    return cfg, nil
}
```

Key behaviors:
- Returns error ONLY if config file exists but can't be parsed
- Missing config files are silently skipped
- Both user-level and project-level configs are optional
- `loadTOMLFile()` uses BurntSushi/toml library for parsing

### 3. **Command Structure Pattern**

Each command is created with a factory function in `pkg/cmd/`:
- `CreateRunCommand()` in main.go
- `CreateSyncCommand()` in main.go
- `CreateWatchCommand()` in watch.go
- `CreateCheckCommand()` in check.go
- `CreateVersionCommand()` in version.go
- `CreateListCommand()` in list.go
- etc.

All commands inherit from the **root command** which has a `PersistentPreRunE` hook (lines 145-223 in main.go):

```go
rootCmd := &cobra.Command{
    // ...
    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
        // Validate flags
        // Configure logging
        // Initialize cloud sync manager
        // Handle authentication
        
        return nil
    },
    // ...
}
```

This hook runs **before ANY subcommand** - it's the ideal place to hook in config initialization logic.

### 4. **Ideal Hook Points for Default Config Creation**

You have **two excellent options**:

**Option A: In `config.Load()` function (pkg/config/config.go)**
- **Pros**: 
  - Centralized, clean separation of concerns
  - Happens early (before logging, before commands)
  - Can handle both user-level and project-level config creation
  - Doesn't pollute main.go
- **Cons**:
  - Slightly less visible since it's in a separate package

**Option B: In `main.go` after `config.Load()` (around line 1210)**
- **Pros**:
  - Explicit, visible in the startup flow
  - Has access to parsed flags and logging setup options
- **Cons**:
  - Main.go is already large and complex

**Option C: In root command's `PersistentPreRunE` hook (main.go, line 145)**
- **Pros**:
  - Runs for ALL commands automatically
  - After logging is set up
- **Cons**:
  - Runs for EVERY command invocation (even `--help`, `--version`)
  - Less efficient than doing it at startup

### 5. **Key Files and Paths**

Absolute paths for reference:
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/main.go` - Entry point, config loading at line 1194
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go` - Config loading logic
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/` - Command implementations

Config file paths (runtime determined):
- User-level: `~/.specstory/cli-config.toml`
- Project-level: `.specstory/cli-config.toml` (relative to current working directory)
- History directory: `.specstory/history/` (created by `utils.EnsureHistoryDirectoryExists()`)

### 6. **Implementation Recommendations**

**My recommendation: Option A - Add logic to `config.Load()` function**

Reasoning:
1. It's the natural place where config files are handled
2. Happens at the right time in startup sequence (before any command runs)
3. Keeps concerns separated - config package handles config
4. Has clean error handling pattern already in place
5. Can create default config templates if needed
6. Won't add overhead to commands that don't need it

The implementation would:
- Check if `.specstory/cli-config.toml` exists after loading attempts
- If it doesn't exist, create it with sensible defaults
- Return the config as normal (whether freshly created or loaded)
- This integrates seamlessly with the current priority system: user-level → local → defaults

Would you like me to analyze any specific part of the code further, or are you ready to move forward with implementation?
agentId: ad4d774 (for resuming to continue this agent's work if needed)
<usage>total_tokens: 47466
tool_uses: 8
duration_ms: 25140</usage>
```
</details></tool-use>

_**Agent - sidechain (2026-02-22 15:19:31Z)**_

Explore how the CLI starts up - look at:
1. main.go - the entry point
2. pkg/cmd/ - how commands are initialized and run
3. Where config is loaded during startup
4. Any existing "init" or "setup" logic that runs at startup for all commands
5. The command structure (root command, subcommands)

I need to understand where we could hook in logic that runs at startup for ANY command to check for and create a default config file.

Exclude the .specstory directory from all searches.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:32Z)**_

Now let me read the main config files:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:33Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/config/config.go`

```text
     1→// Package config provides configuration management for the SpecStory CLI.
     2→// Configuration is loaded with the following priority (highest to lowest):
     3→//  1. CLI flags
     4→//  2. Local project config: .specstory/cli-config.toml
     5→//  3. User-level config: ~/.specstory/cli-config.toml
     6→//
     7→// Note: For telemetry settings, environment variables (OTEL_*) take highest priority
     8→// per OpenTelemetry conventions.
     9→package config
    10→
    11→import (
    12→	"fmt"
    13→	"log/slog"
    14→	"os"
    15→	"path/filepath"
    16→
    17→	"github.com/BurntSushi/toml"
    18→)
    19→
    20→const (
    21→	// ConfigFileName is the name of the configuration file
    22→	ConfigFileName = "cli-config.toml"
    23→	// SpecStoryDir is the directory name for SpecStory files
    24→	SpecStoryDir = ".specstory"
    25→)
    26→
    27→// Config represents the complete CLI configuration
    28→type Config struct {
    29→	// OutputDir is the custom output directory for markdown and debug files
    30→	OutputDir string `toml:"output_dir"`
    31→
    32→	VersionCheck VersionCheckConfig `toml:"version_check"`
    33→	CloudSync    CloudSyncConfig    `toml:"cloud_sync"`
    34→	LocalSync    LocalSyncConfig    `toml:"local_sync"`
    35→	Logging      LoggingConfig      `toml:"logging"`
    36→	Analytics    AnalyticsConfig    `toml:"analytics"`
    37→}
    38→
    39→// VersionCheckConfig holds version check settings
    40→type VersionCheckConfig struct {
    41→	// Enabled controls whether to check for newer versions on startup
    42→	Enabled *bool `toml:"enabled"`
    43→}
    44→
    45→// CloudSyncConfig holds cloud sync settings
    46→type CloudSyncConfig struct {
    47→	// Enabled controls whether cloud sync is active
    48→	Enabled *bool `toml:"enabled"`
    49→}
    50→
    51→// LocalSyncConfig holds local file sync settings
    52→type LocalSyncConfig struct {
    53→	// Enabled controls whether local markdown files are written
    54→	// When false, only cloud sync is performed (equivalent to --only-cloud-sync)
    55→	Enabled *bool `toml:"enabled"`
    56→}
    57→
    58→// LoggingConfig holds logging settings
    59→type LoggingConfig struct {
    60→	// Console enables error/warn/info output to stdout
    61→	Console *bool `toml:"console"`
    62→	// Log enables writing error/warn/info output to .specstory/debug/debug.log
    63→	Log *bool `toml:"log"`
    64→	// Debug enables debug-level output (requires Console or Log)
    65→	Debug *bool `toml:"debug"`
    66→	// Silent suppresses all non-error output
    67→	Silent *bool `toml:"silent"`
    68→}
    69→
    70→// AnalyticsConfig holds analytics settings
    71→type AnalyticsConfig struct {
    72→	// Enabled controls whether usage analytics are sent
    73→	Enabled *bool `toml:"enabled"`
    74→}
    75→
    76→// CLIOverrides holds CLI flag values that override config file settings.
    77→// These are applied after config files are loaded.
    78→type CLIOverrides struct {
    79→	// General
    80→	OutputDir string
    81→
    82→	// Version check
    83→	NoVersionCheck bool
    84→
    85→	// Cloud sync
    86→	NoCloudSync   bool
    87→	OnlyCloudSync bool
    88→
    89→	// Logging
    90→	Console bool
    91→	Log     bool
    92→	Debug   bool
    93→	Silent  bool
    94→
    95→	// Analytics
    96→	NoAnalytics bool
    97→}
    98→
    99→// Load reads configuration from files and CLI flags.
   100→// Priority: CLI flags > local project config > user-level config
   101→//
   102→// Returns an error if a config file exists but cannot be parsed (TOML syntax error)
   103→// or cannot be read (permission denied, I/O error). Missing config files are not
   104→// treated as errors - they are simply skipped.
   105→func Load(cliOverrides *CLIOverrides) (*Config, error) {
   106→	cfg := &Config{}
   107→
   108→	// Load user-level config first (lowest priority)
   109→	userConfigPath := getUserConfigPath()
   110→	if userConfigPath != "" {
   111→		if err := loadTOMLFile(userConfigPath, cfg); err != nil {
   112→			if os.IsNotExist(err) {
   113→				slog.Debug("No user-level config file found", "path", userConfigPath)
   114→			} else {
   115→				// Parse error or permission denied - return error to caller
   116→				return cfg, fmt.Errorf("failed to load user config %s: %w", userConfigPath, err)
   117→			}
   118→		} else {
   119→			slog.Debug("Loaded user-level config", "path", userConfigPath)
   120→		}
   121→	}
   122→
   123→	// Load local project config (overwrites user-level)
   124→	localConfigPath := getLocalConfigPath()
   125→	if localConfigPath != "" {
   126→		if err := loadTOMLFile(localConfigPath, cfg); err != nil {
   127→			if os.IsNotExist(err) {
   128→				slog.Debug("No local project config file found", "path", localConfigPath)
   129→			} else {
   130→				// Parse error or permission denied - return error to caller
   131→				return cfg, fmt.Errorf("failed to load project config %s: %w", localConfigPath, err)
   132→			}
   133→		} else {
   134→			slog.Debug("Loaded local project config", "path", localConfigPath)
   135→		}
   136→	}
   137→
   138→	// Apply CLI flag overrides (highest priority for most settings)
   139→	if cliOverrides != nil {
   140→		applyCLIOverrides(cfg, cliOverrides)
   141→	}
   142→
   143→	return cfg, nil
   144→}
   145→
   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
   147→func getUserConfigPath() string {
   148→	home, err := os.UserHomeDir()
   149→	if err != nil {
   150→		slog.Debug("Could not determine home directory", "error", err)
   151→		return ""
   152→	}
   153→	return filepath.Join(home, SpecStoryDir, ConfigFileName)
   154→}
   155→
   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
   157→func getLocalConfigPath() string {
   158→	cwd, err := os.Getwd()
   159→	if err != nil {
   160→		slog.Debug("Could not determine current directory", "error", err)
   161→		return ""
   162→	}
   163→	return filepath.Join(cwd, SpecStoryDir, ConfigFileName)
   164→}
   165→
   166→// loadTOMLFile reads a TOML file and decodes it into the config struct.
   167→// Fields are merged (later calls overwrite earlier values).
   168→func loadTOMLFile(path string, cfg *Config) error {
   169→	_, err := toml.DecodeFile(path, cfg)
   170→	return err
   171→}
   172→
   173→// applyCLIOverrides applies CLI flag overrides to the config.
   174→func applyCLIOverrides(cfg *Config, o *CLIOverrides) {
   175→	// General
   176→	if o.OutputDir != "" {
   177→		cfg.OutputDir = o.OutputDir
   178→	}
   179→
   180→	// Version check (--no-version-check sets enabled to false)
   181→	if o.NoVersionCheck {
   182→		disabled := false
   183→		cfg.VersionCheck.Enabled = &disabled
   184→	}
   185→
   186→	// Cloud sync (--no-cloud-sync sets enabled to false)
   187→	if o.NoCloudSync {
   188→		disabled := false
   189→		cfg.CloudSync.Enabled = &disabled
   190→	}
   191→
   192→	// Local sync (--only-cloud-sync sets enabled to false)
   193→	if o.OnlyCloudSync {
   194→		disabled := false
   195→		cfg.LocalSync.Enabled = &disabled
   196→	}
   197→
   198→	// Logging flags only override if explicitly set (true)
   199→	if o.Console {
   200→		enabled := true
   201→		cfg.Logging.Console = &enabled
   202→	}
   203→	if o.Log {
   204→		enabled := true
   205→		cfg.Logging.Log = &enabled
   206→	}
   207→	if o.Debug {
   208→		enabled := true
   209→		cfg.Logging.Debug = &enabled
   210→	}
   211→	if o.Silent {
   212→		enabled := true
   213→		cfg.Logging.Silent = &enabled
   214→	}
   215→
   216→	// Analytics (--no-usage-analytics sets enabled to false)
   217→	if o.NoAnalytics {
   218→		disabled := false
   219→		cfg.Analytics.Enabled = &disabled
   220→	}
   221→}
   222→
   223→// --- Getter methods ---
   224→
   225→// GetOutputDir returns the output directory, or empty string to use default.
   226→func (c *Config) GetOutputDir() string {
   227→	return c.OutputDir
   228→}
   229→
   230→// IsVersionCheckEnabled returns whether version check is enabled.
   231→// Defaults to true if not explicitly set.
   232→func (c *Config) IsVersionCheckEnabled() bool {
   233→	if c.VersionCheck.Enabled != nil {
   234→		return *c.VersionCheck.Enabled
   235→	}
   236→	return true // default enabled
   237→}
   238→
   239→// IsCloudSyncEnabled returns whether cloud sync is enabled.
   240→// Defaults to true if not explicitly set.
   241→func (c *Config) IsCloudSyncEnabled() bool {
   242→	if c.CloudSync.Enabled != nil {
   243→		return *c.CloudSync.Enabled
   244→	}
   245→	return true // default enabled
   246→}
   247→
   248→// IsLocalSyncEnabled returns whether local sync is enabled.
   249→// Defaults to true if not explicitly set.
   250→// When false, only cloud sync is performed (equivalent to --only-cloud-sync).
   251→func (c *Config) IsLocalSyncEnabled() bool {
   252→	if c.LocalSync.Enabled != nil {
   253→		return *c.LocalSync.Enabled
   254→	}
   255→	return true // default enabled
   256→}
   257→
   258→// IsConsoleEnabled returns whether console logging is enabled.
   259→// Defaults to false if not explicitly set.
   260→func (c *Config) IsConsoleEnabled() bool {
   261→	if c.Logging.Console != nil {
   262→		return *c.Logging.Console
   263→	}
   264→	return false // default disabled
   265→}
   266→
   267→// IsLogEnabled returns whether file logging is enabled.
   268→// Defaults to false if not explicitly set.
   269→func (c *Config) IsLogEnabled() bool {
   270→	if c.Logging.Log != nil {
   271→		return *c.Logging.Log
   272→	}
   273→	return false // default disabled
   274→}
   275→
   276→// IsDebugEnabled returns whether debug logging is enabled.
   277→// Defaults to false if not explicitly set.
   278→func (c *Config) IsDebugEnabled() bool {
   279→	if c.Logging.Debug != nil {
   280→		return *c.Logging.Debug
   281→	}
   282→	return false // default disabled
   283→}
   284→
   285→// IsSilentEnabled returns whether silent mode is enabled.
   286→// Defaults to false if not explicitly set.
   287→func (c *Config) IsSilentEnabled() bool {
   288→	if c.Logging.Silent != nil {
   289→		return *c.Logging.Silent
   290→	}
   291→	return false // default disabled
   292→}
   293→
   294→// IsAnalyticsEnabled returns whether analytics are enabled.
   295→// Defaults to true if not explicitly set.
   296→func (c *Config) IsAnalyticsEnabled() bool {
   297→	if c.Analytics.Enabled != nil {
   298→		return *c.Analytics.Enabled
   299→	}
   300→	return true // default enabled
   301→}
   302→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:33Z)**_

I'll explore the CLI startup flow systematically, looking at the entry point, command initialization, and configuration loading.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:33Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/config/config_test.go`

```text
     1→package config
     2→
     3→import (
     4→	"os"
     5→	"path/filepath"
     6→	"strings"
     7→	"testing"
     8→)
     9→
    10→// Helper to create a temporary config file with the given content
    11→func createTempConfigFile(t *testing.T, dir, content string) string {
    12→	t.Helper()
    13→	specstoryDir := filepath.Join(dir, SpecStoryDir)
    14→	if err := os.MkdirAll(specstoryDir, 0755); err != nil {
    15→		t.Fatalf("Failed to create .specstory dir: %v", err)
    16→	}
    17→	configPath := filepath.Join(specstoryDir, ConfigFileName)
    18→	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
    19→		t.Fatalf("Failed to write config file: %v", err)
    20→	}
    21→	return configPath
    22→}
    23→
    24→// TestLoadPrecedence tests that project config overrides user config
    25→func TestLoadPrecedence(t *testing.T) {
    26→	// Save and restore original working directory
    27→	origWd, err := os.Getwd()
    28→	if err != nil {
    29→		t.Fatalf("Failed to get working directory: %v", err)
    30→	}
    31→	defer func() { _ = os.Chdir(origWd) }()
    32→
    33→	// Save and restore original HOME
    34→	origHome := os.Getenv("HOME")
    35→	defer func() { _ = os.Setenv("HOME", origHome) }()
    36→
    37→	tests := []struct {
    38→		name           string
    39→		userConfig     string
    40→		projectConfig  string
    41→		expectedOutDir string
    42→	}{
    43→		{
    44→			name:           "project config overrides user config",
    45→			userConfig:     `output_dir = "/user/path"`,
    46→			projectConfig:  `output_dir = "/project/path"`,
    47→			expectedOutDir: "/project/path",
    48→		},
    49→		{
    50→			name:           "user config used when no project config",
    51→			userConfig:     `output_dir = "/user/path"`,
    52→			projectConfig:  "",
    53→			expectedOutDir: "/user/path",
    54→		},
    55→		{
    56→			name:           "project config used when no user config",
    57→			userConfig:     "",
    58→			projectConfig:  `output_dir = "/project/path"`,
    59→			expectedOutDir: "/project/path",
    60→		},
    61→		{
    62→			name:           "empty when no config files",
    63→			userConfig:     "",
    64→			projectConfig:  "",
    65→			expectedOutDir: "",
    66→		},
    67→		{
    68→			name: "project nested config overrides user nested config",
    69→			userConfig: `
    70→[cloud_sync]
    71→enabled = true
    72→`,
    73→			projectConfig: `
    74→[cloud_sync]
    75→enabled = false
    76→`,
    77→			expectedOutDir: "", // We check cloud_sync separately below
    78→		},
    79→	}
    80→
    81→	for _, tt := range tests {
    82→		t.Run(tt.name, func(t *testing.T) {
    83→			// Create temp directories for HOME and project
    84→			tempHome := t.TempDir()
    85→			tempProject := t.TempDir()
    86→
    87→			// Set HOME to temp directory
    88→			if err := os.Setenv("HOME", tempHome); err != nil {
    89→				t.Fatalf("Failed to set HOME: %v", err)
    90→			}
    91→
    92→			// Change to temp project directory
    93→			if err := os.Chdir(tempProject); err != nil {
    94→				t.Fatalf("Failed to chdir: %v", err)
    95→			}
    96→
    97→			// Create user config if provided
    98→			if tt.userConfig != "" {
    99→				createTempConfigFile(t, tempHome, tt.userConfig)
   100→			}
   101→
   102→			// Create project config if provided
   103→			if tt.projectConfig != "" {
   104→				createTempConfigFile(t, tempProject, tt.projectConfig)
   105→			}
   106→
   107→			// Load config
   108→			cfg, err := Load(nil)
   109→			if err != nil {
   110→				t.Fatalf("Load() returned error: %v", err)
   111→			}
   112→
   113→			// Check output_dir precedence
   114→			if cfg.GetOutputDir() != tt.expectedOutDir {
   115→				t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), tt.expectedOutDir)
   116→			}
   117→
   118→			// Special check for nested config test
   119→			if tt.name == "project nested config overrides user nested config" {
   120→				if cfg.IsCloudSyncEnabled() {
   121→					t.Errorf("IsCloudSyncEnabled() = true, want false (project should override user)")
   122→				}
   123→			}
   124→		})
   125→	}
   126→}
   127→
   128→// TestCLIOverrides tests that CLI flags override config file settings
   129→func TestCLIOverrides(t *testing.T) {
   130→	// Save and restore original working directory
   131→	origWd, err := os.Getwd()
   132→	if err != nil {
   133→		t.Fatalf("Failed to get working directory: %v", err)
   134→	}
   135→	defer func() { _ = os.Chdir(origWd) }()
   136→
   137→	// Save and restore original HOME
   138→	origHome := os.Getenv("HOME")
   139→	defer func() { _ = os.Setenv("HOME", origHome) }()
   140→
   141→	tests := []struct {
   142→		name       string
   143→		configFile string
   144→		overrides  *CLIOverrides
   145→		checkFunc  func(t *testing.T, cfg *Config)
   146→	}{
   147→		{
   148→			name:       "OutputDir override",
   149→			configFile: `output_dir = "/config/path"`,
   150→			overrides:  &CLIOverrides{OutputDir: "/cli/path"},
   151→			checkFunc: func(t *testing.T, cfg *Config) {
   152→				if cfg.GetOutputDir() != "/cli/path" {
   153→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/cli/path")
   154→				}
   155→			},
   156→		},
   157→		{
   158→			name: "NoVersionCheck override (--no-version-check)",
   159→			configFile: `
   160→[version_check]
   161→enabled = true
   162→`,
   163→			overrides: &CLIOverrides{NoVersionCheck: true},
   164→			checkFunc: func(t *testing.T, cfg *Config) {
   165→				if cfg.IsVersionCheckEnabled() {
   166→					t.Errorf("IsVersionCheckEnabled() = true, want false")
   167→				}
   168→			},
   169→		},
   170→		{
   171→			name: "NoCloudSync override (--no-cloud-sync)",
   172→			configFile: `
   173→[cloud_sync]
   174→enabled = true
   175→`,
   176→			overrides: &CLIOverrides{NoCloudSync: true},
   177→			checkFunc: func(t *testing.T, cfg *Config) {
   178→				if cfg.IsCloudSyncEnabled() {
   179→					t.Errorf("IsCloudSyncEnabled() = true, want false")
   180→				}
   181→			},
   182→		},
   183→		{
   184→			name: "OnlyCloudSync override (--only-cloud-sync)",
   185→			configFile: `
   186→[local_sync]
   187→enabled = true
   188→`,
   189→			overrides: &CLIOverrides{OnlyCloudSync: true},
   190→			checkFunc: func(t *testing.T, cfg *Config) {
   191→				if cfg.IsLocalSyncEnabled() {
   192→					t.Errorf("IsLocalSyncEnabled() = true, want false")
   193→				}
   194→			},
   195→		},
   196→		{
   197→			name: "Console logging override (--console)",
   198→			configFile: `
   199→[logging]
   200→console = false
   201→`,
   202→			overrides: &CLIOverrides{Console: true},
   203→			checkFunc: func(t *testing.T, cfg *Config) {
   204→				if !cfg.IsConsoleEnabled() {
   205→					t.Errorf("IsConsoleEnabled() = false, want true")
   206→				}
   207→			},
   208→		},
   209→		{
   210→			name: "Log file override (--log)",
   211→			configFile: `
   212→[logging]
   213→log = false
   214→`,
   215→			overrides: &CLIOverrides{Log: true},
   216→			checkFunc: func(t *testing.T, cfg *Config) {
   217→				if !cfg.IsLogEnabled() {
   218→					t.Errorf("IsLogEnabled() = false, want true")
   219→				}
   220→			},
   221→		},
   222→		{
   223→			name: "Debug override (--debug)",
   224→			configFile: `
   225→[logging]
   226→debug = false
   227→`,
   228→			overrides: &CLIOverrides{Debug: true},
   229→			checkFunc: func(t *testing.T, cfg *Config) {
   230→				if !cfg.IsDebugEnabled() {
   231→					t.Errorf("IsDebugEnabled() = false, want true")
   232→				}
   233→			},
   234→		},
   235→		{
   236→			name: "Silent override (--silent)",
   237→			configFile: `
   238→[logging]
   239→silent = false
   240→`,
   241→			overrides: &CLIOverrides{Silent: true},
   242→			checkFunc: func(t *testing.T, cfg *Config) {
   243→				if !cfg.IsSilentEnabled() {
   244→					t.Errorf("IsSilentEnabled() = false, want true")
   245→				}
   246→			},
   247→		},
   248→		{
   249→			name: "NoAnalytics override (--no-usage-analytics)",
   250→			configFile: `
   251→[analytics]
   252→enabled = true
   253→`,
   254→			overrides: &CLIOverrides{NoAnalytics: true},
   255→			checkFunc: func(t *testing.T, cfg *Config) {
   256→				if cfg.IsAnalyticsEnabled() {
   257→					t.Errorf("IsAnalyticsEnabled() = true, want false")
   258→				}
   259→			},
   260→		},
   261→		{
   262→			name:       "Empty CLI override doesn't change config value",
   263→			configFile: `output_dir = "/config/path"`,
   264→			overrides:  &CLIOverrides{OutputDir: ""},
   265→			checkFunc: func(t *testing.T, cfg *Config) {
   266→				if cfg.GetOutputDir() != "/config/path" {
   267→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/config/path")
   268→				}
   269→			},
   270→		},
   271→		{
   272→			name:       "Nil CLI overrides doesn't panic",
   273→			configFile: `output_dir = "/config/path"`,
   274→			overrides:  nil,
   275→			checkFunc: func(t *testing.T, cfg *Config) {
   276→				if cfg.GetOutputDir() != "/config/path" {
   277→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/config/path")
   278→				}
   279→			},
   280→		},
   281→	}
   282→
   283→	for _, tt := range tests {
   284→		t.Run(tt.name, func(t *testing.T) {
   285→			// Create temp directories
   286→			tempHome := t.TempDir()
   287→			tempProject := t.TempDir()
   288→
   289→			// Set HOME to empty temp dir (no user config)
   290→			if err := os.Setenv("HOME", tempHome); err != nil {
   291→				t.Fatalf("Failed to set HOME: %v", err)
   292→			}
   293→
   294→			// Change to temp project directory
   295→			if err := os.Chdir(tempProject); err != nil {
   296→				t.Fatalf("Failed to chdir: %v", err)
   297→			}
   298→
   299→			// Create project config
   300→			if tt.configFile != "" {
   301→				createTempConfigFile(t, tempProject, tt.configFile)
   302→			}
   303→
   304→			// Load config with overrides
   305→			cfg, err := Load(tt.overrides)
   306→			if err != nil {
   307→				t.Fatalf("Load() returned error: %v", err)
   308→			}
   309→
   310→			tt.checkFunc(t, cfg)
   311→		})
   312→	}
   313→}
   314→
   315→// TestParseErrorHandling tests that TOML parse errors are returned to the caller
   316→func TestParseErrorHandling(t *testing.T) {
   317→	// Save and restore original working directory
   318→	origWd, err := os.Getwd()
   319→	if err != nil {
   320→		t.Fatalf("Failed to get working directory: %v", err)
   321→	}
   322→	defer func() { _ = os.Chdir(origWd) }()
   323→
   324→	// Save and restore original HOME
   325→	origHome := os.Getenv("HOME")
   326→	defer func() { _ = os.Setenv("HOME", origHome) }()
   327→
   328→	tests := []struct {
   329→		name          string
   330→		configContent string
   331→		wantError     bool
   332→		errorContains string
   333→	}{
   334→		{
   335→			name:          "valid TOML parses successfully",
   336→			configContent: `output_dir = "/valid/path"`,
   337→			wantError:     false,
   338→		},
   339→		{
   340→			name:          "invalid TOML returns error",
   341→			configContent: `this is not valid toml [[[`,
   342→			wantError:     true,
   343→			errorContains: "failed to load project config",
   344→		},
   345→		{
   346→			name:          "unclosed quote returns error",
   347→			configContent: `output_dir = "/unclosed`,
   348→			wantError:     true,
   349→			errorContains: "failed to load project config",
   350→		},
   351→		{
   352→			name:          "invalid table syntax returns error",
   353→			configContent: `[cloud_sync`,
   354→			wantError:     true,
   355→			errorContains: "failed to load project config",
   356→		},
   357→	}
   358→
   359→	for _, tt := range tests {
   360→		t.Run(tt.name, func(t *testing.T) {
   361→			// Create temp directories
   362→			tempHome := t.TempDir()
   363→			tempProject := t.TempDir()
   364→
   365→			// Set HOME to empty temp dir (no user config)
   366→			if err := os.Setenv("HOME", tempHome); err != nil {
   367→				t.Fatalf("Failed to set HOME: %v", err)
   368→			}
   369→
   370→			// Change to temp project directory
   371→			if err := os.Chdir(tempProject); err != nil {
   372→				t.Fatalf("Failed to chdir: %v", err)
   373→			}
   374→
   375→			// Create project config with test content
   376→			createTempConfigFile(t, tempProject, tt.configContent)
   377→
   378→			// Load config
   379→			_, err := Load(nil)
   380→
   381→			if tt.wantError {
   382→				if err == nil {
   383→					t.Errorf("Load() returned no error, want error containing %q", tt.errorContains)
   384→				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
   385→					t.Errorf("Load() error = %q, want error containing %q", err.Error(), tt.errorContains)
   386→				}
   387→			} else {
   388→				if err != nil {
   389→					t.Errorf("Load() returned error: %v, want no error", err)
   390→				}
   391→			}
   392→		})
   393→	}
   394→}
   395→
   396→// TestMissingFileHandling tests that missing config files don't cause errors
   397→func TestMissingFileHandling(t *testing.T) {
   398→	// Save and restore original working directory
   399→	origWd, err := os.Getwd()
   400→	if err != nil {
   401→		t.Fatalf("Failed to get working directory: %v", err)
   402→	}
   403→	defer func() { _ = os.Chdir(origWd) }()
   404→
   405→	// Save and restore original HOME
   406→	origHome := os.Getenv("HOME")
   407→	defer func() { _ = os.Setenv("HOME", origHome) }()
   408→
   409→	tests := []struct {
   410→		name           string
   411→		createUserDir  bool
   412→		createProjDir  bool
   413→		createUserConf bool
   414→		createProjConf bool
   415→		wantError      bool
   416→	}{
   417→		{
   418→			name:           "no config files - no error",
   419→			createUserDir:  false,
   420→			createProjDir:  false,
   421→			createUserConf: false,
   422→			createProjConf: false,
   423→			wantError:      false,
   424→		},
   425→		{
   426→			name:           "only user config exists - no error",
   427→			createUserDir:  true,
   428→			createProjDir:  false,
   429→			createUserConf: true,
   430→			createProjConf: false,
   431→			wantError:      false,
   432→		},
   433→		{
   434→			name:           "only project config exists - no error",
   435→			createUserDir:  false,
   436→			createProjDir:  true,
   437→			createUserConf: false,
   438→			createProjConf: true,
   439→			wantError:      false,
   440→		},
   441→		{
   442→			name:           "both config files exist - no error",
   443→			createUserDir:  true,
   444→			createProjDir:  true,
   445→			createUserConf: true,
   446→			createProjConf: true,
   447→			wantError:      false,
   448→		},
   449→		{
   450→			name:           ".specstory dirs exist but no config files - no error",
   451→			createUserDir:  true,
   452→			createProjDir:  true,
   453→			createUserConf: false,
   454→			createProjConf: false,
   455→			wantError:      false,
   456→		},
   457→	}
   458→
   459→	for _, tt := range tests {
   460→		t.Run(tt.name, func(t *testing.T) {
   461→			// Create temp directories
   462→			tempHome := t.TempDir()
   463→			tempProject := t.TempDir()
   464→
   465→			// Set HOME
   466→			if err := os.Setenv("HOME", tempHome); err != nil {
   467→				t.Fatalf("Failed to set HOME: %v", err)
   468→			}
   469→
   470→			// Change to temp project directory
   471→			if err := os.Chdir(tempProject); err != nil {
   472→				t.Fatalf("Failed to chdir: %v", err)
   473→			}
   474→
   475→			// Create directories if needed
   476→			if tt.createUserDir {
   477→				userSpecstoryDir := filepath.Join(tempHome, SpecStoryDir)
   478→				if err := os.MkdirAll(userSpecstoryDir, 0755); err != nil {
   479→					t.Fatalf("Failed to create user .specstory dir: %v", err)
   480→				}
   481→				if tt.createUserConf {
   482→					configPath := filepath.Join(userSpecstoryDir, ConfigFileName)
   483→					if err := os.WriteFile(configPath, []byte(`output_dir = "/user"`), 0644); err != nil {
   484→						t.Fatalf("Failed to create user config: %v", err)
   485→					}
   486→				}
   487→			}
   488→
   489→			if tt.createProjDir {
   490→				projSpecstoryDir := filepath.Join(tempProject, SpecStoryDir)
   491→				if err := os.MkdirAll(projSpecstoryDir, 0755); err != nil {
   492→					t.Fatalf("Failed to create project .specstory dir: %v", err)
   493→				}
   494→				if tt.createProjConf {
   495→					configPath := filepath.Join(projSpecstoryDir, ConfigFileName)
   496→					if err := os.WriteFile(configPath, []byte(`output_dir = "/project"`), 0644); err != nil {
   497→						t.Fatalf("Failed to create project config: %v", err)
   498→					}
   499→				}
   500→			}
   501→
   502→			// Load config
   503→			_, err := Load(nil)
   504→
   505→			if tt.wantError && err == nil {
   506→				t.Errorf("Load() returned no error, want error")
   507→			}
   508→			if !tt.wantError && err != nil {
   509→				t.Errorf("Load() returned error: %v, want no error", err)
   510→			}
   511→		})
   512→	}
   513→}
   514→
   515→// TestDefaultValues tests that default values are returned when config is empty
   516→func TestDefaultValues(t *testing.T) {
   517→	// Save and restore original working directory
   518→	origWd, err := os.Getwd()
   519→	if err != nil {
   520→		t.Fatalf("Failed to get working directory: %v", err)
   521→	}
   522→	defer func() { _ = os.Chdir(origWd) }()
   523→
   524→	// Save and restore original HOME
   525→	origHome := os.Getenv("HOME")
   526→	defer func() { _ = os.Setenv("HOME", origHome) }()
   527→
   528→	// Create temp directories with no config files
   529→	tempHome := t.TempDir()
   530→	tempProject := t.TempDir()
   531→
   532→	if err := os.Setenv("HOME", tempHome); err != nil {
   533→		t.Fatalf("Failed to set HOME: %v", err)
   534→	}
   535→	if err := os.Chdir(tempProject); err != nil {
   536→		t.Fatalf("Failed to chdir: %v", err)
   537→	}
   538→
   539→	cfg, err := Load(nil)
   540→	if err != nil {
   541→		t.Fatalf("Load() returned error: %v", err)
   542→	}
   543→
   544→	// Test default values
   545→	tests := []struct {
   546→		name     string
   547→		got      bool
   548→		expected bool
   549→	}{
   550→		{"IsVersionCheckEnabled default", cfg.IsVersionCheckEnabled(), true},
   551→		{"IsCloudSyncEnabled default", cfg.IsCloudSyncEnabled(), true},
   552→		{"IsLocalSyncEnabled default", cfg.IsLocalSyncEnabled(), true},
   553→		{"IsAnalyticsEnabled default", cfg.IsAnalyticsEnabled(), true},
   554→		{"IsConsoleEnabled default", cfg.IsConsoleEnabled(), false},
   555→		{"IsLogEnabled default", cfg.IsLogEnabled(), false},
   556→		{"IsDebugEnabled default", cfg.IsDebugEnabled(), false},
   557→		{"IsSilentEnabled default", cfg.IsSilentEnabled(), false},
   558→	}
   559→
   560→	for _, tt := range tests {
   561→		t.Run(tt.name, func(t *testing.T) {
   562→			if tt.got != tt.expected {
   563→				t.Errorf("%s = %v, want %v", tt.name, tt.got, tt.expected)
   564→			}
   565→		})
   566→	}
   567→
   568→	// OutputDir should be empty string (no default path)
   569→	if cfg.GetOutputDir() != "" {
   570→		t.Errorf("GetOutputDir() = %q, want empty string", cfg.GetOutputDir())
   571→	}
   572→}
   573→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:33Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./main.go`

```text
     1→package main
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"os"
     8→	"os/signal"
     9→	"strings"
    10→	"syscall"
    11→	"time"
    12→
    13→	"github.com/charmbracelet/fang"
    14→	"github.com/spf13/cobra"
    15→
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/cloud"
    18→	cmdpkg "github.com/specstoryai/getspecstory/specstory-cli/pkg/cmd" // Aliased to avoid shadowing cobra's `cmd` parameter
    19→
    20→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/config"
    21→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    22→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/provenance"
    23→	sessionpkg "github.com/specstoryai/getspecstory/specstory-cli/pkg/session"
    24→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    25→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/factory"
    26→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/utils"
    27→)
    28→
    29→// The current version of the CLI
    30→var version = "dev" // Replaced with actual version in the production build process
    31→
    32→// Flags / Modes / Options
    33→
    34→// General Options
    35→var noAnalytics bool    // flag to disable usage analytics
    36→var noVersionCheck bool // flag to skip checking for newer versions
    37→var outputDir string    // custom output directory for markdown and debug files
    38→// Sync Options
    39→var noCloudSync bool   // flag to disable cloud sync
    40→var onlyCloudSync bool // flag to skip local markdown writes and only sync to cloud
    41→var printToStdout bool // flag to output markdown to stdout instead of saving (only with -s flag)
    42→var cloudURL string    // custom cloud API URL (hidden flag)
    43→// Authentication Options
    44→var cloudToken string // cloud refresh token for this session only (used by VSC VSIX, bypasses normal login)
    45→// Logging and Debugging Options
    46→var console bool // flag to enable logging to the console
    47→var logFile bool // flag to enable logging to the log file
    48→var debug bool   // flag to enable debug level logging
    49→var silent bool  // flag to enable silent output (no user messages)
    50→// Provenance Options
    51→var provenanceEnabled bool // flag to enable AI provenance tracking
    52→
    53→// Run Mode State
    54→var lastRunSessionID string // tracks the session ID from the most recent run command for deep linking
    55→
    56→// pluralSession returns "session" or "sessions" based on count for proper grammar
    57→func pluralSession(count int) string {
    58→	if count == 1 {
    59→		return "session"
    60→	}
    61→	return "sessions"
    62→}
    63→
    64→// SyncStats tracks the results of a sync operation
    65→type SyncStats struct {
    66→	TotalSessions   int
    67→	SessionsSkipped int // Already up to date
    68→	SessionsUpdated int // Existed but needed update
    69→	SessionsCreated int // Newly created markdown files
    70→}
    71→
    72→// validateFlags checks for mutually exclusive flag combinations
    73→func validateFlags() error {
    74→	if console && silent {
    75→		return utils.ValidationError{Message: "cannot use --console and --silent together. These flags are mutually exclusive"}
    76→	}
    77→	if debug && !console && !logFile {
    78→		return utils.ValidationError{Message: "--debug requires either --console or --log to be specified"}
    79→	}
    80→	if onlyCloudSync && noCloudSync {
    81→		return utils.ValidationError{Message: "cannot use --only-cloud-sync and --no-cloud-sync together. These flags are mutually exclusive"}
    82→	}
    83→	if printToStdout && onlyCloudSync {
    84→		return utils.ValidationError{Message: "cannot use --print and --only-cloud-sync together. These flags are mutually exclusive"}
    85→	}
    86→	if printToStdout && console {
    87→		return utils.ValidationError{Message: "cannot use --print and --console together. Console debug output would interleave with markdown on stdout"}
    88→	}
    89→	return nil
    90→}
    91→
    92→// createRootCommand dynamically creates the root command with provider information
    93→func createRootCommand() *cobra.Command {
    94→	registry := factory.GetRegistry()
    95→	ids := registry.ListIDs()
    96→	providerList := registry.GetProviderList()
    97→
    98→	// Build dynamic examples based on registered providers
    99→	examples := `
   100→# Check terminal coding agents installation
   101→specstory check
   102→
   103→# Run the default agent with auto-saving
   104→specstory run`
   105→
   106→	// Add provider-specific examples if we have providers
   107→	if len(ids) > 0 {
   108→		examples += "\n\n# Run a specific agent with auto-saving"
   109→		for _, id := range ids {
   110→			if provider, _ := registry.Get(id); provider != nil {
   111→				examples += fmt.Sprintf("\nspecstory run %s", id)
   112→			}
   113→		}
   114→
   115→		// Use first provider for custom command example
   116→		examples += fmt.Sprintf("\n\n# Run with custom command\nspecstory run %s -c \"/custom/path/to/agent\"", ids[0])
   117→	}
   118→
   119→	examples += `
   120→
   121→# Generate markdown files for all agent sessions associated with the current directory
   122→specstory sync
   123→
   124→# Generate markdown files for specific agent sessions
   125→specstory sync -s <session-id>
   126→specstory sync -s <session-id-1> -s <session-id-2>
   127→
   128→# Watch for any agent activity in the current directory and generate markdown files
   129→specstory watch`
   130→
   131→	longDesc := `SpecStory is a wrapper for terminal coding agents that auto-saves markdown files of all your chat interactions.`
   132→	if providerList != "No providers registered" {
   133→		longDesc += "\n\nSupported agents: " + providerList + "."
   134→	}
   135→
   136→	return &cobra.Command{
   137→		Use:               "specstory [command]",
   138→		Short:             "SpecStory auto-saves terminal coding agent chat interactions",
   139→		Long:              longDesc,
   140→		Example:           examples,
   141→		SilenceUsage:      true,
   142→		SilenceErrors:     true,
   143→		DisableAutoGenTag: true,
   144→		CompletionOptions: cobra.CompletionOptions{DisableDefaultCmd: true},
   145→		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
   146→			// Validate flags before any other setup
   147→			if err := validateFlags(); err != nil {
   148→				fmt.Println() // Add visual separation before error message for better CLI readability
   149→				return err
   150→			}
   151→
   152→			// Configure logging based on flags
   153→			if console || logFile {
   154→				// Create output config to get proper log path if needed
   155→				var logPath string
   156→				if logFile {
   157→					config, err := utils.SetupOutputConfig(outputDir)
   158→					if err != nil {
   159→						return err
   160→					}
   161→					logPath = config.GetLogPath()
   162→				}
   163→
   164→				// Set up logger
   165→				if err := log.SetupLogger(console, logFile, debug, logPath); err != nil {
   166→					return fmt.Errorf("failed to set up logger: %v", err)
   167→				}
   168→
   169→				// Log startup information
   170→				slog.Info("=== SpecStory Starting ===")
   171→				slog.Info("Version", "version", version)
   172→				slog.Info("Command line", "args", strings.Join(os.Args, " "))
   173→				if cwd, err := os.Getwd(); err == nil {
   174→					slog.Info("Current working directory", "cwd", cwd)
   175→				}
   176→				slog.Info("========================")
   177→			} else {
   178→				// No logging - set up discard logger
   179→				if err := log.SetupLogger(false, false, false, ""); err != nil {
   180→					return err
   181→				}
   182→			}
   183→
   184→			// Set silent mode for user messages
   185→			log.SetSilent(silent)
   186→
   187→			// Initialize cloud sync manager
   188→			cloud.InitSyncManager(!noCloudSync)
   189→			cloud.SetSilent(silent)
   190→			cloud.SetClientVersion(version)
   191→			// Set custom cloud URL if provided (otherwise cloud package uses its default)
   192→			if cloudURL != "" {
   193→				cloud.SetAPIBaseURL(cloudURL)
   194→			}
   195→
   196→			// If --cloud-token flag was provided, verify the refresh token works
   197→			// This bypasses normal authentication and uses the token for this session only
   198→			if cloudToken != "" {
   199→				slog.Info("Using session-only refresh token from --cloud-token flag")
   200→				if err := cloud.SetSessionRefreshToken(cloudToken); err != nil {
   201→					fmt.Fprintln(os.Stderr) // Visual separation
   202→					fmt.Fprintln(os.Stderr, "❌ Failed to authenticate with the provided token:")
   203→					fmt.Fprintf(os.Stderr, "   %v\n", err)
   204→					fmt.Fprintln(os.Stderr)
   205→					fmt.Fprintln(os.Stderr, "💡 The token may be invalid, expired, or revoked.")
   206→					fmt.Fprintln(os.Stderr, "   Please check your token and try again, or use 'specstory login' for interactive authentication.")
   207→					fmt.Fprintln(os.Stderr)
   208→					return fmt.Errorf("authentication failed with provided token")
   209→				}
   210→				if !silent {
   211→					fmt.Println()
   212→					fmt.Println("🔑 Authenticated using provided refresh token (session-only)")
   213→					fmt.Println()
   214→				}
   215→			}
   216→
   217→			// Validate that --only-cloud-sync requires authentication
   218→			if onlyCloudSync && !cloud.IsAuthenticated() {
   219→				return utils.ValidationError{Message: "--only-cloud-sync requires authentication. Please run 'specstory login' first"}
   220→			}
   221→
   222→			return nil
   223→		},
   224→		Run: func(c *cobra.Command, args []string) {
   225→			// Track help command usage (when no command is specified)
   226→			analytics.TrackEvent(analytics.EventHelpCommand, analytics.Properties{
   227→				"help_topic":  "general",
   228→				"help_reason": "requested",
   229→			})
   230→			// If no command is specified, show logo then help
   231→			cmdpkg.DisplayLogoAndHelp(c)
   232→		},
   233→	}
   234→}
   235→
   236→var rootCmd *cobra.Command
   237→
   238→// createRunCommand dynamically creates the run command with provider information
   239→func createRunCommand() *cobra.Command {
   240→	registry := factory.GetRegistry()
   241→	ids := registry.ListIDs()
   242→	providerList := registry.GetProviderList()
   243→
   244→	// Build dynamic examples
   245→	examples := `
   246→# Run default agent with auto-saving
   247→specstory run`
   248→
   249→	if len(ids) > 0 {
   250→		examples += "\n\n# Run specific agent"
   251→		for _, id := range ids {
   252→			examples += fmt.Sprintf("\nspecstory run %s", id)
   253→		}
   254→
   255→		// Use first provider for custom command example
   256→		examples += fmt.Sprintf("\n\n# Run with custom command\nspecstory run %s -c \"/custom/path/to/agent\"", ids[0])
   257→	}
   258→
   259→	examples += `
   260→
   261→# Resume a specific session
   262→specstory run --resume 5c5c2876-febd-4c87-b80c-d0655f1cd3fd
   263→
   264→# Run with custom output directory
   265→specstory run --output-dir ~/my-sessions`
   266→
   267→	// Determine default agent name
   268→	defaultAgent := "the default agent"
   269→	if len(ids) > 0 {
   270→		if provider, err := registry.Get(ids[0]); err == nil {
   271→			defaultAgent = provider.Name()
   272→		}
   273→	}
   274→
   275→	longDesc := fmt.Sprintf(`Launch terminal coding agents in interactive mode with auto-save markdown file generation.
   276→
   277→By default, launches %s. Specify a specific agent ID to use a different agent.`, defaultAgent)
   278→	if providerList != "No providers registered" {
   279→		longDesc += "\n\nAvailable provider IDs: " + providerList + "."
   280→	}
   281→
   282→	return &cobra.Command{
   283→		Use:     "run [provider-id]",
   284→		Aliases: []string{"r"},
   285→		Short:   "Launch terminal coding agents in interactive mode with auto-save",
   286→		Long:    longDesc,
   287→		Example: examples,
   288→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument (provider ID)
   289→		PreRunE: func(cmd *cobra.Command, args []string) error {
   290→			// Get custom command if provided via flag
   291→			customCmd, _ := cmd.Flags().GetString("command")
   292→
   293→			// Validate that -c flag requires a provider
   294→			if customCmd != "" && len(args) == 0 {
   295→				registry := factory.GetRegistry()
   296→				ids := registry.ListIDs()
   297→				example := "specstory run <provider> -c \"/custom/path/to/agent\""
   298→				if len(ids) > 0 {
   299→					example = fmt.Sprintf("specstory run %s -c \"/custom/path/to/agent\"", ids[0])
   300→				}
   301→				return utils.ValidationError{
   302→					Message: "The -c/--command flag requires a provider to be specified.\n" +
   303→						"Example: " + example,
   304→				}
   305→			}
   306→			return nil
   307→		},
   308→		RunE: func(cmd *cobra.Command, args []string) error {
   309→			slog.Info("Running in interactive mode")
   310→
   311→			// Get custom command if provided via flag
   312→			customCmd, _ := cmd.Flags().GetString("command")
   313→
   314→			// Get the provider
   315→			registry := factory.GetRegistry()
   316→			var providerID string
   317→			if len(args) == 0 {
   318→				// Default to first registered provider
   319→				ids := registry.ListIDs()
   320→				if len(ids) > 0 {
   321→					providerID = ids[0]
   322→				} else {
   323→					return fmt.Errorf("no providers registered")
   324→				}
   325→			} else {
   326→				providerID = args[0]
   327→			}
   328→
   329→			provider, err := registry.Get(providerID)
   330→			if err != nil {
   331→				// Provider not found - show helpful error
   332→				fmt.Printf("❌ Provider '%s' is not a valid provider implementation\n\n", providerID)
   333→
   334→				ids := registry.ListIDs()
   335→				if len(ids) > 0 {
   336→					fmt.Println("The registered providers are:")
   337→					for _, id := range ids {
   338→						if p, _ := registry.Get(id); p != nil {
   339→							fmt.Printf("  • %s - %s\n", id, p.Name())
   340→						}
   341→					}
   342→					fmt.Println("\nExample: specstory run " + ids[0])
   343→				}
   344→				return err
   345→			}
   346→
   347→			slog.Info("Launching agent", "provider", provider.Name())
   348→
   349→			// Set the agent provider for analytics
   350→			analytics.SetAgentProviders([]string{provider.Name()})
   351→
   352→			// Setup output configuration
   353→			config, err := utils.SetupOutputConfig(outputDir)
   354→			if err != nil {
   355→				return err
   356→			}
   357→			// Ensure history directory exists for interactive mode
   358→			if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   359→				return err
   360→			}
   361→
   362→			// Initialize project identity
   363→			cwd, err := os.Getwd()
   364→			if err != nil {
   365→				slog.Error("Failed to get current working directory", "error", err)
   366→				return err
   367→			}
   368→			identityManager := utils.NewProjectIdentityManager(cwd)
   369→			if _, err := identityManager.EnsureProjectIdentity(); err != nil {
   370→				// Log error but don't fail the command
   371→				slog.Error("Failed to ensure project identity", "error", err)
   372→			}
   373→
   374→			// Create context for graceful cancellation (Ctrl+C handling)
   375→			ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
   376→			defer cancel()
   377→
   378→			// Start provenance infrastructure before the agent so all file changes are captured
   379→			provenanceEngine, provenanceCleanup, err := provenance.StartEngine(provenanceEnabled)
   380→			if err != nil {
   381→				return err
   382→			}
   383→			defer provenanceCleanup()
   384→
   385→			fsCleanup, err := provenance.StartFSWatcher(ctx, provenanceEngine, cwd)
   386→			if err != nil {
   387→				return err
   388→			}
   389→			defer fsCleanup()
   390→
   391→			// Check authentication for cloud sync
   392→			cmdpkg.CheckAndWarnAuthentication(noCloudSync)
   393→			// Track extension activation
   394→			analytics.TrackEvent(analytics.EventExtensionActivated, nil)
   395→
   396→			// Get resume session ID if provided
   397→			resumeSessionID, _ := cmd.Flags().GetString("resume")
   398→			if resumeSessionID != "" {
   399→				resumeSessionID = strings.TrimSpace(resumeSessionID)
   400→				// Note: Different providers may have different session ID formats
   401→				// Let the provider validate its own format
   402→				slog.Info("Resuming session", "sessionId", resumeSessionID)
   403→			}
   404→
   405→			// Get debug-raw flag value (must be before callback to capture in closure)
   406→			debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   407→			useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   408→			useUTC := !useLocalTimezone
   409→
   410→			// This callback pattern enables real-time processing of agent sessions
   411→			// without blocking the agent's execution. As the agent writes updates to its
   412→			// data files, the provider's watcher detects changes and invokes this callback,
   413→			// allowing immediate markdown generation and cloud sync. Errors are logged but
   414→			// don't stop execution because transient failures (e.g., network issues) shouldn't
   415→			// interrupt the user's coding session.
   416→			sessionCallback := func(session *spi.AgentChatSession) {
   417→				if session == nil {
   418→					return
   419→				}
   420→
   421→				// Track the session ID for deep linking on exit
   422→				lastRunSessionID = session.SessionID
   423→
   424→				// Process the session (write markdown and sync to cloud)
   425→				// Don't show output during interactive run mode
   426→				// This is autosave mode (true)
   427→				_, err := sessionpkg.ProcessSingleSession(session, config, onlyCloudSync, false, true, debugRaw, useUTC)
   428→				if err != nil {
   429→					// Log error but continue - don't fail the whole run
   430→					// In interactive mode, we prioritize keeping the agent running.
   431→					// Failed markdown writes or cloud syncs can be retried later via
   432→					// the sync command, so we just log and continue.
   433→					slog.Error("Failed to process session update",
   434→						"sessionId", session.SessionID,
   435→						"error", err)
   436→				}
   437→
   438→				// Push agent events to provenance engine for correlation
   439→				provenance.ProcessEvents(ctx, provenanceEngine, session)
   440→			}
   441→
   442→			// Execute the agent and watch for updates
   443→			slog.Info("Starting agent execution and monitoring", "provider", provider.Name())
   444→			err = provider.ExecAgentAndWatch(cwd, customCmd, resumeSessionID, debugRaw, sessionCallback)
   445→
   446→			if err != nil {
   447→				slog.Error("Agent execution failed", "provider", provider.Name(), "error", err)
   448→			}
   449→
   450→			return err
   451→		},
   452→	}
   453→}
   454→
   455→var runCmd *cobra.Command
   456→
   457→// createSyncCommand dynamically creates the sync command with provider information
   458→func createSyncCommand() *cobra.Command {
   459→	registry := factory.GetRegistry()
   460→	ids := registry.ListIDs()
   461→	providerList := registry.GetProviderList()
   462→
   463→	// Build dynamic examples
   464→	examples := `
   465→# Sync all agents with activity
   466→specstory sync`
   467→
   468→	if len(ids) > 0 {
   469→		examples += "\n\n# Sync specific agent"
   470→		for _, id := range ids {
   471→			examples += fmt.Sprintf("\nspecstory sync %s", id)
   472→		}
   473→	}
   474→
   475→	examples += `
   476→
   477→# Sync a specific session by UUID
   478→specstory sync -s <session-id>
   479→
   480→# Sync multiple sessions
   481→specstory sync -s <session-id-1> -s <session-id-2> -s <session-id-3>
   482→
   483→# Output session markdown to stdout without saving
   484→specstory sync -s <session-id> --print
   485→
   486→# Output multiple sessions to stdout
   487→specstory sync -s <session-id-1> -s <session-id-2> --print
   488→
   489→# Sync all sessions for the current directory, with console output
   490→specstory sync --console
   491→
   492→# Sync all sessions for the current directory, with a log file
   493→specstory sync --log`
   494→
   495→	longDesc := `Create or update markdown files for the agent sessions in the current working directory.
   496→
   497→By default, syncs all registered providers that have activity.
   498→Provide a specific agent ID to sync a specific provider.`
   499→	if providerList != "No providers registered" {
   500→		longDesc += "\n\nAvailable provider IDs: " + providerList + "."
   501→	}
   502→
   503→	return &cobra.Command{
   504→		Use:     "sync [provider-id]",
   505→		Aliases: []string{"s"},
   506→		Short:   "Sync markdown files for terminal coding agent sessions",
   507→		Long:    longDesc,
   508→		Example: examples,
   509→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument (provider ID)
   510→		PreRunE: func(cmd *cobra.Command, args []string) error {
   511→			// Validate that --print requires -s flag
   512→			sessionIDs, _ := cmd.Flags().GetStringSlice("session")
   513→			if printToStdout && len(sessionIDs) == 0 {
   514→				return utils.ValidationError{Message: "--print requires the -s/--session flag to specify which sessions to output"}
   515→			}
   516→			return nil
   517→		},
   518→		RunE: func(cmd *cobra.Command, args []string) error {
   519→			// Get session IDs if provided via flag
   520→			sessionIDs, _ := cmd.Flags().GetStringSlice("session")
   521→
   522→			// Handle specific session sync if -s flag is provided
   523→			if len(sessionIDs) > 0 {
   524→				return syncSpecificSessions(cmd, args, sessionIDs)
   525→			}
   526→
   527→			slog.Info("Running sync command")
   528→			registry := factory.GetRegistry()
   529→
   530→			// Check if user specified a provider
   531→			if len(args) > 0 {
   532→				// Sync specific provider
   533→				return syncSingleProvider(registry, args[0], cmd)
   534→			} else {
   535→				// Sync all providers with activity
   536→				return syncAllProviders(registry, cmd)
   537→			}
   538→		},
   539→	}
   540→}
   541→
   542→// syncSpecificSessions syncs one or more sessions by their IDs
   543→// When printToStdout is set, outputs markdown to stdout instead of saving to files.
   544→// args[0] is the optional provider ID
   545→func syncSpecificSessions(cmd *cobra.Command, args []string, sessionIDs []string) error {
   546→	if len(sessionIDs) == 1 {
   547→		slog.Info("Running single session sync", "sessionId", sessionIDs[0])
   548→	} else {
   549→		slog.Info("Running multiple session sync", "sessionCount", len(sessionIDs))
   550→	}
   551→
   552→	// Get debug-raw flag value
   553→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   554→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   555→	useUTC := !useLocalTimezone
   556→
   557→	cwd, err := os.Getwd()
   558→	if err != nil {
   559→		slog.Error("Failed to get current working directory", "error", err)
   560→		return err
   561→	}
   562→
   563→	// Setup file output and cloud sync (not needed for --print mode)
   564→	var config utils.OutputConfig
   565→	if !printToStdout {
   566→		config, err = utils.SetupOutputConfig(outputDir)
   567→		if err != nil {
   568→			return err
   569→		}
   570→
   571→		identityManager := utils.NewProjectIdentityManager(cwd)
   572→		if _, err := identityManager.EnsureProjectIdentity(); err != nil {
   573→			slog.Error("Failed to ensure project identity", "error", err)
   574→		}
   575→
   576→		cmdpkg.CheckAndWarnAuthentication(noCloudSync)
   577→
   578→		if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   579→			return err
   580→		}
   581→	}
   582→
   583→	registry := factory.GetRegistry()
   584→
   585→	// Track statistics for summary output
   586→	var successCount, notFoundCount, errorCount int
   587→	var lastError error
   588→
   589→	// Resolve provider once if specified (fail fast if provider not found)
   590→	var specifiedProvider spi.Provider
   591→	if len(args) > 0 {
   592→		providerID := args[0]
   593→		provider, err := registry.Get(providerID)
   594→		if err != nil {
   595→			if !printToStdout {
   596→				fmt.Printf("❌ Provider '%s' not found\n", providerID)
   597→			}
   598→			return fmt.Errorf("provider '%s' not found: %w", providerID, err)
   599→		}
   600→		specifiedProvider = provider
   601→	}
   602→
   603→	// Process each session ID
   604→	var printedSessions int // tracks sessions printed to stdout for separator logic
   605→	for _, sessionID := range sessionIDs {
   606→		sessionID = strings.TrimSpace(sessionID)
   607→		if sessionID == "" {
   608→			continue // Skip empty session IDs
   609→		}
   610→
   611→		// Find session across providers
   612→		var session *spi.AgentChatSession
   613→
   614→		// Case A: Provider was specified - use it directly
   615→		if specifiedProvider != nil {
   616→			session, err = specifiedProvider.GetAgentChatSession(cwd, sessionID, debugRaw)
   617→			if err != nil {
   618→				if !printToStdout {
   619→					fmt.Printf("❌ Error getting session '%s' from %s: %v\n", sessionID, specifiedProvider.Name(), err)
   620→				}
   621→				slog.Error("Error getting session from provider", "sessionId", sessionID, "provider", specifiedProvider.Name(), "error", err)
   622→				errorCount++
   623→				lastError = err
   624→				continue
   625→			}
   626→			if session == nil {
   627→				if !printToStdout {
   628→					fmt.Printf("❌ Session '%s' not found in %s\n", sessionID, specifiedProvider.Name())
   629→				}
   630→				slog.Warn("Session not found in provider", "sessionId", sessionID, "provider", specifiedProvider.Name())
   631→				notFoundCount++
   632→				continue
   633→			}
   634→		} else {
   635→			// Case B: No provider specified - try all providers
   636→			providerIDs := registry.ListIDs()
   637→			for _, id := range providerIDs {
   638→				provider, err := registry.Get(id)
   639→				if err != nil {
   640→					continue
   641→				}
   642→
   643→				session, err = provider.GetAgentChatSession(cwd, sessionID, debugRaw)
   644→				if err != nil {
   645→					slog.Debug("Error checking provider for session", "provider", id, "sessionId", sessionID, "error", err)
   646→					continue
   647→				}
   648→				if session != nil {
   649→					if !silent && !printToStdout {
   650→						fmt.Printf("✅ Found session '%s' for %s\n", sessionID, provider.Name())
   651→					}
   652→					break // Found it, don't check other providers
   653→				}
   654→			}
   655→
   656→			if session == nil {
   657→				if !printToStdout {
   658→					fmt.Printf("❌ Session '%s' not found in any provider\n", sessionID)
   659→				}
   660→				slog.Warn("Session not found in any provider", "sessionId", sessionID)
   661→				notFoundCount++
   662→				continue
   663→			}
   664→		}
   665→
   666→		// Process the found session
   667→		if printToStdout {
   668→			sessionpkg.ValidateSessionData(session, debugRaw)
   669→			sessionpkg.WriteDebugSessionData(session, debugRaw)
   670→
   671→			markdownContent, err := sessionpkg.GenerateMarkdownFromAgentSession(session.SessionData, false, useUTC)
   672→			if err != nil {
   673→				slog.Error("Failed to generate markdown", "sessionId", session.SessionID, "error", err)
   674→				analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   675→					"session_id": session.SessionID,
   676→					"error":      err.Error(),
   677→					"mode":       "print",
   678→				})
   679→				errorCount++
   680→				lastError = err
   681→				continue
   682→			}
   683→
   684→			// Separate multiple sessions with a horizontal rule
   685→			if printedSessions > 0 {
   686→				fmt.Print("\n---\n\n")
   687→			}
   688→			fmt.Print(markdownContent)
   689→			printedSessions++
   690→			successCount++
   691→			analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
   692→				"session_id": session.SessionID,
   693→				"mode":       "print",
   694→			})
   695→		} else {
   696→			// Normal sync: write to file and optionally cloud sync
   697→			if _, err := sessionpkg.ProcessSingleSession(session, config, onlyCloudSync, true, false, debugRaw, useUTC); err != nil {
   698→				errorCount++
   699→				lastError = err
   700→			} else {
   701→				successCount++
   702→			}
   703→		}
   704→	}
   705→
   706→	// Print summary if multiple sessions were processed (not for --print mode)
   707→	if !printToStdout && len(sessionIDs) > 1 && !silent {
   708→		fmt.Println()
   709→		fmt.Println("📊 Session sync summary:")
   710→		fmt.Printf("  ✅ %d %s successfully synced\n", successCount, pluralSession(successCount))
   711→		if notFoundCount > 0 {
   712→			fmt.Printf("  ❌ %d %s not found\n", notFoundCount, pluralSession(notFoundCount))
   713→		}
   714→		if errorCount > 0 {
   715→			fmt.Printf("  ❌ %d %s failed with errors\n", errorCount, pluralSession(errorCount))
   716→		}
   717→		fmt.Println()
   718→	}
   719→
   720→	// Return error if any sessions failed
   721→	if errorCount > 0 || (notFoundCount > 0 && successCount == 0) {
   722→		if lastError != nil {
   723→			return lastError
   724→		}
   725→		return fmt.Errorf("%d %s not found", notFoundCount, pluralSession(notFoundCount))
   726→	}
   727→
   728→	return nil
   729→}
   730→
   731→// preloadBulkSessionSizesIfNeeded optimizes bulk syncs by fetching all session sizes upfront.
   732→// This avoids making individual HEAD requests for each session during sync operations.
   733→//
   734→// The function only performs the preload if:
   735→//   - Cloud sync is enabled (noCloudSync flag is false)
   736→//   - User is authenticated with SpecStory Cloud
   737→//   - A valid projectID can be determined from the identity manager
   738→//
   739→// Parameters:
   740→//   - identityManager: Provides project identity (git_id or workspace_id) for the current project
   741→//
   742→// The preloaded sizes are cached in the SyncManager and shared across all providers since they
   743→// use the same projectID. If the bulk fetch fails or if projectID cannot be determined, individual
   744→// sessions will gracefully fall back to HEAD requests during sync.
   745→//
   746→// This function is safe to call multiple times but should typically be called once before processing
   747→// multiple sessions in batch sync operations.
   748→func preloadBulkSessionSizesIfNeeded(identityManager *utils.ProjectIdentityManager) {
   749→	// Skip if cloud sync is disabled or user is not authenticated
   750→	if noCloudSync || !cloud.IsAuthenticated() {
   751→		return
   752→	}
   753→
   754→	// Get projectID from identity manager - required for cloud sync
   755→	projectID, err := identityManager.GetProjectID()
   756→	if err != nil {
   757→		slog.Warn("Cannot preload session sizes: failed to get project ID", "error", err)
   758→		return
   759→	}
   760→
   761→	// Preload bulk sizes once - shared across all providers since they use same projectID
   762→	if syncMgr := cloud.GetSyncManager(); syncMgr != nil {
   763→		syncMgr.PreloadSessionSizes(projectID)
   764→	} else {
   765→		slog.Warn("Cannot preload session sizes: sync manager is nil despite authentication")
   766→	}
   767→}
   768→
   769→// syncProvider performs the actual sync for a single provider
   770→// Returns (sessionCount, error) for analytics tracking
   771→func syncProvider(provider spi.Provider, providerID string, config utils.OutputConfig, debugRaw bool, useUTC bool) (int, error) {
   772→	cwd, err := os.Getwd()
   773→	if err != nil {
   774→		slog.Error("Failed to get current working directory", "error", err)
   775→		return 0, err
   776→	}
   777→
   778→	// Create progress callback for parsing phase
   779→	// The callback updates the "Parsing..." line in place with [n/m] progress
   780→	var parseProgress spi.ProgressCallback
   781→	if !silent {
   782→		providerName := provider.Name()
   783→		parseProgress = func(current, total int) {
   784→			fmt.Printf("\rParsing %s sessions [%d/%d]", providerName, current, total)
   785→			_ = os.Stdout.Sync()
   786→		}
   787→	}
   788→
   789→	// Get all sessions from the provider
   790→	sessions, err := provider.GetAgentChatSessions(cwd, debugRaw, parseProgress)
   791→	if err != nil {
   792→		return 0, fmt.Errorf("failed to get sessions: %w", err)
   793→	}
   794→
   795→	sessionCount := len(sessions)
   796→
   797→	if sessionCount == 0 && !silent {
   798→		// This comes after "Parsing..." message, on the same line
   799→		fmt.Printf(", no non-empty sessions found for %s\n", provider.Name())
   800→		fmt.Println()
   801→		return 0, nil
   802→	}
   803→
   804→	if !silent {
   805→		fmt.Printf("\nSyncing markdown files for %s", provider.Name())
   806→	}
   807→
   808→	// Initialize statistics
   809→	stats := &SyncStats{
   810→		TotalSessions: sessionCount,
   811→	}
   812→
   813→	historyPath := config.GetHistoryDir()
   814→
   815→	// Process each session
   816→	for i := range sessions {
   817→		session := &sessions[i]
   818→		sessionpkg.ValidateSessionData(session, debugRaw)
   819→		sessionpkg.WriteDebugSessionData(session, debugRaw)
   820→
   821→		// Generate markdown from SessionData
   822→		markdownContent, err := sessionpkg.GenerateMarkdownFromAgentSession(session.SessionData, false, useUTC)
   823→		if err != nil {
   824→			slog.Error("Failed to generate markdown from SessionData",
   825→				"sessionId", session.SessionID,
   826→				"error", err)
   827→			// Track sync error
   828→			analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   829→				"session_id": session.SessionID,
   830→				"error":      err.Error(),
   831→			})
   832→			continue
   833→		}
   834→
   835→		// Generate filename from timestamp and slug
   836→		fileFullPath := sessionpkg.BuildSessionFilePath(session, historyPath, useUTC)
   837→
   838→		// Check if file already exists with same content
   839→		identicalContent := false
   840→		fileExists := false
   841→		if existingContent, err := os.ReadFile(fileFullPath); err == nil {
   842→			fileExists = true
   843→			if string(existingContent) == markdownContent {
   844→				identicalContent = true
   845→				slog.Info("Markdown file already exists with same content, skipping write",
   846→					"sessionId", session.SessionID,
   847→					"path", fileFullPath)
   848→			}
   849→		}
   850→
   851→		// Write file if needed (skip if only-cloud-sync is enabled)
   852→		if !onlyCloudSync {
   853→			if !identicalContent {
   854→				// Ensure history directory exists (handles deletion during long-running sync)
   855→				if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   856→					slog.Error("Failed to ensure history directory", "error", err)
   857→					continue
   858→				}
   859→				err := os.WriteFile(fileFullPath, []byte(markdownContent), 0644)
   860→				if err != nil {
   861→					slog.Error("Error writing markdown file",
   862→						"sessionId", session.SessionID,
   863→						"error", err)
   864→					// Track sync error
   865→					analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   866→						"session_id":      session.SessionID,
   867→						"error":           err.Error(),
   868→						"only_cloud_sync": onlyCloudSync,
   869→					})
   870→					continue
   871→				}
   872→				slog.Info("Successfully wrote file",
   873→					"sessionId", session.SessionID,
   874→					"path", fileFullPath)
   875→
   876→				// Track successful sync
   877→				if !fileExists {
   878→					analytics.TrackEvent(analytics.EventSyncMarkdownNew, analytics.Properties{
   879→						"session_id":      session.SessionID,
   880→						"only_cloud_sync": onlyCloudSync,
   881→					})
   882→				} else {
   883→					analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
   884→						"session_id":      session.SessionID,
   885→						"only_cloud_sync": onlyCloudSync,
   886→					})
   887→				}
   888→			}
   889→
   890→			// Update statistics for normal mode
   891→			if identicalContent {
   892→				stats.SessionsSkipped++
   893→			} else if fileExists {
   894→				stats.SessionsUpdated++
   895→			} else {
   896→				stats.SessionsCreated++
   897→			}
   898→		} else {
   899→			// In cloud-only mode, count as skipped since no local file operation occurred
   900→			stats.SessionsSkipped++
   901→			slog.Info("Skipping local file write (only-cloud-sync mode)",
   902→				"sessionId", session.SessionID)
   903→		}
   904→
   905→		// Trigger cloud sync with provider-specific data
   906→		// Manual sync command: perform immediate sync with HEAD check (not autosave mode)
   907→		// In only-cloud-sync mode: always sync
   908→		cloud.SyncSessionToCloud(session.SessionID, fileFullPath, markdownContent, []byte(session.RawData), provider.Name(), false)
   909→
   910→		// Print progress with [n/m] format
   911→		if !silent {
   912→			fmt.Printf("\rSyncing markdown files for %s [%d/%d]", provider.Name(), i+1, sessionCount)
   913→			_ = os.Stdout.Sync()
   914→		}
   915→	}
   916→
   917→	// Print newline after progress
   918→	if !silent && sessionCount > 0 && !onlyCloudSync {
   919→		fmt.Println()
   920→
   921→		// Calculate actual total of processed sessions
   922→		actualTotal := stats.SessionsSkipped + stats.SessionsUpdated + stats.SessionsCreated
   923→
   924→		// Print summary message with proper pluralization
   925→		fmt.Printf("\n%s✅ %s sync complete!%s 📊 %s%d%s %s processed\n",
   926→			log.ColorBoldGreen, provider.Name(), log.ColorReset,
   927→			log.ColorBoldCyan, actualTotal, log.ColorReset, pluralSession(actualTotal))
   928→		fmt.Println()
   929→
   930→		fmt.Printf("  ⏭️ %s%d %s up to date (skipped)%s\n",
   931→			log.ColorCyan, stats.SessionsSkipped, pluralSession(stats.SessionsSkipped), log.ColorReset)
   932→		fmt.Printf("  ♻️ %s%d %s updated%s\n",
   933→			log.ColorYellow, stats.SessionsUpdated, pluralSession(stats.SessionsUpdated), log.ColorReset)
   934→		fmt.Printf("  ✨ %s%d new %s created%s\n",
   935→			log.ColorGreen, stats.SessionsCreated, pluralSession(stats.SessionsCreated), log.ColorReset)
   936→		fmt.Println()
   937→	}
   938→
   939→	return sessionCount, nil
   940→}
   941→
   942→// syncAllProviders syncs all providers that have activity in the current directory
   943→func syncAllProviders(registry *factory.Registry, cmd *cobra.Command) error {
   944→	// Get debug-raw flag value
   945→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   946→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   947→	useUTC := !useLocalTimezone
   948→
   949→	cwd, err := os.Getwd()
   950→	if err != nil {
   951→		slog.Error("Failed to get current working directory", "error", err)
   952→		return err
   953→	}
   954→
   955→	providerIDs := registry.ListIDs()
   956→	providersWithActivity := []string{}
   957→
   958→	// Check each provider for activity
   959→	for _, id := range providerIDs {
   960→		provider, err := registry.Get(id)
   961→		if err != nil {
   962→			slog.Warn("Failed to get provider", "id", id, "error", err)
   963→			continue
   964→		}
   965→
   966→		if provider.DetectAgent(cwd, false) {
   967→			providersWithActivity = append(providersWithActivity, id)
   968→		}
   969→	}
   970→
   971→	// If no providers have activity, show helpful message
   972→	if len(providersWithActivity) == 0 {
   973→		if !silent {
   974→			fmt.Println() // Add visual separation
   975→			log.UserWarn("No coding agent activity found for this project directory.\n\n")
   976→
   977→			log.UserMessage("We checked for activity in '%s' from the following agents:\n", cwd)
   978→			for _, id := range providerIDs {
   979→				if provider, err := registry.Get(id); err == nil {
   980→					log.UserMessage("- %s\n", provider.Name())
   981→				}
   982→			}
   983→			log.UserMessage("\nBut didn't find any activity.\n\n")
   984→
   985→			log.UserMessage("To fix this:\n")
   986→			log.UserMessage("  1. Run 'specstory run' to start the default agent in this directory\n")
   987→			log.UserMessage("  2. Run 'specstory run <agent>' to start a specific agent in this directory\n")
   988→			log.UserMessage("  3. Or run the agent directly first, then try syncing again\n")
   989→			fmt.Println() // Add trailing newline
   990→		}
   991→		return nil
   992→	}
   993→
   994→	// Collect provider names for analytics
   995→	var providerNames []string
   996→	for _, id := range providersWithActivity {
   997→		if provider, err := registry.Get(id); err == nil {
   998→			providerNames = append(providerNames, provider.Name())
   999→		}
  1000→	}
  1001→	analytics.SetAgentProviders(providerNames)
  1002→
  1003→	// Setup output configuration (once for all providers)
  1004→	config, err := utils.SetupOutputConfig(outputDir)
  1005→	if err != nil {
  1006→		return err
  1007→	}
  1008→
  1009→	// Initialize project identity (once for all providers)
  1010→	identityManager := utils.NewProjectIdentityManager(cwd)
  1011→	if _, err := identityManager.EnsureProjectIdentity(); err != nil {
  1012→		slog.Error("Failed to ensure project identity", "error", err)
  1013→	}
  1014→
  1015→	// Check authentication for cloud sync (once)
  1016→	cmdpkg.CheckAndWarnAuthentication(noCloudSync)
  1017→
  1018→	// Ensure history directory exists (once)
  1019→	if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
  1020→		return err
  1021→	}
  1022→
  1023→	// Preload session sizes for batch sync optimization (ONCE for all providers)
  1024→	preloadBulkSessionSizesIfNeeded(identityManager)
  1025→
  1026→	// Sync each provider with activity
  1027→	totalSessionCount := 0
  1028→	var lastError error
  1029→
  1030→	for _, id := range providersWithActivity {
  1031→		provider, err := registry.Get(id)
  1032→		if err != nil {
  1033→			continue
  1034→		}
  1035→
  1036→		if !silent {
  1037→			fmt.Printf("\nParsing %s sessions", provider.Name())
  1038→		}
  1039→
  1040→		sessionCount, err := syncProvider(provider, id, config, debugRaw, useUTC)
  1041→		totalSessionCount += sessionCount
  1042→
  1043→		if err != nil {
  1044→			lastError = err
  1045→			slog.Error("Error syncing provider", "provider", id, "error", err)
  1046→		}
  1047→	}
  1048→
  1049→	// Track overall analytics
  1050→	if lastError != nil {
  1051→		analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
  1052→			"provider":      "all",
  1053→			"error":         lastError.Error(),
  1054→			"session_count": totalSessionCount,
  1055→		})
  1056→		// Brief delay to ensure error event is sent before exit
  1057→		// TODO: This is a workaround for async analytics - should be fixed properly
  1058→		time.Sleep(500 * time.Millisecond)
  1059→	} else {
  1060→		analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
  1061→			"provider":      "all",
  1062→			"session_count": totalSessionCount,
  1063→		})
  1064→	}
  1065→
  1066→	return lastError
  1067→}
  1068→
  1069→// syncSingleProvider syncs a specific provider
  1070→func syncSingleProvider(registry *factory.Registry, providerID string, cmd *cobra.Command) error {
  1071→	// Get debug-raw flag value
  1072→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
  1073→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
  1074→	useUTC := !useLocalTimezone
  1075→
  1076→	provider, err := registry.Get(providerID)
  1077→	if err != nil {
  1078→		// Provider not found - show helpful error
  1079→		fmt.Printf("❌ Provider '%s' is not a valid provider implementation\n\n", providerID)
  1080→
  1081→		ids := registry.ListIDs()
  1082→		if len(ids) > 0 {
  1083→			fmt.Println("The registered providers are:")
  1084→			for _, id := range ids {
  1085→				if p, _ := registry.Get(id); p != nil {
  1086→					fmt.Printf("  • %s - %s\n", id, p.Name())
  1087→				}
  1088→			}
  1089→			fmt.Println("\nExample: specstory sync " + ids[0])
  1090→		}
  1091→		return err
  1092→	}
  1093→
  1094→	// Set the agent provider for analytics
  1095→	analytics.SetAgentProviders([]string{provider.Name()})
  1096→
  1097→	cwd, err := os.Getwd()
  1098→	if err != nil {
  1099→		slog.Error("Failed to get current working directory", "error", err)
  1100→		return err
  1101→	}
  1102→
  1103→	// Check if provider has activity, with helpful output if not
  1104→	if !provider.DetectAgent(cwd, true) {
  1105→		// Provider already output helpful message
  1106→		return nil
  1107→	}
  1108→
  1109→	// Setup output configuration
  1110→	config, err := utils.SetupOutputConfig(outputDir)
  1111→	if err != nil {
  1112→		return err
  1113→	}
  1114→
  1115→	// Initialize project identity
  1116→	identityManager := utils.NewProjectIdentityManager(cwd)
  1117→	if _, err := identityManager.EnsureProjectIdentity(); err != nil {
  1118→		slog.Error("Failed to ensure project identity", "error", err)
  1119→	}
  1120→
  1121→	// Check authentication for cloud sync
  1122→	cmdpkg.CheckAndWarnAuthentication(noCloudSync)
  1123→
  1124→	// Ensure history directory exists
  1125→	if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
  1126→		return err
  1127→	}
  1128→
  1129→	// Preload session sizes for batch sync optimization
  1130→	preloadBulkSessionSizesIfNeeded(identityManager)
  1131→
  1132→	if !silent {
  1133→		fmt.Printf("\nParsing %s sessions", provider.Name())
  1134→	}
  1135→
  1136→	// Perform the sync
  1137→	sessionCount, syncErr := syncProvider(provider, providerID, config, debugRaw, useUTC)
  1138→
  1139→	// Track analytics
  1140→	if syncErr != nil {
  1141→		analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
  1142→			"provider":      providerID,
  1143→			"error":         syncErr.Error(),
  1144→			"session_count": sessionCount,
  1145→		})
  1146→		// Brief delay to ensure error event is sent before exit
  1147→		// TODO: This is a workaround for async analytics - should be fixed properly
  1148→		time.Sleep(500 * time.Millisecond)
  1149→	} else {
  1150→		analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
  1151→			"provider":      providerID,
  1152→			"session_count": sessionCount,
  1153→		})
  1154→	}
  1155→
  1156→	return syncErr
  1157→}
  1158→
  1159→var syncCmd *cobra.Command
  1160→
  1161→// Main entry point for the CLI
  1162→func main() {
  1163→	// Parse critical flags early by manually checking os.Args
  1164→	// This is necessary because cobra's ParseFlags doesn't work correctly before subcommands are added
  1165→	args := os.Args[1:]
  1166→	for i := 0; i < len(args); i++ {
  1167→		arg := args[i]
  1168→		switch arg {
  1169→		case "--no-usage-analytics":
  1170→			noAnalytics = true
  1171→		case "--console":
  1172→			console = true
  1173→		case "--log":
  1174→			logFile = true
  1175→		case "--debug":
  1176→			debug = true
  1177→		case "--silent":
  1178→			silent = true
  1179→		case "--no-version-check":
  1180→			noVersionCheck = true
  1181→		case "--output-dir":
  1182→			// Handle --output-dir <value> format (space-separated)
  1183→			if i+1 < len(args) && !strings.HasPrefix(args[i+1], "-") {
  1184→				outputDir = args[i+1]
  1185→				i++ // Skip the value in next iteration
  1186→			}
  1187→		}
  1188→		// Handle --output-dir=value format
  1189→		if strings.HasPrefix(arg, "--output-dir=") {
  1190→			outputDir = strings.TrimPrefix(arg, "--output-dir=")
  1191→		}
  1192→	}
  1193→
  1194→	// Load configuration early (before logging setup) so TOML settings can affect logging
  1195→	// Priority: CLI flags > local project config > user-level config
  1196→	cfg, cfgErr := config.Load(&config.CLIOverrides{
  1197→		OutputDir:      outputDir,
  1198→		NoVersionCheck: noVersionCheck,
  1199→		NoCloudSync:    noCloudSync,
  1200→		OnlyCloudSync:  onlyCloudSync,
  1201→		Console:        console,
  1202→		Log:            logFile,
  1203→		Debug:          debug,
  1204→		Silent:         silent,
  1205→		NoAnalytics:    noAnalytics,
  1206→	})
  1207→	if cfgErr != nil {
  1208→		// Use fallback empty config if load fails - will log error after logging is set up
  1209→		cfg = &config.Config{}
  1210→	}
  1211→
  1212→	// Apply config values to flag variables so the rest of the code can use them unchanged.
  1213→	// This merges TOML config with CLI flags (CLI flags take precedence via config.Load).
  1214→	if cfg.GetOutputDir() != "" {
  1215→		outputDir = cfg.GetOutputDir()
  1216→	}
  1217→	noVersionCheck = !cfg.IsVersionCheckEnabled()
  1218→	noCloudSync = !cfg.IsCloudSyncEnabled()
  1219→	onlyCloudSync = !cfg.IsLocalSyncEnabled()
  1220→	noAnalytics = !cfg.IsAnalyticsEnabled()
  1221→	console = cfg.IsConsoleEnabled()
  1222→	logFile = cfg.IsLogEnabled()
  1223→	debug = cfg.IsDebugEnabled()
  1224→	silent = cfg.IsSilentEnabled()
  1225→
  1226→	// Set up logging early before creating commands (which access the registry)
  1227→	if console || logFile {
  1228→		var logPath string
  1229→		if logFile {
  1230→			config, _ := utils.SetupOutputConfig(outputDir)
  1231→			logPath = config.GetLogPath()
  1232→		}
  1233→		_ = log.SetupLogger(console, logFile, debug, logPath)
  1234→	} else {
  1235→		// Set up discard logger to prevent default slog output
  1236→		_ = log.SetupLogger(false, false, false, "")
  1237→	}
  1238→
  1239→	// NOW create the commands - after logging is configured
  1240→	rootCmd = createRootCommand()
  1241→	runCmd = createRunCommand()
  1242→	watchCmd := cmdpkg.CreateWatchCommand(&cloudURL)
  1243→	syncCmd = createSyncCommand()
  1244→	listCmd := cmdpkg.CreateListCommand()
  1245→	checkCmd := cmdpkg.CreateCheckCommand()
  1246→	versionCmd := cmdpkg.CreateVersionCommand(version)
  1247→	loginCmd := cmdpkg.CreateLoginCommand(&cloudURL)
  1248→	logoutCmd := cmdpkg.CreateLogoutCommand(&cloudURL)
  1249→
  1250→	// Set version for the automatic version flag
  1251→	rootCmd.Version = version
  1252→
  1253→	// Override the default version template to match our version command output
  1254→	rootCmd.SetVersionTemplate("{{.Version}} (SpecStory)")
  1255→
  1256→	// Set our custom help command (for "specstory help")
  1257→	helpCmd := cmdpkg.CreateHelpCommand(rootCmd)
  1258→	rootCmd.SetHelpCommand(helpCmd)
  1259→
  1260→	// Add the subcommands
  1261→	rootCmd.AddCommand(runCmd)
  1262→	rootCmd.AddCommand(watchCmd)
  1263→	rootCmd.AddCommand(syncCmd)
  1264→	rootCmd.AddCommand(listCmd)
  1265→	rootCmd.AddCommand(versionCmd)
  1266→	rootCmd.AddCommand(checkCmd)
  1267→	rootCmd.AddCommand(loginCmd)
  1268→	rootCmd.AddCommand(logoutCmd)
  1269→
  1270→	// Global flags available on all commands
  1271→	// Use current variable values as defaults so config file values are preserved
  1272→	rootCmd.PersistentFlags().BoolVar(&console, "console", console, "enable error/warn/info output to stdout")
  1273→	rootCmd.PersistentFlags().BoolVar(&logFile, "log", logFile, "write error/warn/info output to ./.specstory/debug/debug.log")
  1274→	rootCmd.PersistentFlags().BoolVar(&debug, "debug", debug, "enable debug-level output (requires --console or --log)")
  1275→	rootCmd.PersistentFlags().BoolVar(&noAnalytics, "no-usage-analytics", noAnalytics, "disable usage analytics")
  1276→	rootCmd.PersistentFlags().BoolVar(&silent, "silent", silent, "suppress all non-error output")
  1277→	rootCmd.PersistentFlags().BoolVar(&noVersionCheck, "no-version-check", noVersionCheck, "skip checking for newer versions")
  1278→	rootCmd.PersistentFlags().StringVar(&cloudToken, "cloud-token", "", "use a SpecStory Cloud refresh token for this session (bypasses login)")
  1279→	_ = rootCmd.PersistentFlags().MarkHidden("cloud-token") // Hidden flag
  1280→
  1281→	// Command-specific flags
  1282→	syncCmd.Flags().StringSliceP("session", "s", []string{}, "optional session IDs to sync (can be specified multiple times, provider-specific format)")
  1283→	syncCmd.Flags().BoolVar(&printToStdout, "print", printToStdout, "output session markdown to stdout instead of saving (requires -s flag)")
  1284→	syncCmd.Flags().StringVar(&outputDir, "output-dir", outputDir, "custom output directory for markdown and debug files (default: ./.specstory/history)")
  1285→	syncCmd.Flags().BoolVar(&noCloudSync, "no-cloud-sync", noCloudSync, "disable cloud sync functionality")
  1286→	syncCmd.Flags().BoolVar(&onlyCloudSync, "only-cloud-sync", onlyCloudSync, "skip local markdown file saves, only upload to cloud (requires authentication)")
  1287→	syncCmd.Flags().StringVar(&cloudURL, "cloud-url", "", "override the default cloud API base URL")
  1288→	_ = syncCmd.Flags().MarkHidden("cloud-url") // Hidden flag
  1289→	syncCmd.Flags().Bool("debug-raw", false, "debug mode to output pretty-printed raw data files")
  1290→	_ = syncCmd.Flags().MarkHidden("debug-raw") // Hidden flag
  1291→	syncCmd.Flags().BoolP("local-time-zone", "", false, "use local timezone for file name and content timestamps (when not present: UTC)")
  1292→
  1293→	runCmd.Flags().BoolVar(&provenanceEnabled, "provenance", false, "enable AI provenance tracking (correlate file changes to agent activity)")
  1294→	_ = runCmd.Flags().MarkHidden("provenance") // Hidden flag
  1295→	runCmd.Flags().StringP("command", "c", "", "custom agent execution command for the provider")
  1296→	runCmd.Flags().String("resume", "", "resume a specific session by ID")
  1297→	runCmd.Flags().StringVar(&outputDir, "output-dir", outputDir, "custom output directory for markdown and debug files (default: ./.specstory/history)")
  1298→	runCmd.Flags().BoolVar(&noCloudSync, "no-cloud-sync", noCloudSync, "disable cloud sync functionality")
  1299→	runCmd.Flags().BoolVar(&onlyCloudSync, "only-cloud-sync", onlyCloudSync, "skip local markdown file saves, only upload to cloud (requires authentication)")
  1300→	runCmd.Flags().StringVar(&cloudURL, "cloud-url", "", "override the default cloud API base URL")
  1301→	_ = runCmd.Flags().MarkHidden("cloud-url") // Hidden flag
  1302→	runCmd.Flags().Bool("debug-raw", false, "debug mode to output pretty-printed raw data files")
  1303→	_ = runCmd.Flags().MarkHidden("debug-raw") // Hidden flag
  1304→	runCmd.Flags().BoolP("local-time-zone", "", false, "use local timezone for file name and content timestamps (when not present: UTC)")
  1305→
  1306→	// Initialize analytics with the full CLI command (unless disabled)
  1307→	slog.Debug("Analytics initialization check", "noAnalytics", noAnalytics, "flag_should_disable", noAnalytics)
  1308→	if !noAnalytics {
  1309→		slog.Debug("Initializing analytics")
  1310→		fullCommand := strings.Join(os.Args, " ")
  1311→		if err := analytics.Init(fullCommand, version); err != nil {
  1312→			// Log error but don't fail - analytics should not break the app
  1313→			slog.Warn("Failed to initialize analytics", "error", err)
  1314→		}
  1315→		defer func() { _ = analytics.Close() }() // Analytics errors shouldn't break the app
  1316→	} else {
  1317→		slog.Debug("Analytics disabled by --no-usage-analytics flag")
  1318→	}
  1319→
  1320→	// Log config load error after logging is set up
  1321→	if cfgErr != nil {
  1322→		slog.Warn("Failed to load config file, using defaults", "error", cfgErr)
  1323→	}
  1324→
  1325→	// Check for updates (blocking)
  1326→	utils.CheckForUpdates(version, noVersionCheck, silent)
  1327→
  1328→	// Ensure proper cleanup and logging on exit
  1329→	defer func() {
  1330→		if r := recover(); r != nil {
  1331→			slog.Error("=== SpecStory PANIC ===", "panic", r)
  1332→			// Still try to wait for cloud sync even on panic
  1333→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1334→			log.CloseLogger()
  1335→			panic(r) // Re-panic after logging
  1336→		}
  1337→		// Wait for cloud sync operations to complete before exiting
  1338→		cloudStats := cloud.Shutdown(cloud.CloudSyncTimeout)
  1339→
  1340→		// Track cloud sync analytics if we have stats
  1341→		if cloudStats != nil {
  1342→			// Calculate total attempted (all sessions that started sync)
  1343→			totalCloudSessions := cloudStats.SessionsAttempted
  1344→
  1345→			// Track cloud sync completion event
  1346→			if cloudStats.SessionsUpdated > 0 || cloudStats.SessionsCreated > 0 || cloudStats.SessionsErrored > 0 || cloudStats.SessionsTimedOut > 0 {
  1347→				analytics.TrackEvent(analytics.EventCloudSyncComplete, analytics.Properties{
  1348→					"sessions_created":   cloudStats.SessionsCreated,
  1349→					"sessions_updated":   cloudStats.SessionsUpdated,
  1350→					"sessions_skipped":   cloudStats.SessionsSkipped,
  1351→					"sessions_errored":   cloudStats.SessionsErrored,
  1352→					"sessions_timed_out": cloudStats.SessionsTimedOut,
  1353→					"total":              totalCloudSessions,
  1354→				})
  1355→			}
  1356→
  1357→			// Display cloud sync stats if not in silent mode
  1358→			if !silent && totalCloudSessions > 0 {
  1359→				fmt.Println() // Visual separation from provider sync output
  1360→
  1361→				// Determine if sync was complete or incomplete based on errors/timeouts
  1362→				if cloudStats.SessionsErrored > 0 || cloudStats.SessionsTimedOut > 0 {
  1363→					fmt.Printf("❌ Cloud sync incomplete! 📊 %s%d%s %s processed\n",
  1364→						log.ColorBoldCyan, totalCloudSessions, log.ColorReset, pluralSession(int(totalCloudSessions)))
  1365→				} else {
  1366→					fmt.Printf("☁️  Cloud sync complete! 📊 %s%d%s %s processed\n",
  1367→						log.ColorBoldCyan, totalCloudSessions, log.ColorReset, pluralSession(int(totalCloudSessions)))
  1368→				}
  1369→				fmt.Println()
  1370→
  1371→				fmt.Printf("  ⏭️ %s%d %s up to date (skipped)%s\n",
  1372→					log.ColorCyan, cloudStats.SessionsSkipped, pluralSession(int(cloudStats.SessionsSkipped)), log.ColorReset)
  1373→				fmt.Printf("  ♻️ %s%d %s updated%s\n",
  1374→					log.ColorYellow, cloudStats.SessionsUpdated, pluralSession(int(cloudStats.SessionsUpdated)), log.ColorReset)
  1375→				fmt.Printf("  ✨ %s%d new %s created%s\n",
  1376→					log.ColorGreen, cloudStats.SessionsCreated, pluralSession(int(cloudStats.SessionsCreated)), log.ColorReset)
  1377→
  1378→				// Only show errors if there were any
  1379→				if cloudStats.SessionsErrored > 0 {
  1380→					fmt.Printf("  ❌ %s%d %s errored%s\n",
  1381→						log.ColorRed, cloudStats.SessionsErrored, pluralSession(int(cloudStats.SessionsErrored)), log.ColorReset)
  1382→				}
  1383→
  1384→				// Only show timed out sessions if there were any
  1385→				if cloudStats.SessionsTimedOut > 0 {
  1386→					fmt.Printf("  ⏱️  %s%d %s timed out%s\n",
  1387→						log.ColorRed, cloudStats.SessionsTimedOut, pluralSession(int(cloudStats.SessionsTimedOut)), log.ColorReset)
  1388→				}
  1389→				fmt.Println()
  1390→
  1391→				// Display link to SpecStory Cloud (deep link to session if from run command)
  1392→				cwd, cwdErr := os.Getwd()
  1393→				if cwdErr == nil {
  1394→					identityManager := utils.NewProjectIdentityManager(cwd)
  1395→					if projectID, err := identityManager.GetProjectID(); err == nil {
  1396→						fmt.Printf("💡 Search and chat with your AI conversation history at:\n")
  1397→						if lastRunSessionID != "" {
  1398→							// Deep link to the specific session from run command
  1399→							fmt.Printf("   %shttps://cloud.specstory.com/projects/%s/sessions/%s%s\n\n",
  1400→								log.ColorBoldCyan, projectID, lastRunSessionID, log.ColorReset)
  1401→						} else {
  1402→							// Link to project overview for sync command
  1403→							fmt.Printf("   %shttps://cloud.specstory.com/projects/%s%s\n\n",
  1404→								log.ColorBoldCyan, projectID, log.ColorReset)
  1405→						}
  1406→					}
  1407→				}
  1408→			}
  1409→		}
  1410→
  1411→		if console || logFile {
  1412→			slog.Info("=== SpecStory Exiting ===", "code", 0, "status", "normal termination")
  1413→		}
  1414→		log.CloseLogger()
  1415→	}()
  1416→
  1417→	if err := fang.Execute(context.Background(), rootCmd, fang.WithVersion(version)); err != nil {
  1418→		// Check if we're running the check command by looking at the executed command
  1419→		executedCmd, _, _ := rootCmd.Find(os.Args[1:])
  1420→		if executedCmd == checkCmd {
  1421→			if console || logFile {
  1422→				slog.Error("=== SpecStory Exiting ===", "code", 2, "status", "agent execution failure")
  1423→				slog.Error("Error", "error", err)
  1424→			}
  1425→			// For check command, the error details are handled by checkSingleProvider/checkAllProviders
  1426→			// So we just exit silently here
  1427→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1428→			os.Exit(2)
  1429→		} else {
  1430→			if console || logFile {
  1431→				slog.Error("=== SpecStory Exiting ===", "code", 1, "status", "error")
  1432→				slog.Error("Error", "error", err)
  1433→			}
  1434→			fmt.Fprintln(os.Stderr) // Visual separation makes error output more noticeable
  1435→
  1436→			// Only show usage for actual command/flag errors from Cobra
  1437→			// These are errors like "unknown command", "unknown flag", "invalid argument", etc.
  1438→			// For all other errors (authentication, network, file system, etc.), we should NOT show usage
  1439→			errMsg := err.Error()
  1440→			isCommandError := strings.Contains(errMsg, "unknown command") ||
  1441→				strings.Contains(errMsg, "unknown flag") ||
  1442→				strings.Contains(errMsg, "invalid argument") ||
  1443→				strings.Contains(errMsg, "required flag") ||
  1444→				strings.Contains(errMsg, "accepts") || // e.g., "accepts 1 arg(s), received 2"
  1445→				strings.Contains(errMsg, "no such flag") ||
  1446→				strings.Contains(errMsg, "flag needs an argument")
  1447→
  1448→			if isCommandError {
  1449→				_ = rootCmd.Usage() // Ignore error; we're exiting anyway
  1450→				fmt.Println()       // Add visual separation after usage for better CLI readability
  1451→			}
  1452→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1453→			os.Exit(1)
  1454→		}
  1455→	}
  1456→}
  1457→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:34Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `./` pattern `pkg/cmd/*.go`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/list.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/check.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/help.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/login.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/login_test.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/logout.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/version.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/utils.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/watch.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:34Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `./` pattern `pkg/config/*.go`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:34Z)**_

Now let me search for references to the config package across the codebase:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:34Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 pattern `import.*config`

```text
No files found
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:35Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 pattern `config\.Load|config\.Config`

```text
Found 1 file
main.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:35Z)**_

Now let me read the config loading code and examine the cmd package files to understand the startup initialization:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:36Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/config/config.go`

```text
     1→// Package config provides configuration management for the SpecStory CLI.
     2→// Configuration is loaded with the following priority (highest to lowest):
     3→//  1. CLI flags
     4→//  2. Local project config: .specstory/cli-config.toml
     5→//  3. User-level config: ~/.specstory/cli-config.toml
     6→//
     7→// Note: For telemetry settings, environment variables (OTEL_*) take highest priority
     8→// per OpenTelemetry conventions.
     9→package config
    10→
    11→import (
    12→	"fmt"
    13→	"log/slog"
    14→	"os"
    15→	"path/filepath"
    16→
    17→	"github.com/BurntSushi/toml"
    18→)
    19→
    20→const (
    21→	// ConfigFileName is the name of the configuration file
    22→	ConfigFileName = "cli-config.toml"
    23→	// SpecStoryDir is the directory name for SpecStory files
    24→	SpecStoryDir = ".specstory"
    25→)
    26→
    27→// Config represents the complete CLI configuration
    28→type Config struct {
    29→	// OutputDir is the custom output directory for markdown and debug files
    30→	OutputDir string `toml:"output_dir"`
    31→
    32→	VersionCheck VersionCheckConfig `toml:"version_check"`
    33→	CloudSync    CloudSyncConfig    `toml:"cloud_sync"`
    34→	LocalSync    LocalSyncConfig    `toml:"local_sync"`
    35→	Logging      LoggingConfig      `toml:"logging"`
    36→	Analytics    AnalyticsConfig    `toml:"analytics"`
    37→}
    38→
    39→// VersionCheckConfig holds version check settings
    40→type VersionCheckConfig struct {
    41→	// Enabled controls whether to check for newer versions on startup
    42→	Enabled *bool `toml:"enabled"`
    43→}
    44→
    45→// CloudSyncConfig holds cloud sync settings
    46→type CloudSyncConfig struct {
    47→	// Enabled controls whether cloud sync is active
    48→	Enabled *bool `toml:"enabled"`
    49→}
    50→
    51→// LocalSyncConfig holds local file sync settings
    52→type LocalSyncConfig struct {
    53→	// Enabled controls whether local markdown files are written
    54→	// When false, only cloud sync is performed (equivalent to --only-cloud-sync)
    55→	Enabled *bool `toml:"enabled"`
    56→}
    57→
    58→// LoggingConfig holds logging settings
    59→type LoggingConfig struct {
    60→	// Console enables error/warn/info output to stdout
    61→	Console *bool `toml:"console"`
    62→	// Log enables writing error/warn/info output to .specstory/debug/debug.log
    63→	Log *bool `toml:"log"`
    64→	// Debug enables debug-level output (requires Console or Log)
    65→	Debug *bool `toml:"debug"`
    66→	// Silent suppresses all non-error output
    67→	Silent *bool `toml:"silent"`
    68→}
    69→
    70→// AnalyticsConfig holds analytics settings
    71→type AnalyticsConfig struct {
    72→	// Enabled controls whether usage analytics are sent
    73→	Enabled *bool `toml:"enabled"`
    74→}
    75→
    76→// CLIOverrides holds CLI flag values that override config file settings.
    77→// These are applied after config files are loaded.
    78→type CLIOverrides struct {
    79→	// General
    80→	OutputDir string
    81→
    82→	// Version check
    83→	NoVersionCheck bool
    84→
    85→	// Cloud sync
    86→	NoCloudSync   bool
    87→	OnlyCloudSync bool
    88→
    89→	// Logging
    90→	Console bool
    91→	Log     bool
    92→	Debug   bool
    93→	Silent  bool
    94→
    95→	// Analytics
    96→	NoAnalytics bool
    97→}
    98→
    99→// Load reads configuration from files and CLI flags.
   100→// Priority: CLI flags > local project config > user-level config
   101→//
   102→// Returns an error if a config file exists but cannot be parsed (TOML syntax error)
   103→// or cannot be read (permission denied, I/O error). Missing config files are not
   104→// treated as errors - they are simply skipped.
   105→func Load(cliOverrides *CLIOverrides) (*Config, error) {
   106→	cfg := &Config{}
   107→
   108→	// Load user-level config first (lowest priority)
   109→	userConfigPath := getUserConfigPath()
   110→	if userConfigPath != "" {
   111→		if err := loadTOMLFile(userConfigPath, cfg); err != nil {
   112→			if os.IsNotExist(err) {
   113→				slog.Debug("No user-level config file found", "path", userConfigPath)
   114→			} else {
   115→				// Parse error or permission denied - return error to caller
   116→				return cfg, fmt.Errorf("failed to load user config %s: %w", userConfigPath, err)
   117→			}
   118→		} else {
   119→			slog.Debug("Loaded user-level config", "path", userConfigPath)
   120→		}
   121→	}
   122→
   123→	// Load local project config (overwrites user-level)
   124→	localConfigPath := getLocalConfigPath()
   125→	if localConfigPath != "" {
   126→		if err := loadTOMLFile(localConfigPath, cfg); err != nil {
   127→			if os.IsNotExist(err) {
   128→				slog.Debug("No local project config file found", "path", localConfigPath)
   129→			} else {
   130→				// Parse error or permission denied - return error to caller
   131→				return cfg, fmt.Errorf("failed to load project config %s: %w", localConfigPath, err)
   132→			}
   133→		} else {
   134→			slog.Debug("Loaded local project config", "path", localConfigPath)
   135→		}
   136→	}
   137→
   138→	// Apply CLI flag overrides (highest priority for most settings)
   139→	if cliOverrides != nil {
   140→		applyCLIOverrides(cfg, cliOverrides)
   141→	}
   142→
   143→	return cfg, nil
   144→}
   145→
   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
   147→func getUserConfigPath() string {
   148→	home, err := os.UserHomeDir()
   149→	if err != nil {
   150→		slog.Debug("Could not determine home directory", "error", err)
   151→		return ""
   152→	}
   153→	return filepath.Join(home, SpecStoryDir, ConfigFileName)
   154→}
   155→
   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
   157→func getLocalConfigPath() string {
   158→	cwd, err := os.Getwd()
   159→	if err != nil {
   160→		slog.Debug("Could not determine current directory", "error", err)
   161→		return ""
   162→	}
   163→	return filepath.Join(cwd, SpecStoryDir, ConfigFileName)
   164→}
   165→
   166→// loadTOMLFile reads a TOML file and decodes it into the config struct.
   167→// Fields are merged (later calls overwrite earlier values).
   168→func loadTOMLFile(path string, cfg *Config) error {
   169→	_, err := toml.DecodeFile(path, cfg)
   170→	return err
   171→}
   172→
   173→// applyCLIOverrides applies CLI flag overrides to the config.
   174→func applyCLIOverrides(cfg *Config, o *CLIOverrides) {
   175→	// General
   176→	if o.OutputDir != "" {
   177→		cfg.OutputDir = o.OutputDir
   178→	}
   179→
   180→	// Version check (--no-version-check sets enabled to false)
   181→	if o.NoVersionCheck {
   182→		disabled := false
   183→		cfg.VersionCheck.Enabled = &disabled
   184→	}
   185→
   186→	// Cloud sync (--no-cloud-sync sets enabled to false)
   187→	if o.NoCloudSync {
   188→		disabled := false
   189→		cfg.CloudSync.Enabled = &disabled
   190→	}
   191→
   192→	// Local sync (--only-cloud-sync sets enabled to false)
   193→	if o.OnlyCloudSync {
   194→		disabled := false
   195→		cfg.LocalSync.Enabled = &disabled
   196→	}
   197→
   198→	// Logging flags only override if explicitly set (true)
   199→	if o.Console {
   200→		enabled := true
   201→		cfg.Logging.Console = &enabled
   202→	}
   203→	if o.Log {
   204→		enabled := true
   205→		cfg.Logging.Log = &enabled
   206→	}
   207→	if o.Debug {
   208→		enabled := true
   209→		cfg.Logging.Debug = &enabled
   210→	}
   211→	if o.Silent {
   212→		enabled := true
   213→		cfg.Logging.Silent = &enabled
   214→	}
   215→
   216→	// Analytics (--no-usage-analytics sets enabled to false)
   217→	if o.NoAnalytics {
   218→		disabled := false
   219→		cfg.Analytics.Enabled = &disabled
   220→	}
   221→}
   222→
   223→// --- Getter methods ---
   224→
   225→// GetOutputDir returns the output directory, or empty string to use default.
   226→func (c *Config) GetOutputDir() string {
   227→	return c.OutputDir
   228→}
   229→
   230→// IsVersionCheckEnabled returns whether version check is enabled.
   231→// Defaults to true if not explicitly set.
   232→func (c *Config) IsVersionCheckEnabled() bool {
   233→	if c.VersionCheck.Enabled != nil {
   234→		return *c.VersionCheck.Enabled
   235→	}
   236→	return true // default enabled
   237→}
   238→
   239→// IsCloudSyncEnabled returns whether cloud sync is enabled.
   240→// Defaults to true if not explicitly set.
   241→func (c *Config) IsCloudSyncEnabled() bool {
   242→	if c.CloudSync.Enabled != nil {
   243→		return *c.CloudSync.Enabled
   244→	}
   245→	return true // default enabled
   246→}
   247→
   248→// IsLocalSyncEnabled returns whether local sync is enabled.
   249→// Defaults to true if not explicitly set.
   250→// When false, only cloud sync is performed (equivalent to --only-cloud-sync).
   251→func (c *Config) IsLocalSyncEnabled() bool {
   252→	if c.LocalSync.Enabled != nil {
   253→		return *c.LocalSync.Enabled
   254→	}
   255→	return true // default enabled
   256→}
   257→
   258→// IsConsoleEnabled returns whether console logging is enabled.
   259→// Defaults to false if not explicitly set.
   260→func (c *Config) IsConsoleEnabled() bool {
   261→	if c.Logging.Console != nil {
   262→		return *c.Logging.Console
   263→	}
   264→	return false // default disabled
   265→}
   266→
   267→// IsLogEnabled returns whether file logging is enabled.
   268→// Defaults to false if not explicitly set.
   269→func (c *Config) IsLogEnabled() bool {
   270→	if c.Logging.Log != nil {
   271→		return *c.Logging.Log
   272→	}
   273→	return false // default disabled
   274→}
   275→
   276→// IsDebugEnabled returns whether debug logging is enabled.
   277→// Defaults to false if not explicitly set.
   278→func (c *Config) IsDebugEnabled() bool {
   279→	if c.Logging.Debug != nil {
   280→		return *c.Logging.Debug
   281→	}
   282→	return false // default disabled
   283→}
   284→
   285→// IsSilentEnabled returns whether silent mode is enabled.
   286→// Defaults to false if not explicitly set.
   287→func (c *Config) IsSilentEnabled() bool {
   288→	if c.Logging.Silent != nil {
   289→		return *c.Logging.Silent
   290→	}
   291→	return false // default disabled
   292→}
   293→
   294→// IsAnalyticsEnabled returns whether analytics are enabled.
   295→// Defaults to true if not explicitly set.
   296→func (c *Config) IsAnalyticsEnabled() bool {
   297→	if c.Analytics.Enabled != nil {
   298→		return *c.Analytics.Enabled
   299→	}
   300→	return true // default enabled
   301→}
   302→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:36Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/cmd/utils.go`

```text
     1→package cmd
     2→
     3→import (
     4→	"log/slog"
     5→
     6→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/cloud"
     7→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
     8→)
     9→
    10→// CheckAndWarnAuthentication warns the user if cloud sync is enabled but authentication
    11→// is missing or has failed. Uses log.IsSilent() to respect silent mode.
    12→func CheckAndWarnAuthentication(noCloudSync bool) {
    13→	if !noCloudSync && !cloud.IsAuthenticated() && !log.IsSilent() {
    14→		// Check if this was due to a 401 authentication failure
    15→		if cloud.HadAuthFailure() {
    16→			// Show the specific message for auth failures with orange warning and emoji
    17→			slog.Warn("Cloud sync authentication failed (401)")
    18→			log.UserWarn("⚠️ Unable to authenticate with SpecStory Cloud. This could be due to revoked or expired credentials, or network/server issues.\n")
    19→			log.UserMessage("ℹ️ If this persists, run `specstory logout` then `specstory login` to reset your SpecStory Cloud authentication.\n")
    20→		} else {
    21→			// Regular "not authenticated" message
    22→			msg := "⚠️ Cloud sync not available. You're not authenticated."
    23→			slog.Warn(msg)
    24→			log.UserWarn("%s\n", msg)
    25→			log.UserMessage("ℹ️ Use `specstory login` to authenticate, or `--no-cloud-sync` to skip this warning.\n")
    26→		}
    27→	}
    28→}
    29→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:36Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/cmd/watch.go`

```text
     1→package cmd
     2→
     3→import (
     4→	"context"
     5→	"encoding/json"
     6→	"fmt"
     7→	"log/slog"
     8→	"os"
     9→	"os/signal"
    10→	"strings"
    11→	gosync "sync"
    12→	"syscall"
    13→	"time"
    14→
    15→	"github.com/spf13/cobra"
    16→
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    18→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/cloud"
    19→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    20→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/provenance"
    21→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/session"
    22→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    23→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/factory"
    24→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/schema"
    25→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/utils"
    26→)
    27→
    28→// truncateSessionID shortens a UUID to first5...last5 for display.
    29→// Full IDs are available in --json output; the short form is enough
    30→// to visually distinguish sessions.
    31→func truncateSessionID(id string) string {
    32→	if len(id) <= 13 {
    33→		return id
    34→	}
    35→	return id[:5] + "..." + id[len(id)-5:]
    36→}
    37→
    38→// CreateWatchCommand dynamically creates the watch command with provider information.
    39→// cloudURL binds to the parent's --cloud-url flag so PersistentPreRunE can apply it.
    40→func CreateWatchCommand(cloudURL *string) *cobra.Command {
    41→	registry := factory.GetRegistry()
    42→	ids := registry.ListIDs()
    43→	providerList := registry.GetProviderList()
    44→
    45→	// Build dynamic examples
    46→	examples := `
    47→# Watch all registered agent providers for activity
    48→specstory watch`
    49→
    50→	if len(ids) > 0 {
    51→		examples += "\n\n# Watch for activity from a specific agent"
    52→		for _, id := range ids {
    53→			examples += fmt.Sprintf("\nspecstory watch %s", id)
    54→		}
    55→	}
    56→
    57→	examples += `
    58→
    59→# Watch with custom output directory
    60→specstory watch --output-dir ~/my-sessions`
    61→
    62→	longDesc := `Watch for coding agent activity in the current directory and auto-save markdown files.
    63→
    64→Unlike 'run', this command does not launch a coding agent - it only monitors for agent activity.
    65→Use this when you want to run the agent separately, but still want auto-saved markdown files.
    66→
    67→By default, 'watch' is for activity from all registered agent providers. Specify a specific agent ID to watch for activity from only that agent.`
    68→	if providerList != "No providers registered" {
    69→		longDesc += "\n\nAvailable provider IDs: " + providerList + "."
    70→	}
    71→
    72→	watchCmd := &cobra.Command{
    73→		Use:     "watch [provider-id]",
    74→		Aliases: []string{"w"},
    75→		Short:   "Watch for coding agent activity with auto-save",
    76→		Long:    longDesc,
    77→		Example: examples,
    78→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument (provider ID)
    79→		RunE: func(cmd *cobra.Command, args []string) error {
    80→			slog.Info("Running in watch mode")
    81→
    82→			registry := factory.GetRegistry()
    83→
    84→			// Read flags from the command
    85→			debugRaw, _ := cmd.Flags().GetBool("debug-raw")
    86→			useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
    87→			useUTC := !useLocalTimezone
    88→			jsonOutput, _ := cmd.Flags().GetBool("json")
    89→			outputDir, _ := cmd.Flags().GetString("output-dir")
    90→			noCloudSync, _ := cmd.Flags().GetBool("no-cloud-sync")
    91→			onlyCloudSync, _ := cmd.Flags().GetBool("only-cloud-sync")
    92→			provenanceEnabled, _ := cmd.Flags().GetBool("provenance")
    93→
    94→			// Setup output configuration
    95→			config, err := utils.SetupOutputConfig(outputDir)
    96→			if err != nil {
    97→				return err
    98→			}
    99→
   100→			// Ensure history directory exists for watch mode
   101→			if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   102→				return err
   103→			}
   104→
   105→			// Initialize project identity (needed for cloud sync)
   106→			cwd, err := os.Getwd()
   107→			if err != nil {
   108→				slog.Error("Failed to get current working directory", "error", err)
   109→				return err
   110→			}
   111→			if _, err := utils.NewProjectIdentityManager(cwd).EnsureProjectIdentity(); err != nil {
   112→				// Log error but don't fail the command
   113→				slog.Error("Failed to ensure project identity", "error", err)
   114→			}
   115→
   116→			// Check authentication for cloud sync
   117→			CheckAndWarnAuthentication(noCloudSync)
   118→
   119→			// Validate that --only-cloud-sync requires authentication
   120→			if onlyCloudSync && !cloud.IsAuthenticated() {
   121→				return utils.ValidationError{Message: "--only-cloud-sync requires authentication. Please run 'specstory login' first"}
   122→			}
   123→
   124→			// Start provenance engine if enabled (used in later phases for event correlation)
   125→			provenanceEngine, provenanceCleanup, err := provenance.StartEngine(provenanceEnabled)
   126→			if err != nil {
   127→				return err
   128→			}
   129→			defer provenanceCleanup()
   130→
   131→			providerIDs := registry.ListIDs()
   132→			if len(providerIDs) == 0 {
   133→				return fmt.Errorf("no providers registered")
   134→			}
   135→			if len(args) > 0 {
   136→				providerIDs = []string{args[0]}
   137→			}
   138→
   139→			// Collect provider names for analytics
   140→			providers := make(map[string]spi.Provider)
   141→			for _, id := range providerIDs {
   142→				if provider, err := registry.Get(id); err == nil {
   143→					providers[id] = provider
   144→				} else {
   145→					return fmt.Errorf("no provider %s found", id)
   146→				}
   147→			}
   148→			var providerNames []string
   149→			// Get all provider names from the providers map
   150→			for _, provider := range providers {
   151→				providerNames = append(providerNames, provider.Name())
   152→			}
   153→			analytics.SetAgentProviders(providerNames)
   154→
   155→			// Track watch command activation
   156→			analytics.TrackEvent(analytics.EventWatchActivated, nil)
   157→
   158→			// Create context for graceful cancellation (Ctrl+C handling)
   159→			// This allows providers to clean up resources when user presses Ctrl+C
   160→			ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
   161→			defer cancel()
   162→
   163→			// Start filesystem watcher for provenance correlation if enabled (uses signal context for Ctrl+C)
   164→			fsCleanup, err := provenance.StartFSWatcher(ctx, provenanceEngine, cwd)
   165→			if err != nil {
   166→				return err
   167→			}
   168→			defer fsCleanup()
   169→
   170→			if !log.IsSilent() && !jsonOutput {
   171→				fmt.Println()
   172→				agentWord := "agents"
   173→				if len(providerNames) == 1 {
   174→					agentWord = "agent"
   175→				}
   176→				fmt.Println("👀 Watching for activity from " + agentWord + ": " + strings.Join(providerNames, ", "))
   177→				fmt.Println("   Press Ctrl+C to stop watching")
   178→				fmt.Println()
   179→			}
   180→
   181→			// Track sessions we've seen to suppress initial-scan output.
   182→			// Existing sessions found at startup get their markdown refreshed
   183→			// but don't produce output — only new activity does.
   184→			var seenMu gosync.Mutex
   185→			seenSessions := make(map[string]bool)
   186→
   187→			// Session callback for watch mode output
   188→			sessionCallback := func(providerID string, sess *spi.AgentChatSession) {
   189→				// Check if markdown file already exists to determine if this is an update or creation
   190→				fileFullPath := session.BuildSessionFilePath(sess, config.GetHistoryDir(), useUTC)
   191→				_, fileExistsErr := os.Stat(fileFullPath)
   192→				fileExists := fileExistsErr == nil
   193→
   194→				// Process the session (write markdown and sync to cloud)
   195→				// Don't show output during watch mode
   196→				// This is autosave mode (true)
   197→				markdownSize, err := session.ProcessSingleSession(sess, config, onlyCloudSync, false, true, debugRaw, useUTC)
   198→				if err != nil {
   199→					// Log error but continue - don't fail the whole watch
   200→					// In watch mode, we prioritize keeping the watcher running.
   201→					// Failed markdown writes or cloud syncs can be retried later via
   202→					// the sync command, so we just log and continue.
   203→					slog.Error("Failed to process session update",
   204→						"sessionId", sess.SessionID,
   205→						"provider", providerID,
   206→						"error", err)
   207→					return
   208→				}
   209→
   210→				// Suppress output for existing sessions seen for the first time (initial scan).
   211→				// New sessions (!fileExists) always get output since they represent real activity.
   212→				seenMu.Lock()
   213→				firstSeen := !seenSessions[sess.SessionID]
   214→				seenSessions[sess.SessionID] = true
   215→				seenMu.Unlock()
   216→				if firstSeen && fileExists {
   217→					return
   218→				}
   219→
   220→				// Output formatted line to stdout for watch mode
   221→				if !log.IsSilent() {
   222→					// Determine if this was an update or creation
   223→					action := "updated"
   224→					if !fileExists {
   225→						action = "created"
   226→					}
   227→
   228→					// Get timestamps from session data
   229→					startTime := sess.CreatedAt
   230→					endTime := startTime
   231→					if sess.SessionData != nil && sess.SessionData.UpdatedAt != "" {
   232→						endTime = sess.SessionData.UpdatedAt
   233→					}
   234→
   235→					// Count messages by role
   236→					userPrompts := 0
   237→					agentActivity := 0
   238→					if sess.SessionData != nil {
   239→						for _, exchange := range sess.SessionData.Exchanges {
   240→							for _, msg := range exchange.Messages {
   241→								if msg.Role == schema.RoleUser {
   242→									userPrompts++
   243→								} else {
   244→									agentActivity++
   245→								}
   246→							}
   247→						}
   248→					}
   249→
   250→					// Output the formatted line
   251→					if jsonOutput {
   252→						record := map[string]interface{}{
   253→							"timestamp":          time.Now().Format(time.RFC3339),
   254→							"action":             action,
   255→							"session_id":         sess.SessionID,
   256→							"start_time":         startTime,
   257→							"end_time":           endTime,
   258→							"provider":           providerID,
   259→							"markdown_size":      markdownSize,
   260→							"total_user_prompts": userPrompts,
   261→							"agent_activity":     agentActivity,
   262→						}
   263→						if !onlyCloudSync {
   264→							record["markdown_file"] = fileFullPath
   265→						}
   266→						_ = json.NewEncoder(os.Stdout).Encode(record)
   267→					} else {
   268→						emoji := "♻️"
   269→						if action == "created" {
   270→							emoji = "✨"
   271→						}
   272→						activityWord := "activities"
   273→						if agentActivity == 1 {
   274→							activityWord = "activity"
   275→						}
   276→						promptWord := "prompts"
   277→						if userPrompts == 1 {
   278→							promptWord = "prompt"
   279→						}
   280→						fmt.Printf("  %s  %s  %s · %s · %d %s · %d agent %s\n",
   281→							time.Now().Format("15:04:05"),
   282→							emoji,
   283→							providerID,
   284→							truncateSessionID(sess.SessionID),
   285→							userPrompts,
   286→							promptWord,
   287→							agentActivity,
   288→							activityWord)
   289→					}
   290→				}
   291→
   292→				// Push agent events to provenance engine for correlation
   293→				provenance.ProcessEvents(ctx, provenanceEngine, sess)
   294→			}
   295→
   296→			return utils.WatchProviders(ctx, cwd, providers, debugRaw, sessionCallback)
   297→		},
   298→	}
   299→
   300→	// Watch-specific flags
   301→	watchCmd.Flags().Bool("json", false, "output session updates as JSON lines (one JSON object per line)")
   302→	watchCmd.Flags().String("output-dir", "", "custom output directory for markdown and debug files (default: ./.specstory/history)")
   303→	watchCmd.Flags().Bool("only-cloud-sync", false, "skip local markdown file saves, only upload to cloud (requires authentication)")
   304→	watchCmd.Flags().Bool("no-cloud-sync", false, "disable cloud sync functionality")
   305→	watchCmd.Flags().Bool("debug-raw", false, "debug mode to output pretty-printed raw data files")
   306→	_ = watchCmd.Flags().MarkHidden("debug-raw") // Hidden flag
   307→	watchCmd.Flags().Bool("local-time-zone", false, "use local timezone for file name and content timestamps (when not present: UTC)")
   308→	watchCmd.Flags().Bool("provenance", false, "enable AI provenance tracking (correlate file changes to agent activity)")
   309→	_ = watchCmd.Flags().MarkHidden("provenance") // Hidden flag
   310→	watchCmd.Flags().StringVar(cloudURL, "cloud-url", "", "override the default cloud API base URL")
   311→	_ = watchCmd.Flags().MarkHidden("cloud-url") // Hidden flag
   312→
   313→	return watchCmd
   314→}
   315→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:37Z)**_

Let me check the main.go file to see how config is used:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:38Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./main.go`

```text
     1→package main
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"os"
     8→	"os/signal"
     9→	"strings"
    10→	"syscall"
    11→	"time"
    12→
    13→	"github.com/charmbracelet/fang"
    14→	"github.com/spf13/cobra"
    15→
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/cloud"
    18→	cmdpkg "github.com/specstoryai/getspecstory/specstory-cli/pkg/cmd" // Aliased to avoid shadowing cobra's `cmd` parameter
    19→
    20→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/config"
    21→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    22→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/provenance"
    23→	sessionpkg "github.com/specstoryai/getspecstory/specstory-cli/pkg/session"
    24→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    25→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/factory"
    26→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/utils"
    27→)
    28→
    29→// The current version of the CLI
    30→var version = "dev" // Replaced with actual version in the production build process
    31→
    32→// Flags / Modes / Options
    33→
    34→// General Options
    35→var noAnalytics bool    // flag to disable usage analytics
    36→var noVersionCheck bool // flag to skip checking for newer versions
    37→var outputDir string    // custom output directory for markdown and debug files
    38→// Sync Options
    39→var noCloudSync bool   // flag to disable cloud sync
    40→var onlyCloudSync bool // flag to skip local markdown writes and only sync to cloud
    41→var printToStdout bool // flag to output markdown to stdout instead of saving (only with -s flag)
    42→var cloudURL string    // custom cloud API URL (hidden flag)
    43→// Authentication Options
    44→var cloudToken string // cloud refresh token for this session only (used by VSC VSIX, bypasses normal login)
    45→// Logging and Debugging Options
    46→var console bool // flag to enable logging to the console
    47→var logFile bool // flag to enable logging to the log file
    48→var debug bool   // flag to enable debug level logging
    49→var silent bool  // flag to enable silent output (no user messages)
    50→// Provenance Options
    51→var provenanceEnabled bool // flag to enable AI provenance tracking
    52→
    53→// Run Mode State
    54→var lastRunSessionID string // tracks the session ID from the most recent run command for deep linking
    55→
    56→// pluralSession returns "session" or "sessions" based on count for proper grammar
    57→func pluralSession(count int) string {
    58→	if count == 1 {
    59→		return "session"
    60→	}
    61→	return "sessions"
    62→}
    63→
    64→// SyncStats tracks the results of a sync operation
    65→type SyncStats struct {
    66→	TotalSessions   int
    67→	SessionsSkipped int // Already up to date
    68→	SessionsUpdated int // Existed but needed update
    69→	SessionsCreated int // Newly created markdown files
    70→}
    71→
    72→// validateFlags checks for mutually exclusive flag combinations
    73→func validateFlags() error {
    74→	if console && silent {
    75→		return utils.ValidationError{Message: "cannot use --console and --silent together. These flags are mutually exclusive"}
    76→	}
    77→	if debug && !console && !logFile {
    78→		return utils.ValidationError{Message: "--debug requires either --console or --log to be specified"}
    79→	}
    80→	if onlyCloudSync && noCloudSync {
    81→		return utils.ValidationError{Message: "cannot use --only-cloud-sync and --no-cloud-sync together. These flags are mutually exclusive"}
    82→	}
    83→	if printToStdout && onlyCloudSync {
    84→		return utils.ValidationError{Message: "cannot use --print and --only-cloud-sync together. These flags are mutually exclusive"}
    85→	}
    86→	if printToStdout && console {
    87→		return utils.ValidationError{Message: "cannot use --print and --console together. Console debug output would interleave with markdown on stdout"}
    88→	}
    89→	return nil
    90→}
    91→
    92→// createRootCommand dynamically creates the root command with provider information
    93→func createRootCommand() *cobra.Command {
    94→	registry := factory.GetRegistry()
    95→	ids := registry.ListIDs()
    96→	providerList := registry.GetProviderList()
    97→
    98→	// Build dynamic examples based on registered providers
    99→	examples := `
   100→# Check terminal coding agents installation
   101→specstory check
   102→
   103→# Run the default agent with auto-saving
   104→specstory run`
   105→
   106→	// Add provider-specific examples if we have providers
   107→	if len(ids) > 0 {
   108→		examples += "\n\n# Run a specific agent with auto-saving"
   109→		for _, id := range ids {
   110→			if provider, _ := registry.Get(id); provider != nil {
   111→				examples += fmt.Sprintf("\nspecstory run %s", id)
   112→			}
   113→		}
   114→
   115→		// Use first provider for custom command example
   116→		examples += fmt.Sprintf("\n\n# Run with custom command\nspecstory run %s -c \"/custom/path/to/agent\"", ids[0])
   117→	}
   118→
   119→	examples += `
   120→
   121→# Generate markdown files for all agent sessions associated with the current directory
   122→specstory sync
   123→
   124→# Generate markdown files for specific agent sessions
   125→specstory sync -s <session-id>
   126→specstory sync -s <session-id-1> -s <session-id-2>
   127→
   128→# Watch for any agent activity in the current directory and generate markdown files
   129→specstory watch`
   130→
   131→	longDesc := `SpecStory is a wrapper for terminal coding agents that auto-saves markdown files of all your chat interactions.`
   132→	if providerList != "No providers registered" {
   133→		longDesc += "\n\nSupported agents: " + providerList + "."
   134→	}
   135→
   136→	return &cobra.Command{
   137→		Use:               "specstory [command]",
   138→		Short:             "SpecStory auto-saves terminal coding agent chat interactions",
   139→		Long:              longDesc,
   140→		Example:           examples,
   141→		SilenceUsage:      true,
   142→		SilenceErrors:     true,
   143→		DisableAutoGenTag: true,
   144→		CompletionOptions: cobra.CompletionOptions{DisableDefaultCmd: true},
   145→		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
   146→			// Validate flags before any other setup
   147→			if err := validateFlags(); err != nil {
   148→				fmt.Println() // Add visual separation before error message for better CLI readability
   149→				return err
   150→			}
   151→
   152→			// Configure logging based on flags
   153→			if console || logFile {
   154→				// Create output config to get proper log path if needed
   155→				var logPath string
   156→				if logFile {
   157→					config, err := utils.SetupOutputConfig(outputDir)
   158→					if err != nil {
   159→						return err
   160→					}
   161→					logPath = config.GetLogPath()
   162→				}
   163→
   164→				// Set up logger
   165→				if err := log.SetupLogger(console, logFile, debug, logPath); err != nil {
   166→					return fmt.Errorf("failed to set up logger: %v", err)
   167→				}
   168→
   169→				// Log startup information
   170→				slog.Info("=== SpecStory Starting ===")
   171→				slog.Info("Version", "version", version)
   172→				slog.Info("Command line", "args", strings.Join(os.Args, " "))
   173→				if cwd, err := os.Getwd(); err == nil {
   174→					slog.Info("Current working directory", "cwd", cwd)
   175→				}
   176→				slog.Info("========================")
   177→			} else {
   178→				// No logging - set up discard logger
   179→				if err := log.SetupLogger(false, false, false, ""); err != nil {
   180→					return err
   181→				}
   182→			}
   183→
   184→			// Set silent mode for user messages
   185→			log.SetSilent(silent)
   186→
   187→			// Initialize cloud sync manager
   188→			cloud.InitSyncManager(!noCloudSync)
   189→			cloud.SetSilent(silent)
   190→			cloud.SetClientVersion(version)
   191→			// Set custom cloud URL if provided (otherwise cloud package uses its default)
   192→			if cloudURL != "" {
   193→				cloud.SetAPIBaseURL(cloudURL)
   194→			}
   195→
   196→			// If --cloud-token flag was provided, verify the refresh token works
   197→			// This bypasses normal authentication and uses the token for this session only
   198→			if cloudToken != "" {
   199→				slog.Info("Using session-only refresh token from --cloud-token flag")
   200→				if err := cloud.SetSessionRefreshToken(cloudToken); err != nil {
   201→					fmt.Fprintln(os.Stderr) // Visual separation
   202→					fmt.Fprintln(os.Stderr, "❌ Failed to authenticate with the provided token:")
   203→					fmt.Fprintf(os.Stderr, "   %v\n", err)
   204→					fmt.Fprintln(os.Stderr)
   205→					fmt.Fprintln(os.Stderr, "💡 The token may be invalid, expired, or revoked.")
   206→					fmt.Fprintln(os.Stderr, "   Please check your token and try again, or use 'specstory login' for interactive authentication.")
   207→					fmt.Fprintln(os.Stderr)
   208→					return fmt.Errorf("authentication failed with provided token")
   209→				}
   210→				if !silent {
   211→					fmt.Println()
   212→					fmt.Println("🔑 Authenticated using provided refresh token (session-only)")
   213→					fmt.Println()
   214→				}
   215→			}
   216→
   217→			// Validate that --only-cloud-sync requires authentication
   218→			if onlyCloudSync && !cloud.IsAuthenticated() {
   219→				return utils.ValidationError{Message: "--only-cloud-sync requires authentication. Please run 'specstory login' first"}
   220→			}
   221→
   222→			return nil
   223→		},
   224→		Run: func(c *cobra.Command, args []string) {
   225→			// Track help command usage (when no command is specified)
   226→			analytics.TrackEvent(analytics.EventHelpCommand, analytics.Properties{
   227→				"help_topic":  "general",
   228→				"help_reason": "requested",
   229→			})
   230→			// If no command is specified, show logo then help
   231→			cmdpkg.DisplayLogoAndHelp(c)
   232→		},
   233→	}
   234→}
   235→
   236→var rootCmd *cobra.Command
   237→
   238→// createRunCommand dynamically creates the run command with provider information
   239→func createRunCommand() *cobra.Command {
   240→	registry := factory.GetRegistry()
   241→	ids := registry.ListIDs()
   242→	providerList := registry.GetProviderList()
   243→
   244→	// Build dynamic examples
   245→	examples := `
   246→# Run default agent with auto-saving
   247→specstory run`
   248→
   249→	if len(ids) > 0 {
   250→		examples += "\n\n# Run specific agent"
   251→		for _, id := range ids {
   252→			examples += fmt.Sprintf("\nspecstory run %s", id)
   253→		}
   254→
   255→		// Use first provider for custom command example
   256→		examples += fmt.Sprintf("\n\n# Run with custom command\nspecstory run %s -c \"/custom/path/to/agent\"", ids[0])
   257→	}
   258→
   259→	examples += `
   260→
   261→# Resume a specific session
   262→specstory run --resume 5c5c2876-febd-4c87-b80c-d0655f1cd3fd
   263→
   264→# Run with custom output directory
   265→specstory run --output-dir ~/my-sessions`
   266→
   267→	// Determine default agent name
   268→	defaultAgent := "the default agent"
   269→	if len(ids) > 0 {
   270→		if provider, err := registry.Get(ids[0]); err == nil {
   271→			defaultAgent = provider.Name()
   272→		}
   273→	}
   274→
   275→	longDesc := fmt.Sprintf(`Launch terminal coding agents in interactive mode with auto-save markdown file generation.
   276→
   277→By default, launches %s. Specify a specific agent ID to use a different agent.`, defaultAgent)
   278→	if providerList != "No providers registered" {
   279→		longDesc += "\n\nAvailable provider IDs: " + providerList + "."
   280→	}
   281→
   282→	return &cobra.Command{
   283→		Use:     "run [provider-id]",
   284→		Aliases: []string{"r"},
   285→		Short:   "Launch terminal coding agents in interactive mode with auto-save",
   286→		Long:    longDesc,
   287→		Example: examples,
   288→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument (provider ID)
   289→		PreRunE: func(cmd *cobra.Command, args []string) error {
   290→			// Get custom command if provided via flag
   291→			customCmd, _ := cmd.Flags().GetString("command")
   292→
   293→			// Validate that -c flag requires a provider
   294→			if customCmd != "" && len(args) == 0 {
   295→				registry := factory.GetRegistry()
   296→				ids := registry.ListIDs()
   297→				example := "specstory run <provider> -c \"/custom/path/to/agent\""
   298→				if len(ids) > 0 {
   299→					example = fmt.Sprintf("specstory run %s -c \"/custom/path/to/agent\"", ids[0])
   300→				}
   301→				return utils.ValidationError{
   302→					Message: "The -c/--command flag requires a provider to be specified.\n" +
   303→						"Example: " + example,
   304→				}
   305→			}
   306→			return nil
   307→		},
   308→		RunE: func(cmd *cobra.Command, args []string) error {
   309→			slog.Info("Running in interactive mode")
   310→
   311→			// Get custom command if provided via flag
   312→			customCmd, _ := cmd.Flags().GetString("command")
   313→
   314→			// Get the provider
   315→			registry := factory.GetRegistry()
   316→			var providerID string
   317→			if len(args) == 0 {
   318→				// Default to first registered provider
   319→				ids := registry.ListIDs()
   320→				if len(ids) > 0 {
   321→					providerID = ids[0]
   322→				} else {
   323→					return fmt.Errorf("no providers registered")
   324→				}
   325→			} else {
   326→				providerID = args[0]
   327→			}
   328→
   329→			provider, err := registry.Get(providerID)
   330→			if err != nil {
   331→				// Provider not found - show helpful error
   332→				fmt.Printf("❌ Provider '%s' is not a valid provider implementation\n\n", providerID)
   333→
   334→				ids := registry.ListIDs()
   335→				if len(ids) > 0 {
   336→					fmt.Println("The registered providers are:")
   337→					for _, id := range ids {
   338→						if p, _ := registry.Get(id); p != nil {
   339→							fmt.Printf("  • %s - %s\n", id, p.Name())
   340→						}
   341→					}
   342→					fmt.Println("\nExample: specstory run " + ids[0])
   343→				}
   344→				return err
   345→			}
   346→
   347→			slog.Info("Launching agent", "provider", provider.Name())
   348→
   349→			// Set the agent provider for analytics
   350→			analytics.SetAgentProviders([]string{provider.Name()})
   351→
   352→			// Setup output configuration
   353→			config, err := utils.SetupOutputConfig(outputDir)
   354→			if err != nil {
   355→				return err
   356→			}
   357→			// Ensure history directory exists for interactive mode
   358→			if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   359→				return err
   360→			}
   361→
   362→			// Initialize project identity
   363→			cwd, err := os.Getwd()
   364→			if err != nil {
   365→				slog.Error("Failed to get current working directory", "error", err)
   366→				return err
   367→			}
   368→			identityManager := utils.NewProjectIdentityManager(cwd)
   369→			if _, err := identityManager.EnsureProjectIdentity(); err != nil {
   370→				// Log error but don't fail the command
   371→				slog.Error("Failed to ensure project identity", "error", err)
   372→			}
   373→
   374→			// Create context for graceful cancellation (Ctrl+C handling)
   375→			ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
   376→			defer cancel()
   377→
   378→			// Start provenance infrastructure before the agent so all file changes are captured
   379→			provenanceEngine, provenanceCleanup, err := provenance.StartEngine(provenanceEnabled)
   380→			if err != nil {
   381→				return err
   382→			}
   383→			defer provenanceCleanup()
   384→
   385→			fsCleanup, err := provenance.StartFSWatcher(ctx, provenanceEngine, cwd)
   386→			if err != nil {
   387→				return err
   388→			}
   389→			defer fsCleanup()
   390→
   391→			// Check authentication for cloud sync
   392→			cmdpkg.CheckAndWarnAuthentication(noCloudSync)
   393→			// Track extension activation
   394→			analytics.TrackEvent(analytics.EventExtensionActivated, nil)
   395→
   396→			// Get resume session ID if provided
   397→			resumeSessionID, _ := cmd.Flags().GetString("resume")
   398→			if resumeSessionID != "" {
   399→				resumeSessionID = strings.TrimSpace(resumeSessionID)
   400→				// Note: Different providers may have different session ID formats
   401→				// Let the provider validate its own format
   402→				slog.Info("Resuming session", "sessionId", resumeSessionID)
   403→			}
   404→
   405→			// Get debug-raw flag value (must be before callback to capture in closure)
   406→			debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   407→			useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   408→			useUTC := !useLocalTimezone
   409→
   410→			// This callback pattern enables real-time processing of agent sessions
   411→			// without blocking the agent's execution. As the agent writes updates to its
   412→			// data files, the provider's watcher detects changes and invokes this callback,
   413→			// allowing immediate markdown generation and cloud sync. Errors are logged but
   414→			// don't stop execution because transient failures (e.g., network issues) shouldn't
   415→			// interrupt the user's coding session.
   416→			sessionCallback := func(session *spi.AgentChatSession) {
   417→				if session == nil {
   418→					return
   419→				}
   420→
   421→				// Track the session ID for deep linking on exit
   422→				lastRunSessionID = session.SessionID
   423→
   424→				// Process the session (write markdown and sync to cloud)
   425→				// Don't show output during interactive run mode
   426→				// This is autosave mode (true)
   427→				_, err := sessionpkg.ProcessSingleSession(session, config, onlyCloudSync, false, true, debugRaw, useUTC)
   428→				if err != nil {
   429→					// Log error but continue - don't fail the whole run
   430→					// In interactive mode, we prioritize keeping the agent running.
   431→					// Failed markdown writes or cloud syncs can be retried later via
   432→					// the sync command, so we just log and continue.
   433→					slog.Error("Failed to process session update",
   434→						"sessionId", session.SessionID,
   435→						"error", err)
   436→				}
   437→
   438→				// Push agent events to provenance engine for correlation
   439→				provenance.ProcessEvents(ctx, provenanceEngine, session)
   440→			}
   441→
   442→			// Execute the agent and watch for updates
   443→			slog.Info("Starting agent execution and monitoring", "provider", provider.Name())
   444→			err = provider.ExecAgentAndWatch(cwd, customCmd, resumeSessionID, debugRaw, sessionCallback)
   445→
   446→			if err != nil {
   447→				slog.Error("Agent execution failed", "provider", provider.Name(), "error", err)
   448→			}
   449→
   450→			return err
   451→		},
   452→	}
   453→}
   454→
   455→var runCmd *cobra.Command
   456→
   457→// createSyncCommand dynamically creates the sync command with provider information
   458→func createSyncCommand() *cobra.Command {
   459→	registry := factory.GetRegistry()
   460→	ids := registry.ListIDs()
   461→	providerList := registry.GetProviderList()
   462→
   463→	// Build dynamic examples
   464→	examples := `
   465→# Sync all agents with activity
   466→specstory sync`
   467→
   468→	if len(ids) > 0 {
   469→		examples += "\n\n# Sync specific agent"
   470→		for _, id := range ids {
   471→			examples += fmt.Sprintf("\nspecstory sync %s", id)
   472→		}
   473→	}
   474→
   475→	examples += `
   476→
   477→# Sync a specific session by UUID
   478→specstory sync -s <session-id>
   479→
   480→# Sync multiple sessions
   481→specstory sync -s <session-id-1> -s <session-id-2> -s <session-id-3>
   482→
   483→# Output session markdown to stdout without saving
   484→specstory sync -s <session-id> --print
   485→
   486→# Output multiple sessions to stdout
   487→specstory sync -s <session-id-1> -s <session-id-2> --print
   488→
   489→# Sync all sessions for the current directory, with console output
   490→specstory sync --console
   491→
   492→# Sync all sessions for the current directory, with a log file
   493→specstory sync --log`
   494→
   495→	longDesc := `Create or update markdown files for the agent sessions in the current working directory.
   496→
   497→By default, syncs all registered providers that have activity.
   498→Provide a specific agent ID to sync a specific provider.`
   499→	if providerList != "No providers registered" {
   500→		longDesc += "\n\nAvailable provider IDs: " + providerList + "."
   501→	}
   502→
   503→	return &cobra.Command{
   504→		Use:     "sync [provider-id]",
   505→		Aliases: []string{"s"},
   506→		Short:   "Sync markdown files for terminal coding agent sessions",
   507→		Long:    longDesc,
   508→		Example: examples,
   509→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument (provider ID)
   510→		PreRunE: func(cmd *cobra.Command, args []string) error {
   511→			// Validate that --print requires -s flag
   512→			sessionIDs, _ := cmd.Flags().GetStringSlice("session")
   513→			if printToStdout && len(sessionIDs) == 0 {
   514→				return utils.ValidationError{Message: "--print requires the -s/--session flag to specify which sessions to output"}
   515→			}
   516→			return nil
   517→		},
   518→		RunE: func(cmd *cobra.Command, args []string) error {
   519→			// Get session IDs if provided via flag
   520→			sessionIDs, _ := cmd.Flags().GetStringSlice("session")
   521→
   522→			// Handle specific session sync if -s flag is provided
   523→			if len(sessionIDs) > 0 {
   524→				return syncSpecificSessions(cmd, args, sessionIDs)
   525→			}
   526→
   527→			slog.Info("Running sync command")
   528→			registry := factory.GetRegistry()
   529→
   530→			// Check if user specified a provider
   531→			if len(args) > 0 {
   532→				// Sync specific provider
   533→				return syncSingleProvider(registry, args[0], cmd)
   534→			} else {
   535→				// Sync all providers with activity
   536→				return syncAllProviders(registry, cmd)
   537→			}
   538→		},
   539→	}
   540→}
   541→
   542→// syncSpecificSessions syncs one or more sessions by their IDs
   543→// When printToStdout is set, outputs markdown to stdout instead of saving to files.
   544→// args[0] is the optional provider ID
   545→func syncSpecificSessions(cmd *cobra.Command, args []string, sessionIDs []string) error {
   546→	if len(sessionIDs) == 1 {
   547→		slog.Info("Running single session sync", "sessionId", sessionIDs[0])
   548→	} else {
   549→		slog.Info("Running multiple session sync", "sessionCount", len(sessionIDs))
   550→	}
   551→
   552→	// Get debug-raw flag value
   553→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   554→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   555→	useUTC := !useLocalTimezone
   556→
   557→	cwd, err := os.Getwd()
   558→	if err != nil {
   559→		slog.Error("Failed to get current working directory", "error", err)
   560→		return err
   561→	}
   562→
   563→	// Setup file output and cloud sync (not needed for --print mode)
   564→	var config utils.OutputConfig
   565→	if !printToStdout {
   566→		config, err = utils.SetupOutputConfig(outputDir)
   567→		if err != nil {
   568→			return err
   569→		}
   570→
   571→		identityManager := utils.NewProjectIdentityManager(cwd)
   572→		if _, err := identityManager.EnsureProjectIdentity(); err != nil {
   573→			slog.Error("Failed to ensure project identity", "error", err)
   574→		}
   575→
   576→		cmdpkg.CheckAndWarnAuthentication(noCloudSync)
   577→
   578→		if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   579→			return err
   580→		}
   581→	}
   582→
   583→	registry := factory.GetRegistry()
   584→
   585→	// Track statistics for summary output
   586→	var successCount, notFoundCount, errorCount int
   587→	var lastError error
   588→
   589→	// Resolve provider once if specified (fail fast if provider not found)
   590→	var specifiedProvider spi.Provider
   591→	if len(args) > 0 {
   592→		providerID := args[0]
   593→		provider, err := registry.Get(providerID)
   594→		if err != nil {
   595→			if !printToStdout {
   596→				fmt.Printf("❌ Provider '%s' not found\n", providerID)
   597→			}
   598→			return fmt.Errorf("provider '%s' not found: %w", providerID, err)
   599→		}
   600→		specifiedProvider = provider
   601→	}
   602→
   603→	// Process each session ID
   604→	var printedSessions int // tracks sessions printed to stdout for separator logic
   605→	for _, sessionID := range sessionIDs {
   606→		sessionID = strings.TrimSpace(sessionID)
   607→		if sessionID == "" {
   608→			continue // Skip empty session IDs
   609→		}
   610→
   611→		// Find session across providers
   612→		var session *spi.AgentChatSession
   613→
   614→		// Case A: Provider was specified - use it directly
   615→		if specifiedProvider != nil {
   616→			session, err = specifiedProvider.GetAgentChatSession(cwd, sessionID, debugRaw)
   617→			if err != nil {
   618→				if !printToStdout {
   619→					fmt.Printf("❌ Error getting session '%s' from %s: %v\n", sessionID, specifiedProvider.Name(), err)
   620→				}
   621→				slog.Error("Error getting session from provider", "sessionId", sessionID, "provider", specifiedProvider.Name(), "error", err)
   622→				errorCount++
   623→				lastError = err
   624→				continue
   625→			}
   626→			if session == nil {
   627→				if !printToStdout {
   628→					fmt.Printf("❌ Session '%s' not found in %s\n", sessionID, specifiedProvider.Name())
   629→				}
   630→				slog.Warn("Session not found in provider", "sessionId", sessionID, "provider", specifiedProvider.Name())
   631→				notFoundCount++
   632→				continue
   633→			}
   634→		} else {
   635→			// Case B: No provider specified - try all providers
   636→			providerIDs := registry.ListIDs()
   637→			for _, id := range providerIDs {
   638→				provider, err := registry.Get(id)
   639→				if err != nil {
   640→					continue
   641→				}
   642→
   643→				session, err = provider.GetAgentChatSession(cwd, sessionID, debugRaw)
   644→				if err != nil {
   645→					slog.Debug("Error checking provider for session", "provider", id, "sessionId", sessionID, "error", err)
   646→					continue
   647→				}
   648→				if session != nil {
   649→					if !silent && !printToStdout {
   650→						fmt.Printf("✅ Found session '%s' for %s\n", sessionID, provider.Name())
   651→					}
   652→					break // Found it, don't check other providers
   653→				}
   654→			}
   655→
   656→			if session == nil {
   657→				if !printToStdout {
   658→					fmt.Printf("❌ Session '%s' not found in any provider\n", sessionID)
   659→				}
   660→				slog.Warn("Session not found in any provider", "sessionId", sessionID)
   661→				notFoundCount++
   662→				continue
   663→			}
   664→		}
   665→
   666→		// Process the found session
   667→		if printToStdout {
   668→			sessionpkg.ValidateSessionData(session, debugRaw)
   669→			sessionpkg.WriteDebugSessionData(session, debugRaw)
   670→
   671→			markdownContent, err := sessionpkg.GenerateMarkdownFromAgentSession(session.SessionData, false, useUTC)
   672→			if err != nil {
   673→				slog.Error("Failed to generate markdown", "sessionId", session.SessionID, "error", err)
   674→				analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   675→					"session_id": session.SessionID,
   676→					"error":      err.Error(),
   677→					"mode":       "print",
   678→				})
   679→				errorCount++
   680→				lastError = err
   681→				continue
   682→			}
   683→
   684→			// Separate multiple sessions with a horizontal rule
   685→			if printedSessions > 0 {
   686→				fmt.Print("\n---\n\n")
   687→			}
   688→			fmt.Print(markdownContent)
   689→			printedSessions++
   690→			successCount++
   691→			analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
   692→				"session_id": session.SessionID,
   693→				"mode":       "print",
   694→			})
   695→		} else {
   696→			// Normal sync: write to file and optionally cloud sync
   697→			if _, err := sessionpkg.ProcessSingleSession(session, config, onlyCloudSync, true, false, debugRaw, useUTC); err != nil {
   698→				errorCount++
   699→				lastError = err
   700→			} else {
   701→				successCount++
   702→			}
   703→		}
   704→	}
   705→
   706→	// Print summary if multiple sessions were processed (not for --print mode)
   707→	if !printToStdout && len(sessionIDs) > 1 && !silent {
   708→		fmt.Println()
   709→		fmt.Println("📊 Session sync summary:")
   710→		fmt.Printf("  ✅ %d %s successfully synced\n", successCount, pluralSession(successCount))
   711→		if notFoundCount > 0 {
   712→			fmt.Printf("  ❌ %d %s not found\n", notFoundCount, pluralSession(notFoundCount))
   713→		}
   714→		if errorCount > 0 {
   715→			fmt.Printf("  ❌ %d %s failed with errors\n", errorCount, pluralSession(errorCount))
   716→		}
   717→		fmt.Println()
   718→	}
   719→
   720→	// Return error if any sessions failed
   721→	if errorCount > 0 || (notFoundCount > 0 && successCount == 0) {
   722→		if lastError != nil {
   723→			return lastError
   724→		}
   725→		return fmt.Errorf("%d %s not found", notFoundCount, pluralSession(notFoundCount))
   726→	}
   727→
   728→	return nil
   729→}
   730→
   731→// preloadBulkSessionSizesIfNeeded optimizes bulk syncs by fetching all session sizes upfront.
   732→// This avoids making individual HEAD requests for each session during sync operations.
   733→//
   734→// The function only performs the preload if:
   735→//   - Cloud sync is enabled (noCloudSync flag is false)
   736→//   - User is authenticated with SpecStory Cloud
   737→//   - A valid projectID can be determined from the identity manager
   738→//
   739→// Parameters:
   740→//   - identityManager: Provides project identity (git_id or workspace_id) for the current project
   741→//
   742→// The preloaded sizes are cached in the SyncManager and shared across all providers since they
   743→// use the same projectID. If the bulk fetch fails or if projectID cannot be determined, individual
   744→// sessions will gracefully fall back to HEAD requests during sync.
   745→//
   746→// This function is safe to call multiple times but should typically be called once before processing
   747→// multiple sessions in batch sync operations.
   748→func preloadBulkSessionSizesIfNeeded(identityManager *utils.ProjectIdentityManager) {
   749→	// Skip if cloud sync is disabled or user is not authenticated
   750→	if noCloudSync || !cloud.IsAuthenticated() {
   751→		return
   752→	}
   753→
   754→	// Get projectID from identity manager - required for cloud sync
   755→	projectID, err := identityManager.GetProjectID()
   756→	if err != nil {
   757→		slog.Warn("Cannot preload session sizes: failed to get project ID", "error", err)
   758→		return
   759→	}
   760→
   761→	// Preload bulk sizes once - shared across all providers since they use same projectID
   762→	if syncMgr := cloud.GetSyncManager(); syncMgr != nil {
   763→		syncMgr.PreloadSessionSizes(projectID)
   764→	} else {
   765→		slog.Warn("Cannot preload session sizes: sync manager is nil despite authentication")
   766→	}
   767→}
   768→
   769→// syncProvider performs the actual sync for a single provider
   770→// Returns (sessionCount, error) for analytics tracking
   771→func syncProvider(provider spi.Provider, providerID string, config utils.OutputConfig, debugRaw bool, useUTC bool) (int, error) {
   772→	cwd, err := os.Getwd()
   773→	if err != nil {
   774→		slog.Error("Failed to get current working directory", "error", err)
   775→		return 0, err
   776→	}
   777→
   778→	// Create progress callback for parsing phase
   779→	// The callback updates the "Parsing..." line in place with [n/m] progress
   780→	var parseProgress spi.ProgressCallback
   781→	if !silent {
   782→		providerName := provider.Name()
   783→		parseProgress = func(current, total int) {
   784→			fmt.Printf("\rParsing %s sessions [%d/%d]", providerName, current, total)
   785→			_ = os.Stdout.Sync()
   786→		}
   787→	}
   788→
   789→	// Get all sessions from the provider
   790→	sessions, err := provider.GetAgentChatSessions(cwd, debugRaw, parseProgress)
   791→	if err != nil {
   792→		return 0, fmt.Errorf("failed to get sessions: %w", err)
   793→	}
   794→
   795→	sessionCount := len(sessions)
   796→
   797→	if sessionCount == 0 && !silent {
   798→		// This comes after "Parsing..." message, on the same line
   799→		fmt.Printf(", no non-empty sessions found for %s\n", provider.Name())
   800→		fmt.Println()
   801→		return 0, nil
   802→	}
   803→
   804→	if !silent {
   805→		fmt.Printf("\nSyncing markdown files for %s", provider.Name())
   806→	}
   807→
   808→	// Initialize statistics
   809→	stats := &SyncStats{
   810→		TotalSessions: sessionCount,
   811→	}
   812→
   813→	historyPath := config.GetHistoryDir()
   814→
   815→	// Process each session
   816→	for i := range sessions {
   817→		session := &sessions[i]
   818→		sessionpkg.ValidateSessionData(session, debugRaw)
   819→		sessionpkg.WriteDebugSessionData(session, debugRaw)
   820→
   821→		// Generate markdown from SessionData
   822→		markdownContent, err := sessionpkg.GenerateMarkdownFromAgentSession(session.SessionData, false, useUTC)
   823→		if err != nil {
   824→			slog.Error("Failed to generate markdown from SessionData",
   825→				"sessionId", session.SessionID,
   826→				"error", err)
   827→			// Track sync error
   828→			analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   829→				"session_id": session.SessionID,
   830→				"error":      err.Error(),
   831→			})
   832→			continue
   833→		}
   834→
   835→		// Generate filename from timestamp and slug
   836→		fileFullPath := sessionpkg.BuildSessionFilePath(session, historyPath, useUTC)
   837→
   838→		// Check if file already exists with same content
   839→		identicalContent := false
   840→		fileExists := false
   841→		if existingContent, err := os.ReadFile(fileFullPath); err == nil {
   842→			fileExists = true
   843→			if string(existingContent) == markdownContent {
   844→				identicalContent = true
   845→				slog.Info("Markdown file already exists with same content, skipping write",
   846→					"sessionId", session.SessionID,
   847→					"path", fileFullPath)
   848→			}
   849→		}
   850→
   851→		// Write file if needed (skip if only-cloud-sync is enabled)
   852→		if !onlyCloudSync {
   853→			if !identicalContent {
   854→				// Ensure history directory exists (handles deletion during long-running sync)
   855→				if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   856→					slog.Error("Failed to ensure history directory", "error", err)
   857→					continue
   858→				}
   859→				err := os.WriteFile(fileFullPath, []byte(markdownContent), 0644)
   860→				if err != nil {
   861→					slog.Error("Error writing markdown file",
   862→						"sessionId", session.SessionID,
   863→						"error", err)
   864→					// Track sync error
   865→					analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   866→						"session_id":      session.SessionID,
   867→						"error":           err.Error(),
   868→						"only_cloud_sync": onlyCloudSync,
   869→					})
   870→					continue
   871→				}
   872→				slog.Info("Successfully wrote file",
   873→					"sessionId", session.SessionID,
   874→					"path", fileFullPath)
   875→
   876→				// Track successful sync
   877→				if !fileExists {
   878→					analytics.TrackEvent(analytics.EventSyncMarkdownNew, analytics.Properties{
   879→						"session_id":      session.SessionID,
   880→						"only_cloud_sync": onlyCloudSync,
   881→					})
   882→				} else {
   883→					analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
   884→						"session_id":      session.SessionID,
   885→						"only_cloud_sync": onlyCloudSync,
   886→					})
   887→				}
   888→			}
   889→
   890→			// Update statistics for normal mode
   891→			if identicalContent {
   892→				stats.SessionsSkipped++
   893→			} else if fileExists {
   894→				stats.SessionsUpdated++
   895→			} else {
   896→				stats.SessionsCreated++
   897→			}
   898→		} else {
   899→			// In cloud-only mode, count as skipped since no local file operation occurred
   900→			stats.SessionsSkipped++
   901→			slog.Info("Skipping local file write (only-cloud-sync mode)",
   902→				"sessionId", session.SessionID)
   903→		}
   904→
   905→		// Trigger cloud sync with provider-specific data
   906→		// Manual sync command: perform immediate sync with HEAD check (not autosave mode)
   907→		// In only-cloud-sync mode: always sync
   908→		cloud.SyncSessionToCloud(session.SessionID, fileFullPath, markdownContent, []byte(session.RawData), provider.Name(), false)
   909→
   910→		// Print progress with [n/m] format
   911→		if !silent {
   912→			fmt.Printf("\rSyncing markdown files for %s [%d/%d]", provider.Name(), i+1, sessionCount)
   913→			_ = os.Stdout.Sync()
   914→		}
   915→	}
   916→
   917→	// Print newline after progress
   918→	if !silent && sessionCount > 0 && !onlyCloudSync {
   919→		fmt.Println()
   920→
   921→		// Calculate actual total of processed sessions
   922→		actualTotal := stats.SessionsSkipped + stats.SessionsUpdated + stats.SessionsCreated
   923→
   924→		// Print summary message with proper pluralization
   925→		fmt.Printf("\n%s✅ %s sync complete!%s 📊 %s%d%s %s processed\n",
   926→			log.ColorBoldGreen, provider.Name(), log.ColorReset,
   927→			log.ColorBoldCyan, actualTotal, log.ColorReset, pluralSession(actualTotal))
   928→		fmt.Println()
   929→
   930→		fmt.Printf("  ⏭️ %s%d %s up to date (skipped)%s\n",
   931→			log.ColorCyan, stats.SessionsSkipped, pluralSession(stats.SessionsSkipped), log.ColorReset)
   932→		fmt.Printf("  ♻️ %s%d %s updated%s\n",
   933→			log.ColorYellow, stats.SessionsUpdated, pluralSession(stats.SessionsUpdated), log.ColorReset)
   934→		fmt.Printf("  ✨ %s%d new %s created%s\n",
   935→			log.ColorGreen, stats.SessionsCreated, pluralSession(stats.SessionsCreated), log.ColorReset)
   936→		fmt.Println()
   937→	}
   938→
   939→	return sessionCount, nil
   940→}
   941→
   942→// syncAllProviders syncs all providers that have activity in the current directory
   943→func syncAllProviders(registry *factory.Registry, cmd *cobra.Command) error {
   944→	// Get debug-raw flag value
   945→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   946→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   947→	useUTC := !useLocalTimezone
   948→
   949→	cwd, err := os.Getwd()
   950→	if err != nil {
   951→		slog.Error("Failed to get current working directory", "error", err)
   952→		return err
   953→	}
   954→
   955→	providerIDs := registry.ListIDs()
   956→	providersWithActivity := []string{}
   957→
   958→	// Check each provider for activity
   959→	for _, id := range providerIDs {
   960→		provider, err := registry.Get(id)
   961→		if err != nil {
   962→			slog.Warn("Failed to get provider", "id", id, "error", err)
   963→			continue
   964→		}
   965→
   966→		if provider.DetectAgent(cwd, false) {
   967→			providersWithActivity = append(providersWithActivity, id)
   968→		}
   969→	}
   970→
   971→	// If no providers have activity, show helpful message
   972→	if len(providersWithActivity) == 0 {
   973→		if !silent {
   974→			fmt.Println() // Add visual separation
   975→			log.UserWarn("No coding agent activity found for this project directory.\n\n")
   976→
   977→			log.UserMessage("We checked for activity in '%s' from the following agents:\n", cwd)
   978→			for _, id := range providerIDs {
   979→				if provider, err := registry.Get(id); err == nil {
   980→					log.UserMessage("- %s\n", provider.Name())
   981→				}
   982→			}
   983→			log.UserMessage("\nBut didn't find any activity.\n\n")
   984→
   985→			log.UserMessage("To fix this:\n")
   986→			log.UserMessage("  1. Run 'specstory run' to start the default agent in this directory\n")
   987→			log.UserMessage("  2. Run 'specstory run <agent>' to start a specific agent in this directory\n")
   988→			log.UserMessage("  3. Or run the agent directly first, then try syncing again\n")
   989→			fmt.Println() // Add trailing newline
   990→		}
   991→		return nil
   992→	}
   993→
   994→	// Collect provider names for analytics
   995→	var providerNames []string
   996→	for _, id := range providersWithActivity {
   997→		if provider, err := registry.Get(id); err == nil {
   998→			providerNames = append(providerNames, provider.Name())
   999→		}
  1000→	}
  1001→	analytics.SetAgentProviders(providerNames)
  1002→
  1003→	// Setup output configuration (once for all providers)
  1004→	config, err := utils.SetupOutputConfig(outputDir)
  1005→	if err != nil {
  1006→		return err
  1007→	}
  1008→
  1009→	// Initialize project identity (once for all providers)
  1010→	identityManager := utils.NewProjectIdentityManager(cwd)
  1011→	if _, err := identityManager.EnsureProjectIdentity(); err != nil {
  1012→		slog.Error("Failed to ensure project identity", "error", err)
  1013→	}
  1014→
  1015→	// Check authentication for cloud sync (once)
  1016→	cmdpkg.CheckAndWarnAuthentication(noCloudSync)
  1017→
  1018→	// Ensure history directory exists (once)
  1019→	if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
  1020→		return err
  1021→	}
  1022→
  1023→	// Preload session sizes for batch sync optimization (ONCE for all providers)
  1024→	preloadBulkSessionSizesIfNeeded(identityManager)
  1025→
  1026→	// Sync each provider with activity
  1027→	totalSessionCount := 0
  1028→	var lastError error
  1029→
  1030→	for _, id := range providersWithActivity {
  1031→		provider, err := registry.Get(id)
  1032→		if err != nil {
  1033→			continue
  1034→		}
  1035→
  1036→		if !silent {
  1037→			fmt.Printf("\nParsing %s sessions", provider.Name())
  1038→		}
  1039→
  1040→		sessionCount, err := syncProvider(provider, id, config, debugRaw, useUTC)
  1041→		totalSessionCount += sessionCount
  1042→
  1043→		if err != nil {
  1044→			lastError = err
  1045→			slog.Error("Error syncing provider", "provider", id, "error", err)
  1046→		}
  1047→	}
  1048→
  1049→	// Track overall analytics
  1050→	if lastError != nil {
  1051→		analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
  1052→			"provider":      "all",
  1053→			"error":         lastError.Error(),
  1054→			"session_count": totalSessionCount,
  1055→		})
  1056→		// Brief delay to ensure error event is sent before exit
  1057→		// TODO: This is a workaround for async analytics - should be fixed properly
  1058→		time.Sleep(500 * time.Millisecond)
  1059→	} else {
  1060→		analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
  1061→			"provider":      "all",
  1062→			"session_count": totalSessionCount,
  1063→		})
  1064→	}
  1065→
  1066→	return lastError
  1067→}
  1068→
  1069→// syncSingleProvider syncs a specific provider
  1070→func syncSingleProvider(registry *factory.Registry, providerID string, cmd *cobra.Command) error {
  1071→	// Get debug-raw flag value
  1072→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
  1073→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
  1074→	useUTC := !useLocalTimezone
  1075→
  1076→	provider, err := registry.Get(providerID)
  1077→	if err != nil {
  1078→		// Provider not found - show helpful error
  1079→		fmt.Printf("❌ Provider '%s' is not a valid provider implementation\n\n", providerID)
  1080→
  1081→		ids := registry.ListIDs()
  1082→		if len(ids) > 0 {
  1083→			fmt.Println("The registered providers are:")
  1084→			for _, id := range ids {
  1085→				if p, _ := registry.Get(id); p != nil {
  1086→					fmt.Printf("  • %s - %s\n", id, p.Name())
  1087→				}
  1088→			}
  1089→			fmt.Println("\nExample: specstory sync " + ids[0])
  1090→		}
  1091→		return err
  1092→	}
  1093→
  1094→	// Set the agent provider for analytics
  1095→	analytics.SetAgentProviders([]string{provider.Name()})
  1096→
  1097→	cwd, err := os.Getwd()
  1098→	if err != nil {
  1099→		slog.Error("Failed to get current working directory", "error", err)
  1100→		return err
  1101→	}
  1102→
  1103→	// Check if provider has activity, with helpful output if not
  1104→	if !provider.DetectAgent(cwd, true) {
  1105→		// Provider already output helpful message
  1106→		return nil
  1107→	}
  1108→
  1109→	// Setup output configuration
  1110→	config, err := utils.SetupOutputConfig(outputDir)
  1111→	if err != nil {
  1112→		return err
  1113→	}
  1114→
  1115→	// Initialize project identity
  1116→	identityManager := utils.NewProjectIdentityManager(cwd)
  1117→	if _, err := identityManager.EnsureProjectIdentity(); err != nil {
  1118→		slog.Error("Failed to ensure project identity", "error", err)
  1119→	}
  1120→
  1121→	// Check authentication for cloud sync
  1122→	cmdpkg.CheckAndWarnAuthentication(noCloudSync)
  1123→
  1124→	// Ensure history directory exists
  1125→	if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
  1126→		return err
  1127→	}
  1128→
  1129→	// Preload session sizes for batch sync optimization
  1130→	preloadBulkSessionSizesIfNeeded(identityManager)
  1131→
  1132→	if !silent {
  1133→		fmt.Printf("\nParsing %s sessions", provider.Name())
  1134→	}
  1135→
  1136→	// Perform the sync
  1137→	sessionCount, syncErr := syncProvider(provider, providerID, config, debugRaw, useUTC)
  1138→
  1139→	// Track analytics
  1140→	if syncErr != nil {
  1141→		analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
  1142→			"provider":      providerID,
  1143→			"error":         syncErr.Error(),
  1144→			"session_count": sessionCount,
  1145→		})
  1146→		// Brief delay to ensure error event is sent before exit
  1147→		// TODO: This is a workaround for async analytics - should be fixed properly
  1148→		time.Sleep(500 * time.Millisecond)
  1149→	} else {
  1150→		analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
  1151→			"provider":      providerID,
  1152→			"session_count": sessionCount,
  1153→		})
  1154→	}
  1155→
  1156→	return syncErr
  1157→}
  1158→
  1159→var syncCmd *cobra.Command
  1160→
  1161→// Main entry point for the CLI
  1162→func main() {
  1163→	// Parse critical flags early by manually checking os.Args
  1164→	// This is necessary because cobra's ParseFlags doesn't work correctly before subcommands are added
  1165→	args := os.Args[1:]
  1166→	for i := 0; i < len(args); i++ {
  1167→		arg := args[i]
  1168→		switch arg {
  1169→		case "--no-usage-analytics":
  1170→			noAnalytics = true
  1171→		case "--console":
  1172→			console = true
  1173→		case "--log":
  1174→			logFile = true
  1175→		case "--debug":
  1176→			debug = true
  1177→		case "--silent":
  1178→			silent = true
  1179→		case "--no-version-check":
  1180→			noVersionCheck = true
  1181→		case "--output-dir":
  1182→			// Handle --output-dir <value> format (space-separated)
  1183→			if i+1 < len(args) && !strings.HasPrefix(args[i+1], "-") {
  1184→				outputDir = args[i+1]
  1185→				i++ // Skip the value in next iteration
  1186→			}
  1187→		}
  1188→		// Handle --output-dir=value format
  1189→		if strings.HasPrefix(arg, "--output-dir=") {
  1190→			outputDir = strings.TrimPrefix(arg, "--output-dir=")
  1191→		}
  1192→	}
  1193→
  1194→	// Load configuration early (before logging setup) so TOML settings can affect logging
  1195→	// Priority: CLI flags > local project config > user-level config
  1196→	cfg, cfgErr := config.Load(&config.CLIOverrides{
  1197→		OutputDir:      outputDir,
  1198→		NoVersionCheck: noVersionCheck,
  1199→		NoCloudSync:    noCloudSync,
  1200→		OnlyCloudSync:  onlyCloudSync,
  1201→		Console:        console,
  1202→		Log:            logFile,
  1203→		Debug:          debug,
  1204→		Silent:         silent,
  1205→		NoAnalytics:    noAnalytics,
  1206→	})
  1207→	if cfgErr != nil {
  1208→		// Use fallback empty config if load fails - will log error after logging is set up
  1209→		cfg = &config.Config{}
  1210→	}
  1211→
  1212→	// Apply config values to flag variables so the rest of the code can use them unchanged.
  1213→	// This merges TOML config with CLI flags (CLI flags take precedence via config.Load).
  1214→	if cfg.GetOutputDir() != "" {
  1215→		outputDir = cfg.GetOutputDir()
  1216→	}
  1217→	noVersionCheck = !cfg.IsVersionCheckEnabled()
  1218→	noCloudSync = !cfg.IsCloudSyncEnabled()
  1219→	onlyCloudSync = !cfg.IsLocalSyncEnabled()
  1220→	noAnalytics = !cfg.IsAnalyticsEnabled()
  1221→	console = cfg.IsConsoleEnabled()
  1222→	logFile = cfg.IsLogEnabled()
  1223→	debug = cfg.IsDebugEnabled()
  1224→	silent = cfg.IsSilentEnabled()
  1225→
  1226→	// Set up logging early before creating commands (which access the registry)
  1227→	if console || logFile {
  1228→		var logPath string
  1229→		if logFile {
  1230→			config, _ := utils.SetupOutputConfig(outputDir)
  1231→			logPath = config.GetLogPath()
  1232→		}
  1233→		_ = log.SetupLogger(console, logFile, debug, logPath)
  1234→	} else {
  1235→		// Set up discard logger to prevent default slog output
  1236→		_ = log.SetupLogger(false, false, false, "")
  1237→	}
  1238→
  1239→	// NOW create the commands - after logging is configured
  1240→	rootCmd = createRootCommand()
  1241→	runCmd = createRunCommand()
  1242→	watchCmd := cmdpkg.CreateWatchCommand(&cloudURL)
  1243→	syncCmd = createSyncCommand()
  1244→	listCmd := cmdpkg.CreateListCommand()
  1245→	checkCmd := cmdpkg.CreateCheckCommand()
  1246→	versionCmd := cmdpkg.CreateVersionCommand(version)
  1247→	loginCmd := cmdpkg.CreateLoginCommand(&cloudURL)
  1248→	logoutCmd := cmdpkg.CreateLogoutCommand(&cloudURL)
  1249→
  1250→	// Set version for the automatic version flag
  1251→	rootCmd.Version = version
  1252→
  1253→	// Override the default version template to match our version command output
  1254→	rootCmd.SetVersionTemplate("{{.Version}} (SpecStory)")
  1255→
  1256→	// Set our custom help command (for "specstory help")
  1257→	helpCmd := cmdpkg.CreateHelpCommand(rootCmd)
  1258→	rootCmd.SetHelpCommand(helpCmd)
  1259→
  1260→	// Add the subcommands
  1261→	rootCmd.AddCommand(runCmd)
  1262→	rootCmd.AddCommand(watchCmd)
  1263→	rootCmd.AddCommand(syncCmd)
  1264→	rootCmd.AddCommand(listCmd)
  1265→	rootCmd.AddCommand(versionCmd)
  1266→	rootCmd.AddCommand(checkCmd)
  1267→	rootCmd.AddCommand(loginCmd)
  1268→	rootCmd.AddCommand(logoutCmd)
  1269→
  1270→	// Global flags available on all commands
  1271→	// Use current variable values as defaults so config file values are preserved
  1272→	rootCmd.PersistentFlags().BoolVar(&console, "console", console, "enable error/warn/info output to stdout")
  1273→	rootCmd.PersistentFlags().BoolVar(&logFile, "log", logFile, "write error/warn/info output to ./.specstory/debug/debug.log")
  1274→	rootCmd.PersistentFlags().BoolVar(&debug, "debug", debug, "enable debug-level output (requires --console or --log)")
  1275→	rootCmd.PersistentFlags().BoolVar(&noAnalytics, "no-usage-analytics", noAnalytics, "disable usage analytics")
  1276→	rootCmd.PersistentFlags().BoolVar(&silent, "silent", silent, "suppress all non-error output")
  1277→	rootCmd.PersistentFlags().BoolVar(&noVersionCheck, "no-version-check", noVersionCheck, "skip checking for newer versions")
  1278→	rootCmd.PersistentFlags().StringVar(&cloudToken, "cloud-token", "", "use a SpecStory Cloud refresh token for this session (bypasses login)")
  1279→	_ = rootCmd.PersistentFlags().MarkHidden("cloud-token") // Hidden flag
  1280→
  1281→	// Command-specific flags
  1282→	syncCmd.Flags().StringSliceP("session", "s", []string{}, "optional session IDs to sync (can be specified multiple times, provider-specific format)")
  1283→	syncCmd.Flags().BoolVar(&printToStdout, "print", printToStdout, "output session markdown to stdout instead of saving (requires -s flag)")
  1284→	syncCmd.Flags().StringVar(&outputDir, "output-dir", outputDir, "custom output directory for markdown and debug files (default: ./.specstory/history)")
  1285→	syncCmd.Flags().BoolVar(&noCloudSync, "no-cloud-sync", noCloudSync, "disable cloud sync functionality")
  1286→	syncCmd.Flags().BoolVar(&onlyCloudSync, "only-cloud-sync", onlyCloudSync, "skip local markdown file saves, only upload to cloud (requires authentication)")
  1287→	syncCmd.Flags().StringVar(&cloudURL, "cloud-url", "", "override the default cloud API base URL")
  1288→	_ = syncCmd.Flags().MarkHidden("cloud-url") // Hidden flag
  1289→	syncCmd.Flags().Bool("debug-raw", false, "debug mode to output pretty-printed raw data files")
  1290→	_ = syncCmd.Flags().MarkHidden("debug-raw") // Hidden flag
  1291→	syncCmd.Flags().BoolP("local-time-zone", "", false, "use local timezone for file name and content timestamps (when not present: UTC)")
  1292→
  1293→	runCmd.Flags().BoolVar(&provenanceEnabled, "provenance", false, "enable AI provenance tracking (correlate file changes to agent activity)")
  1294→	_ = runCmd.Flags().MarkHidden("provenance") // Hidden flag
  1295→	runCmd.Flags().StringP("command", "c", "", "custom agent execution command for the provider")
  1296→	runCmd.Flags().String("resume", "", "resume a specific session by ID")
  1297→	runCmd.Flags().StringVar(&outputDir, "output-dir", outputDir, "custom output directory for markdown and debug files (default: ./.specstory/history)")
  1298→	runCmd.Flags().BoolVar(&noCloudSync, "no-cloud-sync", noCloudSync, "disable cloud sync functionality")
  1299→	runCmd.Flags().BoolVar(&onlyCloudSync, "only-cloud-sync", onlyCloudSync, "skip local markdown file saves, only upload to cloud (requires authentication)")
  1300→	runCmd.Flags().StringVar(&cloudURL, "cloud-url", "", "override the default cloud API base URL")
  1301→	_ = runCmd.Flags().MarkHidden("cloud-url") // Hidden flag
  1302→	runCmd.Flags().Bool("debug-raw", false, "debug mode to output pretty-printed raw data files")
  1303→	_ = runCmd.Flags().MarkHidden("debug-raw") // Hidden flag
  1304→	runCmd.Flags().BoolP("local-time-zone", "", false, "use local timezone for file name and content timestamps (when not present: UTC)")
  1305→
  1306→	// Initialize analytics with the full CLI command (unless disabled)
  1307→	slog.Debug("Analytics initialization check", "noAnalytics", noAnalytics, "flag_should_disable", noAnalytics)
  1308→	if !noAnalytics {
  1309→		slog.Debug("Initializing analytics")
  1310→		fullCommand := strings.Join(os.Args, " ")
  1311→		if err := analytics.Init(fullCommand, version); err != nil {
  1312→			// Log error but don't fail - analytics should not break the app
  1313→			slog.Warn("Failed to initialize analytics", "error", err)
  1314→		}
  1315→		defer func() { _ = analytics.Close() }() // Analytics errors shouldn't break the app
  1316→	} else {
  1317→		slog.Debug("Analytics disabled by --no-usage-analytics flag")
  1318→	}
  1319→
  1320→	// Log config load error after logging is set up
  1321→	if cfgErr != nil {
  1322→		slog.Warn("Failed to load config file, using defaults", "error", cfgErr)
  1323→	}
  1324→
  1325→	// Check for updates (blocking)
  1326→	utils.CheckForUpdates(version, noVersionCheck, silent)
  1327→
  1328→	// Ensure proper cleanup and logging on exit
  1329→	defer func() {
  1330→		if r := recover(); r != nil {
  1331→			slog.Error("=== SpecStory PANIC ===", "panic", r)
  1332→			// Still try to wait for cloud sync even on panic
  1333→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1334→			log.CloseLogger()
  1335→			panic(r) // Re-panic after logging
  1336→		}
  1337→		// Wait for cloud sync operations to complete before exiting
  1338→		cloudStats := cloud.Shutdown(cloud.CloudSyncTimeout)
  1339→
  1340→		// Track cloud sync analytics if we have stats
  1341→		if cloudStats != nil {
  1342→			// Calculate total attempted (all sessions that started sync)
  1343→			totalCloudSessions := cloudStats.SessionsAttempted
  1344→
  1345→			// Track cloud sync completion event
  1346→			if cloudStats.SessionsUpdated > 0 || cloudStats.SessionsCreated > 0 || cloudStats.SessionsErrored > 0 || cloudStats.SessionsTimedOut > 0 {
  1347→				analytics.TrackEvent(analytics.EventCloudSyncComplete, analytics.Properties{
  1348→					"sessions_created":   cloudStats.SessionsCreated,
  1349→					"sessions_updated":   cloudStats.SessionsUpdated,
  1350→					"sessions_skipped":   cloudStats.SessionsSkipped,
  1351→					"sessions_errored":   cloudStats.SessionsErrored,
  1352→					"sessions_timed_out": cloudStats.SessionsTimedOut,
  1353→					"total":              totalCloudSessions,
  1354→				})
  1355→			}
  1356→
  1357→			// Display cloud sync stats if not in silent mode
  1358→			if !silent && totalCloudSessions > 0 {
  1359→				fmt.Println() // Visual separation from provider sync output
  1360→
  1361→				// Determine if sync was complete or incomplete based on errors/timeouts
  1362→				if cloudStats.SessionsErrored > 0 || cloudStats.SessionsTimedOut > 0 {
  1363→					fmt.Printf("❌ Cloud sync incomplete! 📊 %s%d%s %s processed\n",
  1364→						log.ColorBoldCyan, totalCloudSessions, log.ColorReset, pluralSession(int(totalCloudSessions)))
  1365→				} else {
  1366→					fmt.Printf("☁️  Cloud sync complete! 📊 %s%d%s %s processed\n",
  1367→						log.ColorBoldCyan, totalCloudSessions, log.ColorReset, pluralSession(int(totalCloudSessions)))
  1368→				}
  1369→				fmt.Println()
  1370→
  1371→				fmt.Printf("  ⏭️ %s%d %s up to date (skipped)%s\n",
  1372→					log.ColorCyan, cloudStats.SessionsSkipped, pluralSession(int(cloudStats.SessionsSkipped)), log.ColorReset)
  1373→				fmt.Printf("  ♻️ %s%d %s updated%s\n",
  1374→					log.ColorYellow, cloudStats.SessionsUpdated, pluralSession(int(cloudStats.SessionsUpdated)), log.ColorReset)
  1375→				fmt.Printf("  ✨ %s%d new %s created%s\n",
  1376→					log.ColorGreen, cloudStats.SessionsCreated, pluralSession(int(cloudStats.SessionsCreated)), log.ColorReset)
  1377→
  1378→				// Only show errors if there were any
  1379→				if cloudStats.SessionsErrored > 0 {
  1380→					fmt.Printf("  ❌ %s%d %s errored%s\n",
  1381→						log.ColorRed, cloudStats.SessionsErrored, pluralSession(int(cloudStats.SessionsErrored)), log.ColorReset)
  1382→				}
  1383→
  1384→				// Only show timed out sessions if there were any
  1385→				if cloudStats.SessionsTimedOut > 0 {
  1386→					fmt.Printf("  ⏱️  %s%d %s timed out%s\n",
  1387→						log.ColorRed, cloudStats.SessionsTimedOut, pluralSession(int(cloudStats.SessionsTimedOut)), log.ColorReset)
  1388→				}
  1389→				fmt.Println()
  1390→
  1391→				// Display link to SpecStory Cloud (deep link to session if from run command)
  1392→				cwd, cwdErr := os.Getwd()
  1393→				if cwdErr == nil {
  1394→					identityManager := utils.NewProjectIdentityManager(cwd)
  1395→					if projectID, err := identityManager.GetProjectID(); err == nil {
  1396→						fmt.Printf("💡 Search and chat with your AI conversation history at:\n")
  1397→						if lastRunSessionID != "" {
  1398→							// Deep link to the specific session from run command
  1399→							fmt.Printf("   %shttps://cloud.specstory.com/projects/%s/sessions/%s%s\n\n",
  1400→								log.ColorBoldCyan, projectID, lastRunSessionID, log.ColorReset)
  1401→						} else {
  1402→							// Link to project overview for sync command
  1403→							fmt.Printf("   %shttps://cloud.specstory.com/projects/%s%s\n\n",
  1404→								log.ColorBoldCyan, projectID, log.ColorReset)
  1405→						}
  1406→					}
  1407→				}
  1408→			}
  1409→		}
  1410→
  1411→		if console || logFile {
  1412→			slog.Info("=== SpecStory Exiting ===", "code", 0, "status", "normal termination")
  1413→		}
  1414→		log.CloseLogger()
  1415→	}()
  1416→
  1417→	if err := fang.Execute(context.Background(), rootCmd, fang.WithVersion(version)); err != nil {
  1418→		// Check if we're running the check command by looking at the executed command
  1419→		executedCmd, _, _ := rootCmd.Find(os.Args[1:])
  1420→		if executedCmd == checkCmd {
  1421→			if console || logFile {
  1422→				slog.Error("=== SpecStory Exiting ===", "code", 2, "status", "agent execution failure")
  1423→				slog.Error("Error", "error", err)
  1424→			}
  1425→			// For check command, the error details are handled by checkSingleProvider/checkAllProviders
  1426→			// So we just exit silently here
  1427→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1428→			os.Exit(2)
  1429→		} else {
  1430→			if console || logFile {
  1431→				slog.Error("=== SpecStory Exiting ===", "code", 1, "status", "error")
  1432→				slog.Error("Error", "error", err)
  1433→			}
  1434→			fmt.Fprintln(os.Stderr) // Visual separation makes error output more noticeable
  1435→
  1436→			// Only show usage for actual command/flag errors from Cobra
  1437→			// These are errors like "unknown command", "unknown flag", "invalid argument", etc.
  1438→			// For all other errors (authentication, network, file system, etc.), we should NOT show usage
  1439→			errMsg := err.Error()
  1440→			isCommandError := strings.Contains(errMsg, "unknown command") ||
  1441→				strings.Contains(errMsg, "unknown flag") ||
  1442→				strings.Contains(errMsg, "invalid argument") ||
  1443→				strings.Contains(errMsg, "required flag") ||
  1444→				strings.Contains(errMsg, "accepts") || // e.g., "accepts 1 arg(s), received 2"
  1445→				strings.Contains(errMsg, "no such flag") ||
  1446→				strings.Contains(errMsg, "flag needs an argument")
  1447→
  1448→			if isCommandError {
  1449→				_ = rootCmd.Usage() // Ignore error; we're exiting anyway
  1450→				fmt.Println()       // Add visual separation after usage for better CLI readability
  1451→			}
  1452→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1453→			os.Exit(1)
  1454→		}
  1455→	}
  1456→}
  1457→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:39Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find config package usage in pkg directory

`grep -r "config\." /Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg --include="*.go" | grep -v ".specstory" | head -30`
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:38Z)**_

Perfect! Now let me look at a couple more command creation examples to fully understand the pattern:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:39Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/cmd/check.go`

```text
     1→// Package cmd contains CLI command implementations for the SpecStory CLI.
     2→package cmd
     3→
     4→import (
     5→	"errors"
     6→	"fmt"
     7→	"log/slog"
     8→	"strings"
     9→
    10→	"github.com/spf13/cobra"
    11→
    12→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    13→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/factory"
    14→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/utils"
    15→)
    16→
    17→// CreateCheckCommand dynamically creates the check command with provider information.
    18→func CreateCheckCommand() *cobra.Command {
    19→	registry := factory.GetRegistry()
    20→	ids := registry.ListIDs()
    21→
    22→	// Build dynamic examples
    23→	var examplesBuilder strings.Builder
    24→	examplesBuilder.WriteString(`
    25→# Check all coding agents
    26→specstory check`)
    27→
    28→	if len(ids) > 0 {
    29→		examplesBuilder.WriteString("\n\n# Check specific coding agent")
    30→		for _, id := range ids {
    31→			fmt.Fprintf(&examplesBuilder, "\nspecstory check %s", id)
    32→		}
    33→
    34→		// Use first provider for custom command example
    35→		fmt.Fprintf(&examplesBuilder, "\n\n# Check a specific coding agent with a custom command\nspecstory check %s -c \"/custom/path/to/agent\"", ids[0])
    36→	}
    37→	examples := examplesBuilder.String()
    38→
    39→	cmd := &cobra.Command{
    40→		Use:   "check [provider-id]",
    41→		Short: "Check if terminal coding agents are properly installed",
    42→		Long: `Check if terminal coding agents are properly installed and can be invoked by SpecStory.
    43→
    44→By default, checks all registered coding agents providers.
    45→Specify a specific agent ID to check only a specific coding agent.`,
    46→		Example: examples,
    47→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument
    48→		RunE: func(cmd *cobra.Command, args []string) error {
    49→			slog.Info("Running in check-install mode")
    50→			registry := factory.GetRegistry()
    51→
    52→			// Get custom command if provided via flag
    53→			customCmd, _ := cmd.Flags().GetString("command")
    54→
    55→			// Validate that -c flag requires a provider
    56→			if customCmd != "" && len(args) == 0 {
    57→				registry := factory.GetRegistry()
    58→				ids := registry.ListIDs()
    59→				example := "specstory check <provider> -c \"/custom/path/to/agent\""
    60→				if len(ids) > 0 {
    61→					example = fmt.Sprintf("specstory check %s -c \"/custom/path/to/agent\"", ids[0])
    62→				}
    63→				return utils.ValidationError{
    64→					Message: "The -c/--command flag requires a provider to be specified.\n" +
    65→						"Example: " + example,
    66→				}
    67→			}
    68→
    69→			if len(args) == 0 {
    70→				// Check all providers
    71→				return checkAllProviders(registry)
    72→			} else {
    73→				// Check specific provider
    74→				return checkSingleProvider(registry, args[0], customCmd)
    75→			}
    76→		},
    77→	}
    78→
    79→	cmd.Flags().StringP("command", "c", "", "custom agent execution command for the provider")
    80→
    81→	return cmd
    82→}
    83→
    84→// printDivider prints a divider line for visual separation
    85→func printDivider() {
    86→	fmt.Println("\n--------")
    87→}
    88→
    89→// checkSingleProvider checks a specific provider
    90→func checkSingleProvider(registry *factory.Registry, providerID, customCmd string) error {
    91→	provider, err := registry.Get(providerID)
    92→	if err != nil {
    93→		// Provider not found - show helpful error
    94→		fmt.Printf("❌ Provider '%s' is not a valid provider implementation\n\n", providerID)
    95→
    96→		ids := registry.ListIDs()
    97→		if len(ids) > 0 {
    98→			fmt.Println("The registered providers are:")
    99→			for _, id := range ids {
   100→				if p, _ := registry.Get(id); p != nil {
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:39Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/cmd/version.go`

```text
     1→// Package cmd contains CLI command implementations for the SpecStory CLI.
     2→package cmd
     3→
     4→import (
     5→	"fmt"
     6→
     7→	"github.com/spf13/cobra"
     8→
     9→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    10→)
    11→
    12→// CreateVersionCommand creates the version command.
    13→// The version string is passed in because it's set at build time in main.go.
    14→func CreateVersionCommand(version string) *cobra.Command {
    15→	return &cobra.Command{
    16→		Use:     "version",
    17→		Aliases: []string{"v", "ver"},
    18→		Short:   "Show SpecStory version information",
    19→		Run: func(cmd *cobra.Command, args []string) {
    20→			// Track version command usage
    21→			analytics.TrackEvent(analytics.EventVersionCommand, analytics.Properties{
    22→				"version": version,
    23→			})
    24→			fmt.Printf("%s (SpecStory)\n", version)
    25→		},
    26→	}
    27→}
    28→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:40Z)**_

Let me search for more config usage patterns:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:42Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find all usages of config getter methods

`grep -r "IsVersionCheckEnabled\|IsCloudSyncEnabled\|IsLocalSyncEnabled\|IsConsoleEnabled\|IsLogEnabled\|IsDebugEnabled\|IsSilentEnabled\|IsAnalyticsEnabled" /Users/sean/Source/SpecStory/getspecstory/specstory-cli --include="*.go" | grep -v ".specstory"`
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:42Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find documentation files

`find /Users/sean/Source/SpecStory/getspecstory/specstory-cli -name "*.md" -type f | head -20`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/changelog.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/.what-is-this.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-20_21-04-48Z-recent-cursor-cli-session.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-10_22-12-29Z-command-name-copy-command.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-29_15-58-30Z-the-droid-provider-uses.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-29_16-26-43Z-command-message-pr-review.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-16_16-27-42Z-implement-the-following-plan.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-11_22-34-04Z-command-message-pr-review.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-10_14-21-48Z-ok-read-at-docs.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-16_16-46-41Z-command-name-exit-command.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-25_23-00-06Z-command-message-pr-review.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-31_14-47-58Z-take-a-look-at.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-11_21-43-59Z-command-name-extra-usage.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-12_17-20-59Z-notice-what-we-did.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-11_16-29-09Z-command-message-code-review.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-25_14-58-39Z-01-25-26-9.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-31_15-39-29Z-when-running-specstory-sync.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-16_22-28-53Z-after-a-cloud-sync.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-01-25_22-47-22Z-the-coordinated-universtal-timezone.md
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/.specstory/history/2026-02-16_13-04-52Z-in-the-claude-code.md
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:44Z)**_

Let me check the README and other documentation:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:45Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
List markdown files in root

`ls -la /Users/sean/Source/SpecStory/getspecstory/specstory-cli/*.md`

```text
lrwxr-xr-x  1 sean  staff      9 Jan 16 09:22 /Users/sean/Source/SpecStory/getspecstory/specstory-cli/AGENT.md -> CLAUDE.md
-rw-r--r--  1 sean  staff  21017 Feb 22 09:42 /Users/sean/Source/SpecStory/getspecstory/specstory-cli/changelog.md
-rw-r--r--  1 sean  staff   5524 Feb 22 10:10 /Users/sean/Source/SpecStory/getspecstory/specstory-cli/CLAUDE.md
-rw-r--r--  1 sean  staff  10993 Feb 22 09:42 /Users/sean/Source/SpecStory/getspecstory/specstory-cli/README.md
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:46Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find all documentation files excluding .specstory

`find /Users/sean/Source/SpecStory/getspecstory/specstory-cli -maxdepth 2 -name "*.md" -type f | grep -v ".specstory"`
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:47Z)**_

Now let me read the README to understand the project better:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:47Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./README.md`

```text
     1→<img width="1649" height="158" alt="Group 6 (1)" src="https://github.com/user-attachments/assets/93f0210f-c3ce-4035-91df-ec597e00a3ce" />
     2→
     3→# Intent is the new source code
     4→
     5→**Turn your AI development conversations into searchable, shareable knowledge.**
     6→
     7→## SpecStory CLI
     8→
     9→SpecStory CLI is a cross-platform command-line tool for saving AI coding coversations from terminal coding agents (e.g. Claude Code, Cursor CLI, Codex CLI, Gemini CLI, Droid CLI, etc.).
    10→
    11→It saves your AI coding conversations as local markdown files of each session. It can optionally sync your markdown files to the [SpecStory Cloud](https://cloud.specstory.com), turning your AI chat history into a centralized knowledge system that you can chat with and search.
    12→
    13→## Features
    14→
    15→- Cross-platform support (Linux, macOS)
    16→- Seamless integration with terminal coding agents
    17→- Command-line wrapper for terminal coding agents with markdown auto-save
    18→- Sync all your prior conversations to local markdown files
    19→- Optional: Syncs your markdown files to the SpecStory Cloud for easy search and chat
    20→- Open source under the Apache 2.0 license
    21→
    22→## Agent Support
    23→
    24→The following coding agents are supported in the SpecStory CLI:
    25→
    26→| Agent                                                     | Provider                                | Data Format | Source Location        |
    27→|-----------------------------------------------------------|-----------------------------------------|-------------|------------------------|
    28→| [Claude Code](https://www.claude.com/product/claude-code) | [claudecode](pkg/providers/claudecode/) | JSONL       | `~/.claude/projects/`  |
    29→| [Codex CLI](https://www.openai.com/codex/cli/)            | [codexcli](pkg/providers/codexcli/)     | JSONL       | `~/.codex/sessions/`   |
    30→| [Cursor CLI](https://cursor.com/cli)                      | [cursorcli](pkg/providers/cursorcli/)   | SQLite      | `~/.cursor/chats/`     |
    31→| [Droid CLI](https://factory.ai/product/cli)               | [droidcli](pkg/providers/droidcli/)     | JSONL       | `~/.factory/sessions/` |
    32→| [Gemini CLI](https://ai.google.dev/gemini-cli)            | [geminicli](pkg/providers/geminicli/)   | JSON        | `~/.gemini/tmp/`       |
    33→
    34→### Agent Provider SPI (Service Provider Interface)
    35→
    36→There is also an [Agent SPI (Service Provider Interface)](/pkg/spi/) that allows you to extend the SpecStory CLI with support for new agent providers. Creating a provider to support a new agent, using the Provider SPI is documented [here](./docs/PROVIDER-SPI.md). Pull requests are welcome!
    37→
    38→## Installation & Usage
    39→
    40→Full end-user installation and usage instructions are in the [SpecStory CLI Documentation](https://docs.specstory.com/integrations/terminal-coding-agents). Installation for developers is covered [here](#development).
    41→
    42→### Quickstart Usage
    43→
    44→Basic usage: `specstory [flags]`
    45→
    46→For help:
    47→
    48→```zsh
    49→specstory help
    50→```
    51→
    52→or
    53→
    54→```zsh
    55→specstory help <command>
    56→# e.g.
    57→specstory help run
    58→```
    59→
    60→Interactive auto-save mode:
    61→
    62→```zsh
    63→# Defaults to Claude Code if no provider is specified.
    64→specstory run <provider>
    65→# e.g.
    66→specstory run codex
    67→```
    68→
    69→Syncing all files for the current project:
    70→
    71→```zsh
    72→# Defaults to syncing for all providers if no provider is specified
    73→specstory sync <provider>
    74→```
    75→
    76→With a specific session UUID:
    77→
    78→```zsh
    79→specstory sync -s <session-uuid>
    80→```
    81→
    82→## Configuration File
    83→
    84→SpecStory CLI supports configuration files in TOML format. Settings can be configured at two levels:
    85→
    86→1. **User-level config**: `~/.specstory/cli-config.toml` - applies to all projects
    87→2. **Project-level config**: `.specstory/cli-config.toml` - applies only to the current project
    88→
    89→Configuration is loaded with the following priority (highest to lowest):
    90→1. CLI flags
    91→2. Project-level config (`.specstory/cli-config.toml`)
    92→3. User-level config (`~/.specstory/cli-config.toml`)
    93→
    94→### Example Configuration
    95→
    96→```toml
    97→# Custom output directory for markdown and debug files
    98→output_dir = "/path/to/output"
    99→
   100→[version_check]
   101→# Check for newer versions on startup (default: true)
   102→enabled = true
   103→
   104→[cloud_sync]
   105→# Sync sessions to SpecStory Cloud (default: true)
   106→enabled = true
   107→
   108→[local_sync]
   109→# Write local markdown files (default: true)
   110→# When false, only cloud sync is performed (equivalent to --only-cloud-sync)
   111→enabled = true
   112→
   113→[logging]
   114→# Enable console output for error/warn/info messages (default: false)
   115→console = false
   116→# Write logs to .specstory/debug/debug.log (default: false)
   117→log = false
   118→# Enable debug-level logging output (default: false)
   119→debug = false
   120→# Suppress all non-error output (default: false)
   121→silent = false
   122→
   123→[analytics]
   124→# Send anonymous usage analytics (default: true)
   125→enabled = true
   126→```
   127→
   128→### Configuration Options
   129→
   130→| Section | Option | Default | Description |
   131→|---------|--------|---------|-------------|
   132→| (root) | `output_dir` | `.specstory/history` | Custom output directory for markdown files |
   133→| `[version_check]` | `enabled` | `true` | Check for newer CLI versions on startup |
   134→| `[cloud_sync]` | `enabled` | `true` | Sync sessions to SpecStory Cloud |
   135→| `[local_sync]` | `enabled` | `true` | Write local markdown files |
   136→| `[logging]` | `console` | `false` | Output logs to stdout |
   137→| `[logging]` | `log` | `false` | Write logs to debug file |
   138→| `[logging]` | `debug` | `false` | Enable debug-level output |
   139→| `[logging]` | `silent` | `false` | Suppress non-error output |
   140→| `[analytics]` | `enabled` | `true` | Send anonymous usage analytics |
   141→
   142→## Development
   143→
   144→### Development Prerequisites
   145→
   146→- macOS development environment
   147→- Go 1.25.1 or later
   148→- golangci-lint, latest version
   149→- Access to one or more terminal coding agents (e.g. Claude Code, Codex CLI, etc.)
   150→
   151→You'll want [Homebrew](https://brew.sh/) installed on your macOS system. Then:
   152→
   153→```zsh
   154→brew install go golangci-lint
   155→```
   156→
   157→You'll also want this test helper:
   158→
   159→```zsh
   160→go install gotest.tools/gotestsum@latest
   161→```
   162→
   163→### Building from source
   164→
   165→```zsh
   166→# Clone the repository
   167→git clone https://github.com/specstoryai/specstory-cli.git
   168→
   169→# Navigate to the project directory
   170→cd specstory-cli
   171→
   172→# Build the project
   173→go build -o specstory
   174→```
   175→
   176→You can then run the built executable from there.
   177→
   178→### Check for Outdated Dependencies
   179→
   180→```zsh
   181→go list -m -u all
   182→```
   183→
   184→### Debug Raw Mode
   185→
   186→The `--debug-raw` flag enables a debug mode that is useful for developers working on the SpecStory CLI. It outputs the raw data from AI coding agents in a pretty-printed format. This hidden flag works with all operation modes and supports all providers (Claude Code, Cursor CLI, Codex CLI, Gemini CLI, Droid CLI).
   187→
   188→When enabled, it creates a debug directory structure under `.specstory/debug/` with individual pretty-printed JSON files for each record in the session as well as a JSON version of the SessionData returned from the provider for that session.
   189→
   190→This mode is useful for:
   191→- Understanding the raw data structure from different AI coding agents
   192→- Analyzing conversation flow and metadata
   193→- Debugging parsing issues
   194→- Troubleshooting agent-specific data formats
   195→
   196→Run mode with debug output:
   197→
   198→```zsh
   199→./specstory run --debug-raw
   200→```
   201→
   202→Sync mode with debug output:
   203→
   204→```zsh
   205→./specstory sync --debug-raw
   206→```
   207→
   208→Sync specific session with debug output:
   209→
   210→```zsh
   211→./specstory sync -s <session-id> --debug-raw
   212→```
   213→
   214→**Output Structure:**
   215→
   216→```
   217→.specstory/debug/
   218→└── <session-uuid>/
   219→    ├── 1.json      # Claude Code: sequential numbering
   220→    ├── 2.json      # Cursor CLI: based on rowid
   221→    ├── 3.json
   222→    └── ...
   223→    └── session-data.json # JSON version of the SessionData returned from the provider for this session
   224→```
   225→
   226→Each JSON file is pretty-printed with 2-space indentation. For Claude Code, files are numbered sequentially based on their position in the JSONL file. For Cursor CLI, files are numbered based on the SQLite rowid.
   227→
   228→**Example:**
   229→
   230→If processing a session with ID `30cc3569-a9d4-429e-981a-ab73e3ddee5f`, the debug files will be created in: `.specstory/debug/30cc3569-a9d4-429e-981a-ab73e3ddee5f/`
   231→
   232→## Testing
   233→
   234→To run all tests with easy to read output:
   235→
   236→```zsh
   237→gotestsum ./...
   238→```
   239→
   240→Run tests with verbose output:
   241→
   242→```zsh
   243→go test -v ./...
   244→```
   245→
   246→Test specific packages:
   247→
   248→```zsh
   249→go test -v ./pkg/cli 
   250→```
   251→
   252→Run specific tests (e.g., filename generation tests)
   253→
   254→```zsh
   255→go test  -v ./pkg/cli -run TestGenerateFilenameFromUserMessage
   256→```
   257→
   258→Testing specific features
   259→
   260→```zsh
   261→# Test the new filename generation logic
   262→go test -v ./pkg/cli -run "TestExtractWordsFromMessage|TestGenerateFilenameFromWords|TestGenerateFilenameFromUserMessage"
   263→```
   264→
   265→## Linting
   266→
   267→This project uses [golangci-lint](https://golangci-lint.run/) for code quality checks. The configuration enables all default linters plus `gofmt` and `goimports` for consistent formatting.
   268→
   269→### Running the linter
   270→
   271→Check all Go files in the project:
   272→
   273→```zsh
   274→golangci-lint run
   275→```
   276→
   277→Automatically fix issues where possible:
   278→
   279→```zsh
   280→golangci-lint run --fix
   281→```
   282→
   283→Check a specific package:
   284→
   285→```zsh
   286→golangci-lint run ./pkg/analytics/...
   287→```
   288→
   289→**Note:** Always run the linter on directories or packages, not individual files. Running on single files can cause false positives where symbols from other files in the same package cannot be resolved.
   290→
   291→Format code:
   292→
   293→```zsh
   294→gofmt -w .
   295→```
   296→
   297→### Linter Configuration
   298→
   299→The linter configuration is in `.golangci.yml`. Key linters include:
   300→- **errcheck**: Ensures error return values are checked
   301→- **gofmt**: Enforces standard Go formatting
   302→- **goimports**: Manages import statements
   303→- **staticcheck**: Comprehensive bug detection
   304→- **govet**: Reports suspicious constructs
   305→
   306→To see all enabled linters:
   307→
   308→```zsh
   309→golangci-lint linters
   310→```
   311→
   312→## Analytics
   313→
   314→SpecStory CLI collects anonymous usage analytics to PostHog to help improve the product. The following events are tracked:
   315→
   316→- Extension activation (in interacive mode) - ext_activated
   317→- Successful markdown sync operations - ext_sync_markdown_success
   318→- Failed markdown sync operations - ext_sync_markdown_error
   319→- First-time autosave of new sessions - ext_autosave_success
   320→- Failed first-time autosave of new sessions - ext_autosave_error
   321→
   322→All analytics are processed through PostHog with GeoIP enabled for general location data.
   323→
   324→### Disabling Analytics
   325→
   326→To opt out of analytics tracking, use the `--no-usage-analytics` flag:
   327→
   328→```bash
   329→specstory --no-usage-analytics [other options]
   330→```
   331→
   332→**Note**: Error tracking events include a 500ms delay before the program exits to ensure events are sent successfully. This is necessary because PostHog sends events asynchronously.
   333→
   334→### Development Analytics
   335→
   336→Analytics are disabled in development builds by default. To enable analytics during local development, build with the PostHog API key:
   337→
   338→```zsh
   339→export POSTHOG_API_KEY="your-posthog-api-key"
   340→go build -ldflags "-X github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics.apiKey=$POSTHOG_API_KEY" -o specstory ./
   341→```
   342→
   343→## License
   344→
   345→The SpecStory CLI is licensed under the [Apache 2.0 open source license](LICENSE.txt).
   346→
   347→Copyright 2025-2026 by SpecStory, Inc., All Rights Reserved.
   348→
   349→SpecStory® is a registered trademark of SpecStory, Inc.
   350→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:48Z)**_

Perfect! Now let me search for any example config files that might exist in the codebase:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:50Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find config files and examples

`find /Users/sean/Source/SpecStory/getspecstory/specstory-cli -name "*.toml" -o -name "*config*" -type f | grep -v ".specstory" | grep -v ".git"`
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:50Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Check for docs directory

`ls -la /Users/sean/Source/SpecStory/getspecstory/specstory-cli/docs 2>/dev/null || echo "No docs directory"`

```text
total 312
drwxr-xr-x  16 sean  staff    512 Feb 22 09:42 .
drwxr-xr-x  21 sean  staff    672 Feb 22 10:13 ..
-rw-r--r--   1 sean  staff  21877 Feb 22 09:42 AI-PROVENANCE.md
-rw-r--r--   1 sean  staff  16958 Jan 16 09:22 BATCH-HEAD.md
-rw-r--r--   1 sean  staff   3865 Feb 16 09:58 CLI-RELEASE.md
-rw-r--r--   1 sean  staff   2018 Jan 16 09:22 CLI-VERSION-CHECK.md
-rw-r--r--   1 sean  staff   5195 Jan 16 09:22 CLOUD-AUTH.md
-rw-r--r--   1 sean  staff  15013 Jan 16 09:22 CLOUD-DEBOUNCE.md
-rw-r--r--   1 sean  staff   7908 Jan 16 09:22 CLOUD-SYNC-HEAD-OPTIMIZATION.md
drwxr-xr-x   8 sean  staff    256 Feb 22 09:42 git-provenance
-rw-r--r--   1 sean  staff   8458 Jan 16 18:08 HOMEBREW-SETUP.md
-rw-r--r--   1 sean  staff   4613 Jan 28 08:07 POSTHOG.md
-rw-r--r--   1 sean  staff   2624 Jan 16 09:22 PROJECT-IDENTITY.md
-rw-r--r--   1 sean  staff  16381 Jan 16 09:22 PROVIDER-SPI.md
-rw-r--r--   1 sean  staff  10050 Feb 22 09:42 SHELL-PATH-HINTS.md
-rw-r--r--   1 sean  staff  16679 Jan 16 09:22 SPI-SESSION-DATA-SCHEMA.md
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:51Z)**_

Excellent! Let me check if there's any documentation specifically about the config file:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:52Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Search docs for config-related documentation

`grep -r "cli-config\|configuration\|TOML" /Users/sean/Source/SpecStory/getspecstory/specstory-cli/docs --include="*.md" | head -20`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/docs/git-provenance/systems/cnotes.md:4. Team sharing requires explicit notes push/fetch configuration.
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/docs/git-provenance/systems/whogitit.md:- Per-repo init for git hooks and note configuration.
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/docs/POSTHOG.md:See `.goreleaser.yml` for build configuration and `.github/workflows/release.yml` for how the `POSTHOG_API_KEY` secret is passed during release builds.
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/docs/POSTHOG.md:- `client.go` - PostHog client initialization and configuration
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:53Z)**_

Now let me check the directory structure to understand how config is organized:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:54Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
List config package contents

`ls -la /Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/`

```text
total 56
drwxr-xr-x   4 sean  staff    128 Feb 22 09:42 .
drwxr-xr-x  12 sean  staff    384 Feb 22 09:42 ..
-rw-r--r--   1 sean  staff  15238 Feb 22 09:42 config_test.go
-rw-r--r--   1 sean  staff   8511 Feb 22 09:42 config.go
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:55Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find all uses of config loading

`grep -r "CLIOverrides\|Load(" /Users/sean/Source/SpecStory/getspecstory/specstory-cli --include="*.go" -n | grep -v ".specstory" | head -20`
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:56Z)**_

Let me search for config usage in main.go more carefully:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:57Z)**_

Perfect! I now have a comprehensive understanding of the CLI startup flow. Let me provide a detailed report.

## CLI Startup Flow Analysis

I've explored the complete startup sequence and identified exactly where config is loaded and where you could hook in logic to check for and create a default config file. Here's what I found:

### 1. **Entry Point: `main.go` (lines 1162-1456)**

The startup sequence is:

**Step 1: Early Flag Parsing (lines 1163-1192)**
- Manual parsing of critical flags (`--no-usage-analytics`, `--console`, `--log`, `--debug`, `--silent`, `--no-version-check`, `--output-dir`)
- This happens before Cobra's normal parsing to handle flags that affect early initialization

**Step 2: Config Loading (lines 1194-1210)**
```go
cfg, cfgErr := config.Load(&config.CLIOverrides{...})
```
- Happens AFTER early flag parsing, BEFORE logging setup
- Loads config from:
  1. User-level: `~/.specstory/cli-config.toml` (lowest priority)
  2. Local project: `.specstory/cli-config.toml` (overwrites user config)
  3. CLI flags (highest priority, applied after file loading)
- Returns error if config file exists but has parsing errors (required behavior)
- Returns nil error if config file is missing (missing files are skipped)

**Step 3: Apply Config to Flag Variables (lines 1212-1224)**
- Merges loaded config with already-parsed CLI flags

**Step 4: Logger Setup (lines 1226-1237)**
- Sets up logging (console/file) based on config + CLI flags

**Step 5: Command Creation (lines 1239-1268)**
- Creates all commands (`run`, `watch`, `sync`, `list`, `check`, `version`, `login`, `logout`)
- Each command is created dynamically with provider information

**Step 6: Flag Definition (lines 1270-1304)**
- Defines persistent and command-specific flags on the root and sub-commands

**Step 7: Analytics Initialization (lines 1306-1318)**

**Step 8: Version Check (line 1326)**

**Step 9: Defer Cleanup (lines 1329-1415)**

**Step 10: Command Execution via Cobra (line 1417)**

### 2. **Config Loading: `pkg/config/config.go`**

The `Load()` function (lines 105-143):

```go
func Load(cliOverrides *CLIOverrides) (*Config, error) {
    cfg := &Config{}
    
    // Load user-level config first (lowest priority)
    userConfigPath := getUserConfigPath()  // ~/.specstory/cli-config.toml
    
    // Load local project config (overwrites user-level)
    localConfigPath := getLocalConfigPath()  // .specstory/cli-config.toml
    
    // Apply CLI flag overrides (highest priority)
    
    return cfg, nil
}
```

Key behaviors:
- Returns error ONLY if config file exists but can't be parsed
- Missing config files are silently skipped
- Both user-level and project-level configs are optional
- `loadTOMLFile()` uses BurntSushi/toml library for parsing

### 3. **Command Structure Pattern**

Each command is created with a factory function in `pkg/cmd/`:
- `CreateRunCommand()` in main.go
- `CreateSyncCommand()` in main.go
- `CreateWatchCommand()` in watch.go
- `CreateCheckCommand()` in check.go
- `CreateVersionCommand()` in version.go
- `CreateListCommand()` in list.go
- etc.

All commands inherit from the **root command** which has a `PersistentPreRunE` hook (lines 145-223 in main.go):

```go
rootCmd := &cobra.Command{
    // ...
    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
        // Validate flags
        // Configure logging
        // Initialize cloud sync manager
        // Handle authentication
        
        return nil
    },
    // ...
}
```

This hook runs **before ANY subcommand** - it's the ideal place to hook in config initialization logic.

### 4. **Ideal Hook Points for Default Config Creation**

You have **two excellent options**:

**Option A: In `config.Load()` function (pkg/config/config.go)**
- **Pros**: 
  - Centralized, clean separation of concerns
  - Happens early (before logging, before commands)
  - Can handle both user-level and project-level config creation
  - Doesn't pollute main.go
- **Cons**:
  - Slightly less visible since it's in a separate package

**Option B: In `main.go` after `config.Load()` (around line 1210)**
- **Pros**:
  - Explicit, visible in the startup flow
  - Has access to parsed flags and logging setup options
- **Cons**:
  - Main.go is already large and complex

**Option C: In root command's `PersistentPreRunE` hook (main.go, line 145)**
- **Pros**:
  - Runs for ALL commands automatically
  - After logging is set up
- **Cons**:
  - Runs for EVERY command invocation (even `--help`, `--version`)
  - Less efficient than doing it at startup

### 5. **Key Files and Paths**

Absolute paths for reference:
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/main.go` - Entry point, config loading at line 1194
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go` - Config loading logic
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/cmd/` - Command implementations

Config file paths (runtime determined):
- User-level: `~/.specstory/cli-config.toml`
- Project-level: `.specstory/cli-config.toml` (relative to current working directory)
- History directory: `.specstory/history/` (created by `utils.EnsureHistoryDirectoryExists()`)

### 6. **Implementation Recommendations**

**My recommendation: Option A - Add logic to `config.Load()` function**

Reasoning:
1. It's the natural place where config files are handled
2. Happens at the right time in startup sequence (before any command runs)
3. Keeps concerns separated - config package handles config
4. Has clean error handling pattern already in place
5. Can create default config templates if needed
6. Won't add overhead to commands that don't need it

The implementation would:
- Check if `.specstory/cli-config.toml` exists after loading attempts
- If it doesn't exist, create it with sensible defaults
- Return the config as normal (whether freshly created or loaded)
- This integrates seamlessly with the current priority system: user-level → local → defaults

Would you like me to analyze any specific part of the code further, or are you ready to move forward with implementation?

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:19:57Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Find all config usage in main.go

`grep -n "config\." /Users/sean/Source/SpecStory/getspecstory/specstory-cli/main.go | head -50`

```text
161:					logPath = config.GetLogPath()
813:	historyPath := config.GetHistoryDir()
1196:	cfg, cfgErr := config.Load(&config.CLIOverrides{
1209:		cfg = &config.Config{}
1213:	// This merges TOML config with CLI flags (CLI flags take precedence via config.Load).
1231:			logPath = config.GetLogPath()
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-02-22 15:20:13Z)**_

Perfect! Now I have a comprehensive understanding. Let me create a thorough report:

## Configuration System Analysis for SpecStory CLI

I've thoroughly explored the configuration system in the SpecStory CLI. Here's a comprehensive breakdown:

### 1. Config File Structure (TOML Format)

All configurable fields are defined in `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go`:

**Root-level options:**
- `output_dir` (string) - Custom output directory for markdown and debug files

**Nested sections:**

**`[version_check]`**
- `enabled` (boolean pointer, default: true) - Check for newer versions on startup

**`[cloud_sync]`**
- `enabled` (boolean pointer, default: true) - Enable syncing to SpecStory Cloud

**`[local_sync]`**
- `enabled` (boolean pointer, default: true) - Write local markdown files. When false, equivalent to `--only-cloud-sync`

**`[logging]`**
- `console` (boolean pointer, default: false) - Output error/warn/info to stdout
- `log` (boolean pointer, default: false) - Write logs to `.specstory/debug/debug.log`
- `debug` (boolean pointer, default: false) - Enable debug-level output (requires console or log)
- `silent` (boolean pointer, default: false) - Suppress all non-error output

**`[analytics]`**
- `enabled` (boolean pointer, default: true) - Send anonymous usage analytics

### 2. Configuration Loading Priority Order

From highest to lowest priority:
1. **CLI flags** (e.g., `--console`, `--no-cloud-sync`)
2. **Local project config** - `.specstory/cli-config.toml` (in current working directory)
3. **User-level config** - `~/.specstory/cli-config.toml` (in home directory)

This is implemented in the `Load()` function at lines 105-144 of `config.go`.

### 3. Home Directory Config Path Definition

The home directory path is defined in the `getUserConfigPath()` function (lines 146-154 of `config.go`):

```go
func getUserConfigPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		slog.Debug("Could not determine home directory", "error", err)
		return ""
	}
	return filepath.Join(home, SpecStoryDir, ConfigFileName)
}
```

**Constants used:**
- `SpecStoryDir = ".specstory"` (line 24)
- `ConfigFileName = "cli-config.toml"` (line 22)

So the full path becomes: `~/.specstory/cli-config.toml`

The local project config path (from `getLocalConfigPath()`, lines 156-164) is: `.specstory/cli-config.toml` in the current working directory.

### 4. All Configurable Options Summary

| Section | Option | TOML Type | Default | Description |
|---------|--------|-----------|---------|-------------|
| (root) | `output_dir` | string | (empty) | Custom output directory path |
| `[version_check]` | `enabled` | boolean | true | Version check on startup |
| `[cloud_sync]` | `enabled` | boolean | true | Cloud sync to SpecStory |
| `[local_sync]` | `enabled` | boolean | true | Local markdown file writes |
| `[logging]` | `console` | boolean | false | Console logging to stdout |
| `[logging]` | `log` | boolean | false | File logging to debug.log |
| `[logging]` | `debug` | boolean | false | Debug-level output |
| `[logging]` | `silent` | boolean | false | Suppress non-error output |
| `[analytics]` | `enabled` | boolean | true | Usage analytics collection |

### 5. How Config is Used Throughout the Codebase

**In `main.go` (lines 1194-1224):**
- Config is loaded early (before logging setup) so TOML settings can affect logging behavior
- CLI flags are passed to `config.Load()` as `CLIOverrides` 
- After loading, config values are applied back to flag variables for the rest of the code
- This allows the rest of the codebase to use the unified flag variables without explicitly checking config

**Config getter methods** (all with predictable defaults):
- `GetOutputDir()` - Returns empty string if not set
- `IsVersionCheckEnabled()` - Defaults to true
- `IsCloudSyncEnabled()` - Defaults to true
- `IsLocalSyncEnabled()` - Defaults to true
- `IsConsoleEnabled()` - Defaults to false
- `IsLogEnabled()` - Defaults to false
- `IsDebugEnabled()` - Defaults to false
- `IsSilentEnabled()` - Defaults to false
- `IsAnalyticsEnabled()` - Defaults to true

### 6. Example Configuration File

From README.md (lines 96-126), a complete example:

```toml
# Custom output directory for markdown and debug files
output_dir = "/path/to/output"

[version_check]
enabled = true

[cloud_sync]
enabled = true

[local_sync]
enabled = true

[logging]
console = false
log = false
debug = false
silent = false

[analytics]
enabled = true
```

### 7. Config Loading Behavior Details

- **Missing files**: Not treated as errors. If a config file doesn't exist, it's simply skipped with debug logging.
- **Parse errors**: Returned to the caller as errors. Invalid TOML syntax causes the Load() function to return an error.
- **Field merging**: TOML files are decoded using `DecodeFile()` which merges fields - later calls overwrite earlier values.
- **Boolean pointers**: Config uses `*bool` so that `nil` (not set) can be distinguished from explicit `false`.
- **Graceful degradation**: If config loading fails, main.go falls back to an empty config (lines 1207-1210) and logs the error after logging is set up.

### 8. Testing Coverage

The config package has comprehensive test coverage in `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go`:

- **TestLoadPrecedence** - Verifies priority order (project overrides user config)
- **TestCLIOverrides** - Validates all CLI flags override config file settings
- **TestParseErrorHandling** - Ensures TOML parse errors are returned
- **TestMissingFileHandling** - Confirms missing files don't cause errors
- **TestDefaultValues** - Tests all default values when no config exists

### 9. Documentation

The configuration system is documented in:
- **README.md** (lines 82-141) - User-facing documentation with examples and configuration options table
- **CLAUDE.md** (project instructions) - References config file handling as part of the project technical details
- **config.go** (lines 1-9) - Clear inline documentation of priority and file locations

This is a clean, well-designed configuration system with excellent separation of concerns and comprehensive testing.

_**Agent (claude-opus-4-6 2026-02-22 15:20:16Z)**_

<think><details><summary>Thought Process</summary>
Now I have a good understanding of the codebase. Let me read the actual config.go file to see the exact code before planning.
</details></think>

_**Agent (claude-opus-4-6 2026-02-22 15:20:17Z)**_

Good, I have a solid understanding of the config system and startup flow. Let me read the actual config file to see the exact code before designing the plan.

_**Agent (claude-opus-4-6 2026-02-22 15:20:17Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/config/config.go`

```text
     1→// Package config provides configuration management for the SpecStory CLI.
     2→// Configuration is loaded with the following priority (highest to lowest):
     3→//  1. CLI flags
     4→//  2. Local project config: .specstory/cli-config.toml
     5→//  3. User-level config: ~/.specstory/cli-config.toml
     6→//
     7→// Note: For telemetry settings, environment variables (OTEL_*) take highest priority
     8→// per OpenTelemetry conventions.
     9→package config
    10→
    11→import (
    12→	"fmt"
    13→	"log/slog"
    14→	"os"
    15→	"path/filepath"
    16→
    17→	"github.com/BurntSushi/toml"
    18→)
    19→
    20→const (
    21→	// ConfigFileName is the name of the configuration file
    22→	ConfigFileName = "cli-config.toml"
    23→	// SpecStoryDir is the directory name for SpecStory files
    24→	SpecStoryDir = ".specstory"
    25→)
    26→
    27→// Config represents the complete CLI configuration
    28→type Config struct {
    29→	// OutputDir is the custom output directory for markdown and debug files
    30→	OutputDir string `toml:"output_dir"`
    31→
    32→	VersionCheck VersionCheckConfig `toml:"version_check"`
    33→	CloudSync    CloudSyncConfig    `toml:"cloud_sync"`
    34→	LocalSync    LocalSyncConfig    `toml:"local_sync"`
    35→	Logging      LoggingConfig      `toml:"logging"`
    36→	Analytics    AnalyticsConfig    `toml:"analytics"`
    37→}
    38→
    39→// VersionCheckConfig holds version check settings
    40→type VersionCheckConfig struct {
    41→	// Enabled controls whether to check for newer versions on startup
    42→	Enabled *bool `toml:"enabled"`
    43→}
    44→
    45→// CloudSyncConfig holds cloud sync settings
    46→type CloudSyncConfig struct {
    47→	// Enabled controls whether cloud sync is active
    48→	Enabled *bool `toml:"enabled"`
    49→}
    50→
    51→// LocalSyncConfig holds local file sync settings
    52→type LocalSyncConfig struct {
    53→	// Enabled controls whether local markdown files are written
    54→	// When false, only cloud sync is performed (equivalent to --only-cloud-sync)
    55→	Enabled *bool `toml:"enabled"`
    56→}
    57→
    58→// LoggingConfig holds logging settings
    59→type LoggingConfig struct {
    60→	// Console enables error/warn/info output to stdout
    61→	Console *bool `toml:"console"`
    62→	// Log enables writing error/warn/info output to .specstory/debug/debug.log
    63→	Log *bool `toml:"log"`
    64→	// Debug enables debug-level output (requires Console or Log)
    65→	Debug *bool `toml:"debug"`
    66→	// Silent suppresses all non-error output
    67→	Silent *bool `toml:"silent"`
    68→}
    69→
    70→// AnalyticsConfig holds analytics settings
    71→type AnalyticsConfig struct {
    72→	// Enabled controls whether usage analytics are sent
    73→	Enabled *bool `toml:"enabled"`
    74→}
    75→
    76→// CLIOverrides holds CLI flag values that override config file settings.
    77→// These are applied after config files are loaded.
    78→type CLIOverrides struct {
    79→	// General
    80→	OutputDir string
    81→
    82→	// Version check
    83→	NoVersionCheck bool
    84→
    85→	// Cloud sync
    86→	NoCloudSync   bool
    87→	OnlyCloudSync bool
    88→
    89→	// Logging
    90→	Console bool
    91→	Log     bool
    92→	Debug   bool
    93→	Silent  bool
    94→
    95→	// Analytics
    96→	NoAnalytics bool
    97→}
    98→
    99→// Load reads configuration from files and CLI flags.
   100→// Priority: CLI flags > local project config > user-level config
   101→//
   102→// Returns an error if a config file exists but cannot be parsed (TOML syntax error)
   103→// or cannot be read (permission denied, I/O error). Missing config files are not
   104→// treated as errors - they are simply skipped.
   105→func Load(cliOverrides *CLIOverrides) (*Config, error) {
   106→	cfg := &Config{}
   107→
   108→	// Load user-level config first (lowest priority)
   109→	userConfigPath := getUserConfigPath()
   110→	if userConfigPath != "" {
   111→		if err := loadTOMLFile(userConfigPath, cfg); err != nil {
   112→			if os.IsNotExist(err) {
   113→				slog.Debug("No user-level config file found", "path", userConfigPath)
   114→			} else {
   115→				// Parse error or permission denied - return error to caller
   116→				return cfg, fmt.Errorf("failed to load user config %s: %w", userConfigPath, err)
   117→			}
   118→		} else {
   119→			slog.Debug("Loaded user-level config", "path", userConfigPath)
   120→		}
   121→	}
   122→
   123→	// Load local project config (overwrites user-level)
   124→	localConfigPath := getLocalConfigPath()
   125→	if localConfigPath != "" {
   126→		if err := loadTOMLFile(localConfigPath, cfg); err != nil {
   127→			if os.IsNotExist(err) {
   128→				slog.Debug("No local project config file found", "path", localConfigPath)
   129→			} else {
   130→				// Parse error or permission denied - return error to caller
   131→				return cfg, fmt.Errorf("failed to load project config %s: %w", localConfigPath, err)
   132→			}
   133→		} else {
   134→			slog.Debug("Loaded local project config", "path", localConfigPath)
   135→		}
   136→	}
   137→
   138→	// Apply CLI flag overrides (highest priority for most settings)
   139→	if cliOverrides != nil {
   140→		applyCLIOverrides(cfg, cliOverrides)
   141→	}
   142→
   143→	return cfg, nil
   144→}
   145→
   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
   147→func getUserConfigPath() string {
   148→	home, err := os.UserHomeDir()
   149→	if err != nil {
   150→		slog.Debug("Could not determine home directory", "error", err)
   151→		return ""
   152→	}
   153→	return filepath.Join(home, SpecStoryDir, ConfigFileName)
   154→}
   155→
   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
   157→func getLocalConfigPath() string {
   158→	cwd, err := os.Getwd()
   159→	if err != nil {
   160→		slog.Debug("Could not determine current directory", "error", err)
   161→		return ""
   162→	}
   163→	return filepath.Join(cwd, SpecStoryDir, ConfigFileName)
   164→}
   165→
   166→// loadTOMLFile reads a TOML file and decodes it into the config struct.
   167→// Fields are merged (later calls overwrite earlier values).
   168→func loadTOMLFile(path string, cfg *Config) error {
   169→	_, err := toml.DecodeFile(path, cfg)
   170→	return err
   171→}
   172→
   173→// applyCLIOverrides applies CLI flag overrides to the config.
   174→func applyCLIOverrides(cfg *Config, o *CLIOverrides) {
   175→	// General
   176→	if o.OutputDir != "" {
   177→		cfg.OutputDir = o.OutputDir
   178→	}
   179→
   180→	// Version check (--no-version-check sets enabled to false)
   181→	if o.NoVersionCheck {
   182→		disabled := false
   183→		cfg.VersionCheck.Enabled = &disabled
   184→	}
   185→
   186→	// Cloud sync (--no-cloud-sync sets enabled to false)
   187→	if o.NoCloudSync {
   188→		disabled := false
   189→		cfg.CloudSync.Enabled = &disabled
   190→	}
   191→
   192→	// Local sync (--only-cloud-sync sets enabled to false)
   193→	if o.OnlyCloudSync {
   194→		disabled := false
   195→		cfg.LocalSync.Enabled = &disabled
   196→	}
   197→
   198→	// Logging flags only override if explicitly set (true)
   199→	if o.Console {
   200→		enabled := true
   201→		cfg.Logging.Console = &enabled
   202→	}
   203→	if o.Log {
   204→		enabled := true
   205→		cfg.Logging.Log = &enabled
   206→	}
   207→	if o.Debug {
   208→		enabled := true
   209→		cfg.Logging.Debug = &enabled
   210→	}
   211→	if o.Silent {
   212→		enabled := true
   213→		cfg.Logging.Silent = &enabled
   214→	}
   215→
   216→	// Analytics (--no-usage-analytics sets enabled to false)
   217→	if o.NoAnalytics {
   218→		disabled := false
   219→		cfg.Analytics.Enabled = &disabled
   220→	}
   221→}
   222→
   223→// --- Getter methods ---
   224→
   225→// GetOutputDir returns the output directory, or empty string to use default.
   226→func (c *Config) GetOutputDir() string {
   227→	return c.OutputDir
   228→}
   229→
   230→// IsVersionCheckEnabled returns whether version check is enabled.
   231→// Defaults to true if not explicitly set.
   232→func (c *Config) IsVersionCheckEnabled() bool {
   233→	if c.VersionCheck.Enabled != nil {
   234→		return *c.VersionCheck.Enabled
   235→	}
   236→	return true // default enabled
   237→}
   238→
   239→// IsCloudSyncEnabled returns whether cloud sync is enabled.
   240→// Defaults to true if not explicitly set.
   241→func (c *Config) IsCloudSyncEnabled() bool {
   242→	if c.CloudSync.Enabled != nil {
   243→		return *c.CloudSync.Enabled
   244→	}
   245→	return true // default enabled
   246→}
   247→
   248→// IsLocalSyncEnabled returns whether local sync is enabled.
   249→// Defaults to true if not explicitly set.
   250→// When false, only cloud sync is performed (equivalent to --only-cloud-sync).
   251→func (c *Config) IsLocalSyncEnabled() bool {
   252→	if c.LocalSync.Enabled != nil {
   253→		return *c.LocalSync.Enabled
   254→	}
   255→	return true // default enabled
   256→}
   257→
   258→// IsConsoleEnabled returns whether console logging is enabled.
   259→// Defaults to false if not explicitly set.
   260→func (c *Config) IsConsoleEnabled() bool {
   261→	if c.Logging.Console != nil {
   262→		return *c.Logging.Console
   263→	}
   264→	return false // default disabled
   265→}
   266→
   267→// IsLogEnabled returns whether file logging is enabled.
   268→// Defaults to false if not explicitly set.
   269→func (c *Config) IsLogEnabled() bool {
   270→	if c.Logging.Log != nil {
   271→		return *c.Logging.Log
   272→	}
   273→	return false // default disabled
   274→}
   275→
   276→// IsDebugEnabled returns whether debug logging is enabled.
   277→// Defaults to false if not explicitly set.
   278→func (c *Config) IsDebugEnabled() bool {
   279→	if c.Logging.Debug != nil {
   280→		return *c.Logging.Debug
   281→	}
   282→	return false // default disabled
   283→}
   284→
   285→// IsSilentEnabled returns whether silent mode is enabled.
   286→// Defaults to false if not explicitly set.
   287→func (c *Config) IsSilentEnabled() bool {
   288→	if c.Logging.Silent != nil {
   289→		return *c.Logging.Silent
   290→	}
   291→	return false // default disabled
   292→}
   293→
   294→// IsAnalyticsEnabled returns whether analytics are enabled.
   295→// Defaults to true if not explicitly set.
   296→func (c *Config) IsAnalyticsEnabled() bool {
   297→	if c.Analytics.Enabled != nil {
   298→		return *c.Analytics.Enabled
   299→	}
   300→	return true // default enabled
   301→}
   302→
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:20:18Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./main.go`

```text
  1190→			outputDir = strings.TrimPrefix(arg, "--output-dir=")
  1191→		}
  1192→	}
  1193→
  1194→	// Load configuration early (before logging setup) so TOML settings can affect logging
  1195→	// Priority: CLI flags > local project config > user-level config
  1196→	cfg, cfgErr := config.Load(&config.CLIOverrides{
  1197→		OutputDir:      outputDir,
  1198→		NoVersionCheck: noVersionCheck,
  1199→		NoCloudSync:    noCloudSync,
  1200→		OnlyCloudSync:  onlyCloudSync,
  1201→		Console:        console,
  1202→		Log:            logFile,
  1203→		Debug:          debug,
  1204→		Silent:         silent,
  1205→		NoAnalytics:    noAnalytics,
  1206→	})
  1207→	if cfgErr != nil {
  1208→		// Use fallback empty config if load fails - will log error after logging is set up
  1209→		cfg = &config.Config{}
  1210→	}
  1211→
  1212→	// Apply config values to flag variables so the rest of the code can use them unchanged.
  1213→	// This merges TOML config with CLI flags (CLI flags take precedence via config.Load).
  1214→	if cfg.GetOutputDir() != "" {
  1215→		outputDir = cfg.GetOutputDir()
  1216→	}
  1217→	noVersionCheck = !cfg.IsVersionCheckEnabled()
  1218→	noCloudSync = !cfg.IsCloudSyncEnabled()
  1219→	onlyCloudSync = !cfg.IsLocalSyncEnabled()
  1220→	noAnalytics = !cfg.IsAnalyticsEnabled()
  1221→	console = cfg.IsConsoleEnabled()
  1222→	logFile = cfg.IsLogEnabled()
  1223→	debug = cfg.IsDebugEnabled()
  1224→	silent = cfg.IsSilentEnabled()
  1225→
  1226→	// Set up logging early before creating commands (which access the registry)
  1227→	if console || logFile {
  1228→		var logPath string
  1229→		if logFile {
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:20:21Z)**_

<think><details><summary>Thought Process</summary>
Now I have a thorough understanding. Let me also check the config_test.go to understand the testing patterns.
</details></think>

_**Agent (claude-opus-4-6 2026-02-22 15:20:21Z)**_

Now let me read the tests to understand testing patterns.

_**Agent (claude-opus-4-6 2026-02-22 15:20:22Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/config/config_test.go`

```text
     1→package config
     2→
     3→import (
     4→	"os"
     5→	"path/filepath"
     6→	"strings"
     7→	"testing"
     8→)
     9→
    10→// Helper to create a temporary config file with the given content
    11→func createTempConfigFile(t *testing.T, dir, content string) string {
    12→	t.Helper()
    13→	specstoryDir := filepath.Join(dir, SpecStoryDir)
    14→	if err := os.MkdirAll(specstoryDir, 0755); err != nil {
    15→		t.Fatalf("Failed to create .specstory dir: %v", err)
    16→	}
    17→	configPath := filepath.Join(specstoryDir, ConfigFileName)
    18→	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
    19→		t.Fatalf("Failed to write config file: %v", err)
    20→	}
    21→	return configPath
    22→}
    23→
    24→// TestLoadPrecedence tests that project config overrides user config
    25→func TestLoadPrecedence(t *testing.T) {
    26→	// Save and restore original working directory
    27→	origWd, err := os.Getwd()
    28→	if err != nil {
    29→		t.Fatalf("Failed to get working directory: %v", err)
    30→	}
    31→	defer func() { _ = os.Chdir(origWd) }()
    32→
    33→	// Save and restore original HOME
    34→	origHome := os.Getenv("HOME")
    35→	defer func() { _ = os.Setenv("HOME", origHome) }()
    36→
    37→	tests := []struct {
    38→		name           string
    39→		userConfig     string
    40→		projectConfig  string
    41→		expectedOutDir string
    42→	}{
    43→		{
    44→			name:           "project config overrides user config",
    45→			userConfig:     `output_dir = "/user/path"`,
    46→			projectConfig:  `output_dir = "/project/path"`,
    47→			expectedOutDir: "/project/path",
    48→		},
    49→		{
    50→			name:           "user config used when no project config",
    51→			userConfig:     `output_dir = "/user/path"`,
    52→			projectConfig:  "",
    53→			expectedOutDir: "/user/path",
    54→		},
    55→		{
    56→			name:           "project config used when no user config",
    57→			userConfig:     "",
    58→			projectConfig:  `output_dir = "/project/path"`,
    59→			expectedOutDir: "/project/path",
    60→		},
    61→		{
    62→			name:           "empty when no config files",
    63→			userConfig:     "",
    64→			projectConfig:  "",
    65→			expectedOutDir: "",
    66→		},
    67→		{
    68→			name: "project nested config overrides user nested config",
    69→			userConfig: `
    70→[cloud_sync]
    71→enabled = true
    72→`,
    73→			projectConfig: `
    74→[cloud_sync]
    75→enabled = false
    76→`,
    77→			expectedOutDir: "", // We check cloud_sync separately below
    78→		},
    79→	}
    80→
    81→	for _, tt := range tests {
    82→		t.Run(tt.name, func(t *testing.T) {
    83→			// Create temp directories for HOME and project
    84→			tempHome := t.TempDir()
    85→			tempProject := t.TempDir()
    86→
    87→			// Set HOME to temp directory
    88→			if err := os.Setenv("HOME", tempHome); err != nil {
    89→				t.Fatalf("Failed to set HOME: %v", err)
    90→			}
    91→
    92→			// Change to temp project directory
    93→			if err := os.Chdir(tempProject); err != nil {
    94→				t.Fatalf("Failed to chdir: %v", err)
    95→			}
    96→
    97→			// Create user config if provided
    98→			if tt.userConfig != "" {
    99→				createTempConfigFile(t, tempHome, tt.userConfig)
   100→			}
   101→
   102→			// Create project config if provided
   103→			if tt.projectConfig != "" {
   104→				createTempConfigFile(t, tempProject, tt.projectConfig)
   105→			}
   106→
   107→			// Load config
   108→			cfg, err := Load(nil)
   109→			if err != nil {
   110→				t.Fatalf("Load() returned error: %v", err)
   111→			}
   112→
   113→			// Check output_dir precedence
   114→			if cfg.GetOutputDir() != tt.expectedOutDir {
   115→				t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), tt.expectedOutDir)
   116→			}
   117→
   118→			// Special check for nested config test
   119→			if tt.name == "project nested config overrides user nested config" {
   120→				if cfg.IsCloudSyncEnabled() {
   121→					t.Errorf("IsCloudSyncEnabled() = true, want false (project should override user)")
   122→				}
   123→			}
   124→		})
   125→	}
   126→}
   127→
   128→// TestCLIOverrides tests that CLI flags override config file settings
   129→func TestCLIOverrides(t *testing.T) {
   130→	// Save and restore original working directory
   131→	origWd, err := os.Getwd()
   132→	if err != nil {
   133→		t.Fatalf("Failed to get working directory: %v", err)
   134→	}
   135→	defer func() { _ = os.Chdir(origWd) }()
   136→
   137→	// Save and restore original HOME
   138→	origHome := os.Getenv("HOME")
   139→	defer func() { _ = os.Setenv("HOME", origHome) }()
   140→
   141→	tests := []struct {
   142→		name       string
   143→		configFile string
   144→		overrides  *CLIOverrides
   145→		checkFunc  func(t *testing.T, cfg *Config)
   146→	}{
   147→		{
   148→			name:       "OutputDir override",
   149→			configFile: `output_dir = "/config/path"`,
   150→			overrides:  &CLIOverrides{OutputDir: "/cli/path"},
   151→			checkFunc: func(t *testing.T, cfg *Config) {
   152→				if cfg.GetOutputDir() != "/cli/path" {
   153→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/cli/path")
   154→				}
   155→			},
   156→		},
   157→		{
   158→			name: "NoVersionCheck override (--no-version-check)",
   159→			configFile: `
   160→[version_check]
   161→enabled = true
   162→`,
   163→			overrides: &CLIOverrides{NoVersionCheck: true},
   164→			checkFunc: func(t *testing.T, cfg *Config) {
   165→				if cfg.IsVersionCheckEnabled() {
   166→					t.Errorf("IsVersionCheckEnabled() = true, want false")
   167→				}
   168→			},
   169→		},
   170→		{
   171→			name: "NoCloudSync override (--no-cloud-sync)",
   172→			configFile: `
   173→[cloud_sync]
   174→enabled = true
   175→`,
   176→			overrides: &CLIOverrides{NoCloudSync: true},
   177→			checkFunc: func(t *testing.T, cfg *Config) {
   178→				if cfg.IsCloudSyncEnabled() {
   179→					t.Errorf("IsCloudSyncEnabled() = true, want false")
   180→				}
   181→			},
   182→		},
   183→		{
   184→			name: "OnlyCloudSync override (--only-cloud-sync)",
   185→			configFile: `
   186→[local_sync]
   187→enabled = true
   188→`,
   189→			overrides: &CLIOverrides{OnlyCloudSync: true},
   190→			checkFunc: func(t *testing.T, cfg *Config) {
   191→				if cfg.IsLocalSyncEnabled() {
   192→					t.Errorf("IsLocalSyncEnabled() = true, want false")
   193→				}
   194→			},
   195→		},
   196→		{
   197→			name: "Console logging override (--console)",
   198→			configFile: `
   199→[logging]
   200→console = false
   201→`,
   202→			overrides: &CLIOverrides{Console: true},
   203→			checkFunc: func(t *testing.T, cfg *Config) {
   204→				if !cfg.IsConsoleEnabled() {
   205→					t.Errorf("IsConsoleEnabled() = false, want true")
   206→				}
   207→			},
   208→		},
   209→		{
   210→			name: "Log file override (--log)",
   211→			configFile: `
   212→[logging]
   213→log = false
   214→`,
   215→			overrides: &CLIOverrides{Log: true},
   216→			checkFunc: func(t *testing.T, cfg *Config) {
   217→				if !cfg.IsLogEnabled() {
   218→					t.Errorf("IsLogEnabled() = false, want true")
   219→				}
   220→			},
   221→		},
   222→		{
   223→			name: "Debug override (--debug)",
   224→			configFile: `
   225→[logging]
   226→debug = false
   227→`,
   228→			overrides: &CLIOverrides{Debug: true},
   229→			checkFunc: func(t *testing.T, cfg *Config) {
   230→				if !cfg.IsDebugEnabled() {
   231→					t.Errorf("IsDebugEnabled() = false, want true")
   232→				}
   233→			},
   234→		},
   235→		{
   236→			name: "Silent override (--silent)",
   237→			configFile: `
   238→[logging]
   239→silent = false
   240→`,
   241→			overrides: &CLIOverrides{Silent: true},
   242→			checkFunc: func(t *testing.T, cfg *Config) {
   243→				if !cfg.IsSilentEnabled() {
   244→					t.Errorf("IsSilentEnabled() = false, want true")
   245→				}
   246→			},
   247→		},
   248→		{
   249→			name: "NoAnalytics override (--no-usage-analytics)",
   250→			configFile: `
   251→[analytics]
   252→enabled = true
   253→`,
   254→			overrides: &CLIOverrides{NoAnalytics: true},
   255→			checkFunc: func(t *testing.T, cfg *Config) {
   256→				if cfg.IsAnalyticsEnabled() {
   257→					t.Errorf("IsAnalyticsEnabled() = true, want false")
   258→				}
   259→			},
   260→		},
   261→		{
   262→			name:       "Empty CLI override doesn't change config value",
   263→			configFile: `output_dir = "/config/path"`,
   264→			overrides:  &CLIOverrides{OutputDir: ""},
   265→			checkFunc: func(t *testing.T, cfg *Config) {
   266→				if cfg.GetOutputDir() != "/config/path" {
   267→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/config/path")
   268→				}
   269→			},
   270→		},
   271→		{
   272→			name:       "Nil CLI overrides doesn't panic",
   273→			configFile: `output_dir = "/config/path"`,
   274→			overrides:  nil,
   275→			checkFunc: func(t *testing.T, cfg *Config) {
   276→				if cfg.GetOutputDir() != "/config/path" {
   277→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/config/path")
   278→				}
   279→			},
   280→		},
   281→	}
   282→
   283→	for _, tt := range tests {
   284→		t.Run(tt.name, func(t *testing.T) {
   285→			// Create temp directories
   286→			tempHome := t.TempDir()
   287→			tempProject := t.TempDir()
   288→
   289→			// Set HOME to empty temp dir (no user config)
   290→			if err := os.Setenv("HOME", tempHome); err != nil {
   291→				t.Fatalf("Failed to set HOME: %v", err)
   292→			}
   293→
   294→			// Change to temp project directory
   295→			if err := os.Chdir(tempProject); err != nil {
   296→				t.Fatalf("Failed to chdir: %v", err)
   297→			}
   298→
   299→			// Create project config
   300→			if tt.configFile != "" {
   301→				createTempConfigFile(t, tempProject, tt.configFile)
   302→			}
   303→
   304→			// Load config with overrides
   305→			cfg, err := Load(tt.overrides)
   306→			if err != nil {
   307→				t.Fatalf("Load() returned error: %v", err)
   308→			}
   309→
   310→			tt.checkFunc(t, cfg)
   311→		})
   312→	}
   313→}
   314→
   315→// TestParseErrorHandling tests that TOML parse errors are returned to the caller
   316→func TestParseErrorHandling(t *testing.T) {
   317→	// Save and restore original working directory
   318→	origWd, err := os.Getwd()
   319→	if err != nil {
   320→		t.Fatalf("Failed to get working directory: %v", err)
   321→	}
   322→	defer func() { _ = os.Chdir(origWd) }()
   323→
   324→	// Save and restore original HOME
   325→	origHome := os.Getenv("HOME")
   326→	defer func() { _ = os.Setenv("HOME", origHome) }()
   327→
   328→	tests := []struct {
   329→		name          string
   330→		configContent string
   331→		wantError     bool
   332→		errorContains string
   333→	}{
   334→		{
   335→			name:          "valid TOML parses successfully",
   336→			configContent: `output_dir = "/valid/path"`,
   337→			wantError:     false,
   338→		},
   339→		{
   340→			name:          "invalid TOML returns error",
   341→			configContent: `this is not valid toml [[[`,
   342→			wantError:     true,
   343→			errorContains: "failed to load project config",
   344→		},
   345→		{
   346→			name:          "unclosed quote returns error",
   347→			configContent: `output_dir = "/unclosed`,
   348→			wantError:     true,
   349→			errorContains: "failed to load project config",
   350→		},
   351→		{
   352→			name:          "invalid table syntax returns error",
   353→			configContent: `[cloud_sync`,
   354→			wantError:     true,
   355→			errorContains: "failed to load project config",
   356→		},
   357→	}
   358→
   359→	for _, tt := range tests {
   360→		t.Run(tt.name, func(t *testing.T) {
   361→			// Create temp directories
   362→			tempHome := t.TempDir()
   363→			tempProject := t.TempDir()
   364→
   365→			// Set HOME to empty temp dir (no user config)
   366→			if err := os.Setenv("HOME", tempHome); err != nil {
   367→				t.Fatalf("Failed to set HOME: %v", err)
   368→			}
   369→
   370→			// Change to temp project directory
   371→			if err := os.Chdir(tempProject); err != nil {
   372→				t.Fatalf("Failed to chdir: %v", err)
   373→			}
   374→
   375→			// Create project config with test content
   376→			createTempConfigFile(t, tempProject, tt.configContent)
   377→
   378→			// Load config
   379→			_, err := Load(nil)
   380→
   381→			if tt.wantError {
   382→				if err == nil {
   383→					t.Errorf("Load() returned no error, want error containing %q", tt.errorContains)
   384→				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
   385→					t.Errorf("Load() error = %q, want error containing %q", err.Error(), tt.errorContains)
   386→				}
   387→			} else {
   388→				if err != nil {
   389→					t.Errorf("Load() returned error: %v, want no error", err)
   390→				}
   391→			}
   392→		})
   393→	}
   394→}
   395→
   396→// TestMissingFileHandling tests that missing config files don't cause errors
   397→func TestMissingFileHandling(t *testing.T) {
   398→	// Save and restore original working directory
   399→	origWd, err := os.Getwd()
   400→	if err != nil {
   401→		t.Fatalf("Failed to get working directory: %v", err)
   402→	}
   403→	defer func() { _ = os.Chdir(origWd) }()
   404→
   405→	// Save and restore original HOME
   406→	origHome := os.Getenv("HOME")
   407→	defer func() { _ = os.Setenv("HOME", origHome) }()
   408→
   409→	tests := []struct {
   410→		name           string
   411→		createUserDir  bool
   412→		createProjDir  bool
   413→		createUserConf bool
   414→		createProjConf bool
   415→		wantError      bool
   416→	}{
   417→		{
   418→			name:           "no config files - no error",
   419→			createUserDir:  false,
   420→			createProjDir:  false,
   421→			createUserConf: false,
   422→			createProjConf: false,
   423→			wantError:      false,
   424→		},
   425→		{
   426→			name:           "only user config exists - no error",
   427→			createUserDir:  true,
   428→			createProjDir:  false,
   429→			createUserConf: true,
   430→			createProjConf: false,
   431→			wantError:      false,
   432→		},
   433→		{
   434→			name:           "only project config exists - no error",
   435→			createUserDir:  false,
   436→			createProjDir:  true,
   437→			createUserConf: false,
   438→			createProjConf: true,
   439→			wantError:      false,
   440→		},
   441→		{
   442→			name:           "both config files exist - no error",
   443→			createUserDir:  true,
   444→			createProjDir:  true,
   445→			createUserConf: true,
   446→			createProjConf: true,
   447→			wantError:      false,
   448→		},
   449→		{
   450→			name:           ".specstory dirs exist but no config files - no error",
   451→			createUserDir:  true,
   452→			createProjDir:  true,
   453→			createUserConf: false,
   454→			createProjConf: false,
   455→			wantError:      false,
   456→		},
   457→	}
   458→
   459→	for _, tt := range tests {
   460→		t.Run(tt.name, func(t *testing.T) {
   461→			// Create temp directories
   462→			tempHome := t.TempDir()
   463→			tempProject := t.TempDir()
   464→
   465→			// Set HOME
   466→			if err := os.Setenv("HOME", tempHome); err != nil {
   467→				t.Fatalf("Failed to set HOME: %v", err)
   468→			}
   469→
   470→			// Change to temp project directory
   471→			if err := os.Chdir(tempProject); err != nil {
   472→				t.Fatalf("Failed to chdir: %v", err)
   473→			}
   474→
   475→			// Create directories if needed
   476→			if tt.createUserDir {
   477→				userSpecstoryDir := filepath.Join(tempHome, SpecStoryDir)
   478→				if err := os.MkdirAll(userSpecstoryDir, 0755); err != nil {
   479→					t.Fatalf("Failed to create user .specstory dir: %v", err)
   480→				}
   481→				if tt.createUserConf {
   482→					configPath := filepath.Join(userSpecstoryDir, ConfigFileName)
   483→					if err := os.WriteFile(configPath, []byte(`output_dir = "/user"`), 0644); err != nil {
   484→						t.Fatalf("Failed to create user config: %v", err)
   485→					}
   486→				}
   487→			}
   488→
   489→			if tt.createProjDir {
   490→				projSpecstoryDir := filepath.Join(tempProject, SpecStoryDir)
   491→				if err := os.MkdirAll(projSpecstoryDir, 0755); err != nil {
   492→					t.Fatalf("Failed to create project .specstory dir: %v", err)
   493→				}
   494→				if tt.createProjConf {
   495→					configPath := filepath.Join(projSpecstoryDir, ConfigFileName)
   496→					if err := os.WriteFile(configPath, []byte(`output_dir = "/project"`), 0644); err != nil {
   497→						t.Fatalf("Failed to create project config: %v", err)
   498→					}
   499→				}
   500→			}
   501→
   502→			// Load config
   503→			_, err := Load(nil)
   504→
   505→			if tt.wantError && err == nil {
   506→				t.Errorf("Load() returned no error, want error")
   507→			}
   508→			if !tt.wantError && err != nil {
   509→				t.Errorf("Load() returned error: %v, want no error", err)
   510→			}
   511→		})
   512→	}
   513→}
   514→
   515→// TestDefaultValues tests that default values are returned when config is empty
   516→func TestDefaultValues(t *testing.T) {
   517→	// Save and restore original working directory
   518→	origWd, err := os.Getwd()
   519→	if err != nil {
   520→		t.Fatalf("Failed to get working directory: %v", err)
   521→	}
   522→	defer func() { _ = os.Chdir(origWd) }()
   523→
   524→	// Save and restore original HOME
   525→	origHome := os.Getenv("HOME")
   526→	defer func() { _ = os.Setenv("HOME", origHome) }()
   527→
   528→	// Create temp directories with no config files
   529→	tempHome := t.TempDir()
   530→	tempProject := t.TempDir()
   531→
   532→	if err := os.Setenv("HOME", tempHome); err != nil {
   533→		t.Fatalf("Failed to set HOME: %v", err)
   534→	}
   535→	if err := os.Chdir(tempProject); err != nil {
   536→		t.Fatalf("Failed to chdir: %v", err)
   537→	}
   538→
   539→	cfg, err := Load(nil)
   540→	if err != nil {
   541→		t.Fatalf("Load() returned error: %v", err)
   542→	}
   543→
   544→	// Test default values
   545→	tests := []struct {
   546→		name     string
   547→		got      bool
   548→		expected bool
   549→	}{
   550→		{"IsVersionCheckEnabled default", cfg.IsVersionCheckEnabled(), true},
   551→		{"IsCloudSyncEnabled default", cfg.IsCloudSyncEnabled(), true},
   552→		{"IsLocalSyncEnabled default", cfg.IsLocalSyncEnabled(), true},
   553→		{"IsAnalyticsEnabled default", cfg.IsAnalyticsEnabled(), true},
   554→		{"IsConsoleEnabled default", cfg.IsConsoleEnabled(), false},
   555→		{"IsLogEnabled default", cfg.IsLogEnabled(), false},
   556→		{"IsDebugEnabled default", cfg.IsDebugEnabled(), false},
   557→		{"IsSilentEnabled default", cfg.IsSilentEnabled(), false},
   558→	}
   559→
   560→	for _, tt := range tests {
   561→		t.Run(tt.name, func(t *testing.T) {
   562→			if tt.got != tt.expected {
   563→				t.Errorf("%s = %v, want %v", tt.name, tt.got, tt.expected)
   564→			}
   565→		})
   566→	}
   567→
   568→	// OutputDir should be empty string (no default path)
   569→	if cfg.GetOutputDir() != "" {
   570→		t.Errorf("GetOutputDir() = %q, want empty string", cfg.GetOutputDir())
   571→	}
   572→}
   573→
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:20:29Z)**_

<think><details><summary>Thought Process</summary>
Now I have a thorough understanding of the codebase. Let me now design the plan. The task is:

1. At startup (any command), check if the `~/.specstory/cli-config.toml` file exists
2. If it doesn't exist, create a default one with all options commented out
3. This helps users discover the config file and know the format

Key considerations:
- The `~/.specstory/` directory may not exist either, so we need to create it
- The default file should have all options documented with comments but commented out
- This should happen in the config package, likely as part of `Load()` or as a separate function called from `Load()`


- I should handle failures gracefully—if we can't create the directory or file due to permissions or other issues, just log it and continue without erroring out
</details></think>

_**Agent (claude-opus-4-6 2026-02-22 15:20:29Z)**_

I have a thorough understanding of the codebase. Let me now design the implementation.

_**Agent (claude-opus-4-6 2026-02-22 15:22:38Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Plan default config creation

```text
I now have a complete understanding of the codebase. Here is the implementation plan.

---

## Implementation Plan: Auto-Create Default `~/.specstory/cli-config.toml`

### Overview

When the `Load()` function detects that `~/.specstory/cli-config.toml` does not exist, it should create a default file with all options commented out. This serves as a discoverability mechanism so users know the config file exists and what options are available.

### 1. Changes to `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go`

#### 1a. Add a const string for the default config template

Add a new constant `defaultConfigTemplate` right after the existing `const` block (after line 25). Using a const string (rather than generating from the struct) is the right approach because:

- It allows rich, human-readable comments explaining each option and its default
- It is trivial to maintain -- when a new config option is added, the developer adds a line to the template
- Generating from struct tags would require reflection and would not produce nice comments

The template content should be:

```go
// defaultConfigTemplate is the commented-out TOML template written to
// ~/.specstory/cli-config.toml when no user-level config file exists.
// This helps users discover available configuration options.
const defaultConfigTemplate = `# SpecStory CLI Configuration
#
# This is the user-level config file for SpecStory CLI.
# All settings here apply to every project unless overridden by a
# project-level config at ./.specstory/cli-config.toml or CLI flags.
#
# Uncomment and edit any setting below to change the default behavior.
# For more information, see: https://github.com/specstoryai/specstory

# Custom output directory for markdown and debug files.
# Default: .specstory (relative to the project directory)
# output_dir = ""

# [version_check]
# Check for newer versions of the CLI on startup.
# Default: true
# enabled = true

# [cloud_sync]
# Sync session data to SpecStory Cloud.
# Default: true
# enabled = true

# [local_sync]
# Write markdown files locally.
# When false, only cloud sync is performed (equivalent to --only-cloud-sync).
# Default: true
# enabled = true

# [logging]
# Console enables error/warn/info output to stdout.
# Default: false
# console = false
#
# Log enables writing error/warn/info output to .specstory/debug/debug.log.
# Default: false
# log = false
#
# Debug enables debug-level output (requires console or log to be enabled).
# Default: false
# debug = false
#
# Silent suppresses all non-error output.
# Default: false
# silent = false

# [analytics]
# Send anonymous usage analytics to help improve SpecStory.
# Default: true
# enabled = true
`
```

Key design decisions for the template:

- Every option is commented out with `#`, so the file has zero effect when first created
- Section headers like `[version_check]` are also commented out -- this is important because an uncommented section header in TOML would be valid even with all keys commented, but it reads more clearly when everything is uniformly commented
- Each option has a comment explaining what it does and what its default is
- A link to the GitHub repo is included for documentation
- The file ends with a trailing newline (Go convention for text files)

#### 1b. Add the `ensureDefaultUserConfig` function

Add a new unexported function after `getUserConfigPath()` (after line 154). This function:

1. Takes the config path as a parameter (for testability -- avoids calling `getUserConfigPath()` internally)
2. Creates the `~/.specstory/` directory if it does not exist
3. Writes the default template to the file
4. Logs success or failure, but never returns an error (failures are non-fatal)

```go
// ensureDefaultUserConfig creates a default user-level config file if one
// does not exist. The file contains all options commented out so users can
// discover and enable them. Failures are logged but not returned because
// the config file is optional -- the CLI works fine without it.
func ensureDefaultUserConfig(path string) {
	// Create the directory (~/.specstory/) if it doesn't exist
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		slog.Debug("Could not create config directory, skipping default config creation",
			"path", dir, "error", err)
		return
	}

	// Write the default template
	if err := os.WriteFile(path, []byte(defaultConfigTemplate), 0644); err != nil {
		slog.Debug("Could not write default config file, skipping",
			"path", path, "error", err)
		return
	}

	slog.Debug("Created default user-level config file", "path", path)
}
```

Design notes:

- Uses `0755` for the directory (matching existing patterns in `pkg/analytics/shared_id.go` line 67 and `pkg/log/logger.go` line 86)
- Uses `0644` for the file (matching existing file write patterns throughout the codebase)
- Only uses `slog.Debug` for logging -- this is consistent with the existing config loading debug messages on lines 113, 119, 128, 133
- Does not return an error -- the caller should not care if this fails
- Takes `path` as a parameter rather than calling `getUserConfigPath()` internally -- this avoids double-computing the path and makes the function testable with temp directories

#### 1c. Modify `Load()` to call `ensureDefaultUserConfig`

In the `Load()` function, modify the `os.IsNotExist` branch (line 112-113) to call the new function. The change is minimal:

Current code (lines 111-114):

```go
if err := loadTOMLFile(userConfigPath, cfg); err != nil {
    if os.IsNotExist(err) {
        slog.Debug("No user-level config file found", "path", userConfigPath)
    } else {
```

New code:

```go
if err := loadTOMLFile(userConfigPath, cfg); err != nil {
    if os.IsNotExist(err) {
        slog.Debug("No user-level config file found", "path", userConfigPath)
        ensureDefaultUserConfig(userConfigPath)
    } else {
```

This is exactly one line added. The function is called in the right place because:

- We already know the file does not exist (we just checked with `os.IsNotExist`)
- We already have the computed path (`userConfigPath`)
- It happens before the local project config is loaded, so there is no ordering concern
- Failure is non-fatal (the function logs and returns silently)

### 2. Test Plan for `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go`

Add a new test function `TestEnsureDefaultUserConfig` with table-driven subtests.

#### Test cases

1. **Creates file when directory and file do not exist** -- Set HOME to an empty temp dir. Call `Load(nil)`. Verify `~/.specstory/cli-config.toml` now exists. Verify the content matches `defaultConfigTemplate`. Verify the returned config is still a zero-value config (since everything is commented out).

2. **Does not overwrite existing file** -- Create a temp HOME with an existing `~/.specstory/cli-config.toml` containing `output_dir = "/custom"`. Call `Load(nil)`. Verify the file still contains the original content. Verify `cfg.GetOutputDir()` returns `/custom`.

3. **Handles read-only directory gracefully** -- Create a temp HOME. Create `~/.specstory/` with permissions `0555` (read-only). Call `Load(nil)`. Verify no error is returned from `Load()`. Verify the config file was NOT created (because write permission denied).

4. **Template parses as valid TOML when uncommented** -- Take `defaultConfigTemplate`, strip the leading `#` and space from each line, feed it through `toml.Decode` into a `Config` struct. Verify it parses without error. This is a guard against template syntax errors that could break the user experience when they uncomment options.

5. **Created file is parseable by Load** -- After `Load(nil)` creates the default file, call `Load(nil)` again. Verify the second call succeeds without error and returns the same default config values.

Here is the test structure:

```go
// TestEnsureDefaultUserConfig tests that a default config file is created
// when no user-level config exists
func TestEnsureDefaultUserConfig(t *testing.T) {
	origWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get working directory: %v", err)
	}
	defer func() { _ = os.Chdir(origWd) }()

	origHome := os.Getenv("HOME")
	defer func() { _ = os.Setenv("HOME", origHome) }()

	t.Run("creates default config when file does not exist", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		cfg, err := Load(nil)
		if err != nil {
			t.Fatalf("Load() returned error: %v", err)
		}

		// Verify default config values (everything should be defaults)
		if cfg.GetOutputDir() != "" {
			t.Errorf("GetOutputDir() = %q, want empty", cfg.GetOutputDir())
		}

		// Verify file was created
		configPath := filepath.Join(tempHome, SpecStoryDir, ConfigFileName)
		content, err := os.ReadFile(configPath)
		if err != nil {
			t.Fatalf("Default config file was not created: %v", err)
		}

		if string(content) != defaultConfigTemplate {
			t.Errorf("Default config content does not match template")
		}
	})

	t.Run("does not overwrite existing config", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		// Create existing config
		existingContent := `output_dir = "/custom"`
		createTempConfigFile(t, tempHome, existingContent)

		cfg, err := Load(nil)
		if err != nil {
			t.Fatalf("Load() returned error: %v", err)
		}

		// Verify existing config was loaded, not overwritten
		if cfg.GetOutputDir() != "/custom" {
			t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/custom")
		}
	})

	t.Run("handles unwritable directory gracefully", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		// Create .specstory dir as read-only
		specDir := filepath.Join(tempHome, SpecStoryDir)
		if err := os.MkdirAll(specDir, 0555); err != nil {
			t.Fatalf("Failed to create dir: %v", err)
		}
		// Cleanup: restore write permissions so t.TempDir() can remove it
		defer func() { _ = os.Chmod(specDir, 0755) }()

		// Load should succeed (failure to create default config is non-fatal)
		_, err := Load(nil)
		if err != nil {
			t.Fatalf("Load() returned error: %v", err)
		}

		// Verify file was NOT created (permission denied)
		configPath := filepath.Join(specDir, ConfigFileName)
		if _, err := os.Stat(configPath); !os.IsNotExist(err) {
			t.Errorf("Config file should not have been created in read-only dir")
		}
	})

	t.Run("created file is loadable on subsequent calls", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		// First call creates the file
		_, err := Load(nil)
		if err != nil {
			t.Fatalf("First Load() returned error: %v", err)
		}

		// Second call should load the created file without error
		cfg, err := Load(nil)
		if err != nil {
			t.Fatalf("Second Load() returned error: %v", err)
		}

		// All values should still be defaults (everything commented out)
		if cfg.IsVersionCheckEnabled() != true {
			t.Errorf("IsVersionCheckEnabled() should be true")
		}
		if cfg.IsCloudSyncEnabled() != true {
			t.Errorf("IsCloudSyncEnabled() should be true")
		}
	})
}

// TestDefaultConfigTemplateParsesWhenUncommented verifies the template
// is valid TOML when all comment markers are removed
func TestDefaultConfigTemplateParsesWhenUncommented(t *testing.T) {
	// Strip "# " prefix from each line to simulate a fully-uncommented config
	lines := strings.Split(defaultConfigTemplate, "\n")
	var uncommented []string
	for _, line := range lines {
		if strings.HasPrefix(line, "# ") {
			uncommented = append(uncommented, strings.TrimPrefix(line, "# "))
		} else if line == "#" {
			uncommented = append(uncommented, "")
		} else {
			uncommented = append(uncommented, line)
		}
	}

	tomlContent := strings.Join(uncommented, "\n")

	var cfg Config
	if _, err := toml.Decode(tomlContent, &cfg); err != nil {
		t.Fatalf("Uncommented default config template is not valid TOML: %v\nContent:\n%s", err, tomlContent)
	}
}
```

Note: The `TestDefaultConfigTemplateParsesWhenUncommented` test will need `"github.com/BurntSushi/toml"` added to the test file imports. The test file currently only imports `"os"`, `"path/filepath"`, `"strings"`, and `"testing"`.

### 3. Impact on Existing Tests

The existing `TestDefaultValues` and `TestMissingFileHandling` tests currently set HOME to an empty temp directory and expect `Load()` to succeed. After this change, `Load()` will also create the default config file in those temp directories. This is fine because:

- The created file has all options commented out, so it behaves identically to no config file
- The tests verify config values, not file existence
- The `TestMissingFileHandling` test with the case `"no config files - no error"` will now have a side effect of creating the file, but the test assertion (no error returned) still passes

However, there is one subtle concern: `TestLoadPrecedence` test case `"empty when no config files"` will now have the file created after the first Load call. If that test calls Load multiple times within the same subtest, subsequent calls would find the file. But looking at the test code, each subtest only calls `Load(nil)` once, so this is not an issue.

### 4. Edge Cases

1. **HOME environment variable not set**: `getUserConfigPath()` returns `""` when `os.UserHomeDir()` fails. In that case, `userConfigPath` is `""`, and the outer `if userConfigPath != ""` guard on line 110 prevents any config loading or file creation. No change needed here.

2. **Race condition on concurrent CLI invocations**: Two specstory processes could start simultaneously and both detect the file is missing. Both would try to create it. Since `os.WriteFile` is atomic at the OS level for small files, one will win and the other will overwrite with identical content. This is harmless.

3. **Disk full or other I/O errors**: `ensureDefaultUserConfig` catches all errors from `os.MkdirAll` and `os.WriteFile` and logs them at Debug level. The CLI continues normally.

4. **`~/.specstory/` directory exists but config file does not**: `os.MkdirAll` is a no-op when the directory already exists. The file will be created. This is the expected behavior.

5. **Idempotency**: The function is only called inside the `os.IsNotExist` branch of `loadTOMLFile`. If the file exists (even if it was just created on a previous run), `loadTOMLFile` succeeds and the `os.IsNotExist` branch is never entered. So the function is never called when the file already exists. This is inherently idempotent.

6. **Template maintenance**: When new config options are added to the `Config` struct, the developer must also update `defaultConfigTemplate`. This is a manual step. The `TestDefaultConfigTemplateParsesWhenUncommented` test helps catch syntax errors in the template, but it does not enforce that all struct fields are represented. A comment above the const should note this responsibility.

### 5. Summary of Changes

| File | Change |
|------|--------|
| `pkg/config/config.go` | Add `defaultConfigTemplate` const (~45 lines) |
| `pkg/config/config.go` | Add `ensureDefaultUserConfig()` function (~18 lines) |
| `pkg/config/config.go` | Add one line to `Load()` calling `ensureDefaultUserConfig` |
| `pkg/config/config_test.go` | Add `TestEnsureDefaultUserConfig` (~100 lines) |
| `pkg/config/config_test.go` | Add `TestDefaultConfigTemplateParsesWhenUncommented` (~25 lines) |
| `pkg/config/config_test.go` | Add `toml` import |

Total: approximately 190 lines of new code (including comments and tests).

No new files are needed. No new dependencies are needed (the `toml` import in the test file uses the already-imported `github.com/BurntSushi/toml` package).

### Critical Files for Implementation

- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go` - Primary file to modify: add template const, creation function, and one-line call in Load()
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go` - Add tests for the new behavior including creation, idempotency, graceful failure, and template validity
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/analytics/shared_id.go` - Reference pattern for creating files in user home directory with proper error handling
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/main.go` - Context for understanding where Load() is called and how config flows through the application (no changes needed here)
agentId: a0e6887 (for resuming to continue this agent's work if needed)
<usage>total_tokens: 56770
tool_uses: 12
duration_ms: 113691</usage>
```
</details></tool-use>

_**Agent - sidechain (2026-02-22 15:20:45Z)**_

Design an implementation plan for auto-creating a default `~/.specstory/cli-config.toml` config file when one doesn't exist.

## Context

The SpecStory CLI has a TOML config system in `pkg/config/config.go`. Config is loaded with priority: CLI flags > local project config (`./specstory/cli-config.toml`) > user-level config (`~/.specstory/cli-config.toml`). All config files are optional.

The problem: nobody discovers this config file exists. The solution: at startup, if the `~` config file doesn't exist, create a default one with all options commented out so users can discover and edit it.

## Current config options (all in config.go)

Root level:
- `output_dir` (string, default empty) - Custom output directory

Sections:
- `[version_check]` - `enabled` (*bool, default true)
- `[cloud_sync]` - `enabled` (*bool, default true)
- `[local_sync]` - `enabled` (*bool, default true)
- `[logging]` - `console` (*bool, default false), `log` (*bool, default false), `debug` (*bool, default false), `silent` (*bool, default false)
- `[analytics]` - `enabled` (*bool, default true)

## Current Load() function (config.go lines 105-144)

```go
func Load(cliOverrides *CLIOverrides) (*Config, error) {
    cfg := &Config{}
    
    // Load user-level config first (lowest priority)
    userConfigPath := getUserConfigPath()
    if userConfigPath != "" {
        if err := loadTOMLFile(userConfigPath, cfg); err != nil {
            if os.IsNotExist(err) {
                slog.Debug("No user-level config file found", "path", userConfigPath)
            } else {
                return cfg, fmt.Errorf("failed to load user config %s: %w", userConfigPath, err)
            }
        } else {
            slog.Debug("Loaded user-level config", "path", userConfigPath)
        }
    }
    
    // Load local project config (overwrites user-level)
    // ... same pattern ...
    
    // Apply CLI flag overrides
    // ...
    
    return cfg, nil
}
```

## Design Requirements

1. When `~/.specstory/cli-config.toml` doesn't exist, create it with all options present but commented out
2. Should also create `~/.specstory/` directory if it doesn't exist
3. Failure to create shouldn't be fatal - just log and continue
4. Should only happen for the user-level (`~`) config, NOT the local project config
5. The generated file should have helpful comments explaining each option and its default

## Design Considerations

- Where should the default config template live? As a const string in config.go? Or generated from the struct?
- A const string template is simpler, easier to maintain, and allows for nice formatting and comments
- The function should be called from within `Load()`, right where the `os.IsNotExist` branch is for the user config
- Keep it idempotent - only create if file doesn't exist

Please provide a detailed implementation plan with:
1. What to add/change in config.go
2. The default template content (commented-out TOML)
3. What tests to add
4. Any edge cases

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:48Z)**_



I'll start by thoroughly exploring the existing config package and related code to understand the current implementation before designing the plan.

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:48Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/config/config.go`

```text
     1→// Package config provides configuration management for the SpecStory CLI.
     2→// Configuration is loaded with the following priority (highest to lowest):
     3→//  1. CLI flags
     4→//  2. Local project config: .specstory/cli-config.toml
     5→//  3. User-level config: ~/.specstory/cli-config.toml
     6→//
     7→// Note: For telemetry settings, environment variables (OTEL_*) take highest priority
     8→// per OpenTelemetry conventions.
     9→package config
    10→
    11→import (
    12→	"fmt"
    13→	"log/slog"
    14→	"os"
    15→	"path/filepath"
    16→
    17→	"github.com/BurntSushi/toml"
    18→)
    19→
    20→const (
    21→	// ConfigFileName is the name of the configuration file
    22→	ConfigFileName = "cli-config.toml"
    23→	// SpecStoryDir is the directory name for SpecStory files
    24→	SpecStoryDir = ".specstory"
    25→)
    26→
    27→// Config represents the complete CLI configuration
    28→type Config struct {
    29→	// OutputDir is the custom output directory for markdown and debug files
    30→	OutputDir string `toml:"output_dir"`
    31→
    32→	VersionCheck VersionCheckConfig `toml:"version_check"`
    33→	CloudSync    CloudSyncConfig    `toml:"cloud_sync"`
    34→	LocalSync    LocalSyncConfig    `toml:"local_sync"`
    35→	Logging      LoggingConfig      `toml:"logging"`
    36→	Analytics    AnalyticsConfig    `toml:"analytics"`
    37→}
    38→
    39→// VersionCheckConfig holds version check settings
    40→type VersionCheckConfig struct {
    41→	// Enabled controls whether to check for newer versions on startup
    42→	Enabled *bool `toml:"enabled"`
    43→}
    44→
    45→// CloudSyncConfig holds cloud sync settings
    46→type CloudSyncConfig struct {
    47→	// Enabled controls whether cloud sync is active
    48→	Enabled *bool `toml:"enabled"`
    49→}
    50→
    51→// LocalSyncConfig holds local file sync settings
    52→type LocalSyncConfig struct {
    53→	// Enabled controls whether local markdown files are written
    54→	// When false, only cloud sync is performed (equivalent to --only-cloud-sync)
    55→	Enabled *bool `toml:"enabled"`
    56→}
    57→
    58→// LoggingConfig holds logging settings
    59→type LoggingConfig struct {
    60→	// Console enables error/warn/info output to stdout
    61→	Console *bool `toml:"console"`
    62→	// Log enables writing error/warn/info output to .specstory/debug/debug.log
    63→	Log *bool `toml:"log"`
    64→	// Debug enables debug-level output (requires Console or Log)
    65→	Debug *bool `toml:"debug"`
    66→	// Silent suppresses all non-error output
    67→	Silent *bool `toml:"silent"`
    68→}
    69→
    70→// AnalyticsConfig holds analytics settings
    71→type AnalyticsConfig struct {
    72→	// Enabled controls whether usage analytics are sent
    73→	Enabled *bool `toml:"enabled"`
    74→}
    75→
    76→// CLIOverrides holds CLI flag values that override config file settings.
    77→// These are applied after config files are loaded.
    78→type CLIOverrides struct {
    79→	// General
    80→	OutputDir string
    81→
    82→	// Version check
    83→	NoVersionCheck bool
    84→
    85→	// Cloud sync
    86→	NoCloudSync   bool
    87→	OnlyCloudSync bool
    88→
    89→	// Logging
    90→	Console bool
    91→	Log     bool
    92→	Debug   bool
    93→	Silent  bool
    94→
    95→	// Analytics
    96→	NoAnalytics bool
    97→}
    98→
    99→// Load reads configuration from files and CLI flags.
   100→// Priority: CLI flags > local project config > user-level config
   101→//
   102→// Returns an error if a config file exists but cannot be parsed (TOML syntax error)
   103→// or cannot be read (permission denied, I/O error). Missing config files are not
   104→// treated as errors - they are simply skipped.
   105→func Load(cliOverrides *CLIOverrides) (*Config, error) {
   106→	cfg := &Config{}
   107→
   108→	// Load user-level config first (lowest priority)
   109→	userConfigPath := getUserConfigPath()
   110→	if userConfigPath != "" {
   111→		if err := loadTOMLFile(userConfigPath, cfg); err != nil {
   112→			if os.IsNotExist(err) {
   113→				slog.Debug("No user-level config file found", "path", userConfigPath)
   114→			} else {
   115→				// Parse error or permission denied - return error to caller
   116→				return cfg, fmt.Errorf("failed to load user config %s: %w", userConfigPath, err)
   117→			}
   118→		} else {
   119→			slog.Debug("Loaded user-level config", "path", userConfigPath)
   120→		}
   121→	}
   122→
   123→	// Load local project config (overwrites user-level)
   124→	localConfigPath := getLocalConfigPath()
   125→	if localConfigPath != "" {
   126→		if err := loadTOMLFile(localConfigPath, cfg); err != nil {
   127→			if os.IsNotExist(err) {
   128→				slog.Debug("No local project config file found", "path", localConfigPath)
   129→			} else {
   130→				// Parse error or permission denied - return error to caller
   131→				return cfg, fmt.Errorf("failed to load project config %s: %w", localConfigPath, err)
   132→			}
   133→		} else {
   134→			slog.Debug("Loaded local project config", "path", localConfigPath)
   135→		}
   136→	}
   137→
   138→	// Apply CLI flag overrides (highest priority for most settings)
   139→	if cliOverrides != nil {
   140→		applyCLIOverrides(cfg, cliOverrides)
   141→	}
   142→
   143→	return cfg, nil
   144→}
   145→
   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
   147→func getUserConfigPath() string {
   148→	home, err := os.UserHomeDir()
   149→	if err != nil {
   150→		slog.Debug("Could not determine home directory", "error", err)
   151→		return ""
   152→	}
   153→	return filepath.Join(home, SpecStoryDir, ConfigFileName)
   154→}
   155→
   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
   157→func getLocalConfigPath() string {
   158→	cwd, err := os.Getwd()
   159→	if err != nil {
   160→		slog.Debug("Could not determine current directory", "error", err)
   161→		return ""
   162→	}
   163→	return filepath.Join(cwd, SpecStoryDir, ConfigFileName)
   164→}
   165→
   166→// loadTOMLFile reads a TOML file and decodes it into the config struct.
   167→// Fields are merged (later calls overwrite earlier values).
   168→func loadTOMLFile(path string, cfg *Config) error {
   169→	_, err := toml.DecodeFile(path, cfg)
   170→	return err
   171→}
   172→
   173→// applyCLIOverrides applies CLI flag overrides to the config.
   174→func applyCLIOverrides(cfg *Config, o *CLIOverrides) {
   175→	// General
   176→	if o.OutputDir != "" {
   177→		cfg.OutputDir = o.OutputDir
   178→	}
   179→
   180→	// Version check (--no-version-check sets enabled to false)
   181→	if o.NoVersionCheck {
   182→		disabled := false
   183→		cfg.VersionCheck.Enabled = &disabled
   184→	}
   185→
   186→	// Cloud sync (--no-cloud-sync sets enabled to false)
   187→	if o.NoCloudSync {
   188→		disabled := false
   189→		cfg.CloudSync.Enabled = &disabled
   190→	}
   191→
   192→	// Local sync (--only-cloud-sync sets enabled to false)
   193→	if o.OnlyCloudSync {
   194→		disabled := false
   195→		cfg.LocalSync.Enabled = &disabled
   196→	}
   197→
   198→	// Logging flags only override if explicitly set (true)
   199→	if o.Console {
   200→		enabled := true
   201→		cfg.Logging.Console = &enabled
   202→	}
   203→	if o.Log {
   204→		enabled := true
   205→		cfg.Logging.Log = &enabled
   206→	}
   207→	if o.Debug {
   208→		enabled := true
   209→		cfg.Logging.Debug = &enabled
   210→	}
   211→	if o.Silent {
   212→		enabled := true
   213→		cfg.Logging.Silent = &enabled
   214→	}
   215→
   216→	// Analytics (--no-usage-analytics sets enabled to false)
   217→	if o.NoAnalytics {
   218→		disabled := false
   219→		cfg.Analytics.Enabled = &disabled
   220→	}
   221→}
   222→
   223→// --- Getter methods ---
   224→
   225→// GetOutputDir returns the output directory, or empty string to use default.
   226→func (c *Config) GetOutputDir() string {
   227→	return c.OutputDir
   228→}
   229→
   230→// IsVersionCheckEnabled returns whether version check is enabled.
   231→// Defaults to true if not explicitly set.
   232→func (c *Config) IsVersionCheckEnabled() bool {
   233→	if c.VersionCheck.Enabled != nil {
   234→		return *c.VersionCheck.Enabled
   235→	}
   236→	return true // default enabled
   237→}
   238→
   239→// IsCloudSyncEnabled returns whether cloud sync is enabled.
   240→// Defaults to true if not explicitly set.
   241→func (c *Config) IsCloudSyncEnabled() bool {
   242→	if c.CloudSync.Enabled != nil {
   243→		return *c.CloudSync.Enabled
   244→	}
   245→	return true // default enabled
   246→}
   247→
   248→// IsLocalSyncEnabled returns whether local sync is enabled.
   249→// Defaults to true if not explicitly set.
   250→// When false, only cloud sync is performed (equivalent to --only-cloud-sync).
   251→func (c *Config) IsLocalSyncEnabled() bool {
   252→	if c.LocalSync.Enabled != nil {
   253→		return *c.LocalSync.Enabled
   254→	}
   255→	return true // default enabled
   256→}
   257→
   258→// IsConsoleEnabled returns whether console logging is enabled.
   259→// Defaults to false if not explicitly set.
   260→func (c *Config) IsConsoleEnabled() bool {
   261→	if c.Logging.Console != nil {
   262→		return *c.Logging.Console
   263→	}
   264→	return false // default disabled
   265→}
   266→
   267→// IsLogEnabled returns whether file logging is enabled.
   268→// Defaults to false if not explicitly set.
   269→func (c *Config) IsLogEnabled() bool {
   270→	if c.Logging.Log != nil {
   271→		return *c.Logging.Log
   272→	}
   273→	return false // default disabled
   274→}
   275→
   276→// IsDebugEnabled returns whether debug logging is enabled.
   277→// Defaults to false if not explicitly set.
   278→func (c *Config) IsDebugEnabled() bool {
   279→	if c.Logging.Debug != nil {
   280→		return *c.Logging.Debug
   281→	}
   282→	return false // default disabled
   283→}
   284→
   285→// IsSilentEnabled returns whether silent mode is enabled.
   286→// Defaults to false if not explicitly set.
   287→func (c *Config) IsSilentEnabled() bool {
   288→	if c.Logging.Silent != nil {
   289→		return *c.Logging.Silent
   290→	}
   291→	return false // default disabled
   292→}
   293→
   294→// IsAnalyticsEnabled returns whether analytics are enabled.
   295→// Defaults to true if not explicitly set.
   296→func (c *Config) IsAnalyticsEnabled() bool {
   297→	if c.Analytics.Enabled != nil {
   298→		return *c.Analytics.Enabled
   299→	}
   300→	return true // default enabled
   301→}
   302→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:49Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/*`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:49Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/**/*`

```text
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go
/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:52Z)**_

Now let me read the existing test file and look at how other parts of the codebase handle directory/file creation for patterns to follow.

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:53Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/config/config_test.go`

```text
     1→package config
     2→
     3→import (
     4→	"os"
     5→	"path/filepath"
     6→	"strings"
     7→	"testing"
     8→)
     9→
    10→// Helper to create a temporary config file with the given content
    11→func createTempConfigFile(t *testing.T, dir, content string) string {
    12→	t.Helper()
    13→	specstoryDir := filepath.Join(dir, SpecStoryDir)
    14→	if err := os.MkdirAll(specstoryDir, 0755); err != nil {
    15→		t.Fatalf("Failed to create .specstory dir: %v", err)
    16→	}
    17→	configPath := filepath.Join(specstoryDir, ConfigFileName)
    18→	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
    19→		t.Fatalf("Failed to write config file: %v", err)
    20→	}
    21→	return configPath
    22→}
    23→
    24→// TestLoadPrecedence tests that project config overrides user config
    25→func TestLoadPrecedence(t *testing.T) {
    26→	// Save and restore original working directory
    27→	origWd, err := os.Getwd()
    28→	if err != nil {
    29→		t.Fatalf("Failed to get working directory: %v", err)
    30→	}
    31→	defer func() { _ = os.Chdir(origWd) }()
    32→
    33→	// Save and restore original HOME
    34→	origHome := os.Getenv("HOME")
    35→	defer func() { _ = os.Setenv("HOME", origHome) }()
    36→
    37→	tests := []struct {
    38→		name           string
    39→		userConfig     string
    40→		projectConfig  string
    41→		expectedOutDir string
    42→	}{
    43→		{
    44→			name:           "project config overrides user config",
    45→			userConfig:     `output_dir = "/user/path"`,
    46→			projectConfig:  `output_dir = "/project/path"`,
    47→			expectedOutDir: "/project/path",
    48→		},
    49→		{
    50→			name:           "user config used when no project config",
    51→			userConfig:     `output_dir = "/user/path"`,
    52→			projectConfig:  "",
    53→			expectedOutDir: "/user/path",
    54→		},
    55→		{
    56→			name:           "project config used when no user config",
    57→			userConfig:     "",
    58→			projectConfig:  `output_dir = "/project/path"`,
    59→			expectedOutDir: "/project/path",
    60→		},
    61→		{
    62→			name:           "empty when no config files",
    63→			userConfig:     "",
    64→			projectConfig:  "",
    65→			expectedOutDir: "",
    66→		},
    67→		{
    68→			name: "project nested config overrides user nested config",
    69→			userConfig: `
    70→[cloud_sync]
    71→enabled = true
    72→`,
    73→			projectConfig: `
    74→[cloud_sync]
    75→enabled = false
    76→`,
    77→			expectedOutDir: "", // We check cloud_sync separately below
    78→		},
    79→	}
    80→
    81→	for _, tt := range tests {
    82→		t.Run(tt.name, func(t *testing.T) {
    83→			// Create temp directories for HOME and project
    84→			tempHome := t.TempDir()
    85→			tempProject := t.TempDir()
    86→
    87→			// Set HOME to temp directory
    88→			if err := os.Setenv("HOME", tempHome); err != nil {
    89→				t.Fatalf("Failed to set HOME: %v", err)
    90→			}
    91→
    92→			// Change to temp project directory
    93→			if err := os.Chdir(tempProject); err != nil {
    94→				t.Fatalf("Failed to chdir: %v", err)
    95→			}
    96→
    97→			// Create user config if provided
    98→			if tt.userConfig != "" {
    99→				createTempConfigFile(t, tempHome, tt.userConfig)
   100→			}
   101→
   102→			// Create project config if provided
   103→			if tt.projectConfig != "" {
   104→				createTempConfigFile(t, tempProject, tt.projectConfig)
   105→			}
   106→
   107→			// Load config
   108→			cfg, err := Load(nil)
   109→			if err != nil {
   110→				t.Fatalf("Load() returned error: %v", err)
   111→			}
   112→
   113→			// Check output_dir precedence
   114→			if cfg.GetOutputDir() != tt.expectedOutDir {
   115→				t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), tt.expectedOutDir)
   116→			}
   117→
   118→			// Special check for nested config test
   119→			if tt.name == "project nested config overrides user nested config" {
   120→				if cfg.IsCloudSyncEnabled() {
   121→					t.Errorf("IsCloudSyncEnabled() = true, want false (project should override user)")
   122→				}
   123→			}
   124→		})
   125→	}
   126→}
   127→
   128→// TestCLIOverrides tests that CLI flags override config file settings
   129→func TestCLIOverrides(t *testing.T) {
   130→	// Save and restore original working directory
   131→	origWd, err := os.Getwd()
   132→	if err != nil {
   133→		t.Fatalf("Failed to get working directory: %v", err)
   134→	}
   135→	defer func() { _ = os.Chdir(origWd) }()
   136→
   137→	// Save and restore original HOME
   138→	origHome := os.Getenv("HOME")
   139→	defer func() { _ = os.Setenv("HOME", origHome) }()
   140→
   141→	tests := []struct {
   142→		name       string
   143→		configFile string
   144→		overrides  *CLIOverrides
   145→		checkFunc  func(t *testing.T, cfg *Config)
   146→	}{
   147→		{
   148→			name:       "OutputDir override",
   149→			configFile: `output_dir = "/config/path"`,
   150→			overrides:  &CLIOverrides{OutputDir: "/cli/path"},
   151→			checkFunc: func(t *testing.T, cfg *Config) {
   152→				if cfg.GetOutputDir() != "/cli/path" {
   153→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/cli/path")
   154→				}
   155→			},
   156→		},
   157→		{
   158→			name: "NoVersionCheck override (--no-version-check)",
   159→			configFile: `
   160→[version_check]
   161→enabled = true
   162→`,
   163→			overrides: &CLIOverrides{NoVersionCheck: true},
   164→			checkFunc: func(t *testing.T, cfg *Config) {
   165→				if cfg.IsVersionCheckEnabled() {
   166→					t.Errorf("IsVersionCheckEnabled() = true, want false")
   167→				}
   168→			},
   169→		},
   170→		{
   171→			name: "NoCloudSync override (--no-cloud-sync)",
   172→			configFile: `
   173→[cloud_sync]
   174→enabled = true
   175→`,
   176→			overrides: &CLIOverrides{NoCloudSync: true},
   177→			checkFunc: func(t *testing.T, cfg *Config) {
   178→				if cfg.IsCloudSyncEnabled() {
   179→					t.Errorf("IsCloudSyncEnabled() = true, want false")
   180→				}
   181→			},
   182→		},
   183→		{
   184→			name: "OnlyCloudSync override (--only-cloud-sync)",
   185→			configFile: `
   186→[local_sync]
   187→enabled = true
   188→`,
   189→			overrides: &CLIOverrides{OnlyCloudSync: true},
   190→			checkFunc: func(t *testing.T, cfg *Config) {
   191→				if cfg.IsLocalSyncEnabled() {
   192→					t.Errorf("IsLocalSyncEnabled() = true, want false")
   193→				}
   194→			},
   195→		},
   196→		{
   197→			name: "Console logging override (--console)",
   198→			configFile: `
   199→[logging]
   200→console = false
   201→`,
   202→			overrides: &CLIOverrides{Console: true},
   203→			checkFunc: func(t *testing.T, cfg *Config) {
   204→				if !cfg.IsConsoleEnabled() {
   205→					t.Errorf("IsConsoleEnabled() = false, want true")
   206→				}
   207→			},
   208→		},
   209→		{
   210→			name: "Log file override (--log)",
   211→			configFile: `
   212→[logging]
   213→log = false
   214→`,
   215→			overrides: &CLIOverrides{Log: true},
   216→			checkFunc: func(t *testing.T, cfg *Config) {
   217→				if !cfg.IsLogEnabled() {
   218→					t.Errorf("IsLogEnabled() = false, want true")
   219→				}
   220→			},
   221→		},
   222→		{
   223→			name: "Debug override (--debug)",
   224→			configFile: `
   225→[logging]
   226→debug = false
   227→`,
   228→			overrides: &CLIOverrides{Debug: true},
   229→			checkFunc: func(t *testing.T, cfg *Config) {
   230→				if !cfg.IsDebugEnabled() {
   231→					t.Errorf("IsDebugEnabled() = false, want true")
   232→				}
   233→			},
   234→		},
   235→		{
   236→			name: "Silent override (--silent)",
   237→			configFile: `
   238→[logging]
   239→silent = false
   240→`,
   241→			overrides: &CLIOverrides{Silent: true},
   242→			checkFunc: func(t *testing.T, cfg *Config) {
   243→				if !cfg.IsSilentEnabled() {
   244→					t.Errorf("IsSilentEnabled() = false, want true")
   245→				}
   246→			},
   247→		},
   248→		{
   249→			name: "NoAnalytics override (--no-usage-analytics)",
   250→			configFile: `
   251→[analytics]
   252→enabled = true
   253→`,
   254→			overrides: &CLIOverrides{NoAnalytics: true},
   255→			checkFunc: func(t *testing.T, cfg *Config) {
   256→				if cfg.IsAnalyticsEnabled() {
   257→					t.Errorf("IsAnalyticsEnabled() = true, want false")
   258→				}
   259→			},
   260→		},
   261→		{
   262→			name:       "Empty CLI override doesn't change config value",
   263→			configFile: `output_dir = "/config/path"`,
   264→			overrides:  &CLIOverrides{OutputDir: ""},
   265→			checkFunc: func(t *testing.T, cfg *Config) {
   266→				if cfg.GetOutputDir() != "/config/path" {
   267→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/config/path")
   268→				}
   269→			},
   270→		},
   271→		{
   272→			name:       "Nil CLI overrides doesn't panic",
   273→			configFile: `output_dir = "/config/path"`,
   274→			overrides:  nil,
   275→			checkFunc: func(t *testing.T, cfg *Config) {
   276→				if cfg.GetOutputDir() != "/config/path" {
   277→					t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/config/path")
   278→				}
   279→			},
   280→		},
   281→	}
   282→
   283→	for _, tt := range tests {
   284→		t.Run(tt.name, func(t *testing.T) {
   285→			// Create temp directories
   286→			tempHome := t.TempDir()
   287→			tempProject := t.TempDir()
   288→
   289→			// Set HOME to empty temp dir (no user config)
   290→			if err := os.Setenv("HOME", tempHome); err != nil {
   291→				t.Fatalf("Failed to set HOME: %v", err)
   292→			}
   293→
   294→			// Change to temp project directory
   295→			if err := os.Chdir(tempProject); err != nil {
   296→				t.Fatalf("Failed to chdir: %v", err)
   297→			}
   298→
   299→			// Create project config
   300→			if tt.configFile != "" {
   301→				createTempConfigFile(t, tempProject, tt.configFile)
   302→			}
   303→
   304→			// Load config with overrides
   305→			cfg, err := Load(tt.overrides)
   306→			if err != nil {
   307→				t.Fatalf("Load() returned error: %v", err)
   308→			}
   309→
   310→			tt.checkFunc(t, cfg)
   311→		})
   312→	}
   313→}
   314→
   315→// TestParseErrorHandling tests that TOML parse errors are returned to the caller
   316→func TestParseErrorHandling(t *testing.T) {
   317→	// Save and restore original working directory
   318→	origWd, err := os.Getwd()
   319→	if err != nil {
   320→		t.Fatalf("Failed to get working directory: %v", err)
   321→	}
   322→	defer func() { _ = os.Chdir(origWd) }()
   323→
   324→	// Save and restore original HOME
   325→	origHome := os.Getenv("HOME")
   326→	defer func() { _ = os.Setenv("HOME", origHome) }()
   327→
   328→	tests := []struct {
   329→		name          string
   330→		configContent string
   331→		wantError     bool
   332→		errorContains string
   333→	}{
   334→		{
   335→			name:          "valid TOML parses successfully",
   336→			configContent: `output_dir = "/valid/path"`,
   337→			wantError:     false,
   338→		},
   339→		{
   340→			name:          "invalid TOML returns error",
   341→			configContent: `this is not valid toml [[[`,
   342→			wantError:     true,
   343→			errorContains: "failed to load project config",
   344→		},
   345→		{
   346→			name:          "unclosed quote returns error",
   347→			configContent: `output_dir = "/unclosed`,
   348→			wantError:     true,
   349→			errorContains: "failed to load project config",
   350→		},
   351→		{
   352→			name:          "invalid table syntax returns error",
   353→			configContent: `[cloud_sync`,
   354→			wantError:     true,
   355→			errorContains: "failed to load project config",
   356→		},
   357→	}
   358→
   359→	for _, tt := range tests {
   360→		t.Run(tt.name, func(t *testing.T) {
   361→			// Create temp directories
   362→			tempHome := t.TempDir()
   363→			tempProject := t.TempDir()
   364→
   365→			// Set HOME to empty temp dir (no user config)
   366→			if err := os.Setenv("HOME", tempHome); err != nil {
   367→				t.Fatalf("Failed to set HOME: %v", err)
   368→			}
   369→
   370→			// Change to temp project directory
   371→			if err := os.Chdir(tempProject); err != nil {
   372→				t.Fatalf("Failed to chdir: %v", err)
   373→			}
   374→
   375→			// Create project config with test content
   376→			createTempConfigFile(t, tempProject, tt.configContent)
   377→
   378→			// Load config
   379→			_, err := Load(nil)
   380→
   381→			if tt.wantError {
   382→				if err == nil {
   383→					t.Errorf("Load() returned no error, want error containing %q", tt.errorContains)
   384→				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
   385→					t.Errorf("Load() error = %q, want error containing %q", err.Error(), tt.errorContains)
   386→				}
   387→			} else {
   388→				if err != nil {
   389→					t.Errorf("Load() returned error: %v, want no error", err)
   390→				}
   391→			}
   392→		})
   393→	}
   394→}
   395→
   396→// TestMissingFileHandling tests that missing config files don't cause errors
   397→func TestMissingFileHandling(t *testing.T) {
   398→	// Save and restore original working directory
   399→	origWd, err := os.Getwd()
   400→	if err != nil {
   401→		t.Fatalf("Failed to get working directory: %v", err)
   402→	}
   403→	defer func() { _ = os.Chdir(origWd) }()
   404→
   405→	// Save and restore original HOME
   406→	origHome := os.Getenv("HOME")
   407→	defer func() { _ = os.Setenv("HOME", origHome) }()
   408→
   409→	tests := []struct {
   410→		name           string
   411→		createUserDir  bool
   412→		createProjDir  bool
   413→		createUserConf bool
   414→		createProjConf bool
   415→		wantError      bool
   416→	}{
   417→		{
   418→			name:           "no config files - no error",
   419→			createUserDir:  false,
   420→			createProjDir:  false,
   421→			createUserConf: false,
   422→			createProjConf: false,
   423→			wantError:      false,
   424→		},
   425→		{
   426→			name:           "only user config exists - no error",
   427→			createUserDir:  true,
   428→			createProjDir:  false,
   429→			createUserConf: true,
   430→			createProjConf: false,
   431→			wantError:      false,
   432→		},
   433→		{
   434→			name:           "only project config exists - no error",
   435→			createUserDir:  false,
   436→			createProjDir:  true,
   437→			createUserConf: false,
   438→			createProjConf: true,
   439→			wantError:      false,
   440→		},
   441→		{
   442→			name:           "both config files exist - no error",
   443→			createUserDir:  true,
   444→			createProjDir:  true,
   445→			createUserConf: true,
   446→			createProjConf: true,
   447→			wantError:      false,
   448→		},
   449→		{
   450→			name:           ".specstory dirs exist but no config files - no error",
   451→			createUserDir:  true,
   452→			createProjDir:  true,
   453→			createUserConf: false,
   454→			createProjConf: false,
   455→			wantError:      false,
   456→		},
   457→	}
   458→
   459→	for _, tt := range tests {
   460→		t.Run(tt.name, func(t *testing.T) {
   461→			// Create temp directories
   462→			tempHome := t.TempDir()
   463→			tempProject := t.TempDir()
   464→
   465→			// Set HOME
   466→			if err := os.Setenv("HOME", tempHome); err != nil {
   467→				t.Fatalf("Failed to set HOME: %v", err)
   468→			}
   469→
   470→			// Change to temp project directory
   471→			if err := os.Chdir(tempProject); err != nil {
   472→				t.Fatalf("Failed to chdir: %v", err)
   473→			}
   474→
   475→			// Create directories if needed
   476→			if tt.createUserDir {
   477→				userSpecstoryDir := filepath.Join(tempHome, SpecStoryDir)
   478→				if err := os.MkdirAll(userSpecstoryDir, 0755); err != nil {
   479→					t.Fatalf("Failed to create user .specstory dir: %v", err)
   480→				}
   481→				if tt.createUserConf {
   482→					configPath := filepath.Join(userSpecstoryDir, ConfigFileName)
   483→					if err := os.WriteFile(configPath, []byte(`output_dir = "/user"`), 0644); err != nil {
   484→						t.Fatalf("Failed to create user config: %v", err)
   485→					}
   486→				}
   487→			}
   488→
   489→			if tt.createProjDir {
   490→				projSpecstoryDir := filepath.Join(tempProject, SpecStoryDir)
   491→				if err := os.MkdirAll(projSpecstoryDir, 0755); err != nil {
   492→					t.Fatalf("Failed to create project .specstory dir: %v", err)
   493→				}
   494→				if tt.createProjConf {
   495→					configPath := filepath.Join(projSpecstoryDir, ConfigFileName)
   496→					if err := os.WriteFile(configPath, []byte(`output_dir = "/project"`), 0644); err != nil {
   497→						t.Fatalf("Failed to create project config: %v", err)
   498→					}
   499→				}
   500→			}
   501→
   502→			// Load config
   503→			_, err := Load(nil)
   504→
   505→			if tt.wantError && err == nil {
   506→				t.Errorf("Load() returned no error, want error")
   507→			}
   508→			if !tt.wantError && err != nil {
   509→				t.Errorf("Load() returned error: %v, want no error", err)
   510→			}
   511→		})
   512→	}
   513→}
   514→
   515→// TestDefaultValues tests that default values are returned when config is empty
   516→func TestDefaultValues(t *testing.T) {
   517→	// Save and restore original working directory
   518→	origWd, err := os.Getwd()
   519→	if err != nil {
   520→		t.Fatalf("Failed to get working directory: %v", err)
   521→	}
   522→	defer func() { _ = os.Chdir(origWd) }()
   523→
   524→	// Save and restore original HOME
   525→	origHome := os.Getenv("HOME")
   526→	defer func() { _ = os.Setenv("HOME", origHome) }()
   527→
   528→	// Create temp directories with no config files
   529→	tempHome := t.TempDir()
   530→	tempProject := t.TempDir()
   531→
   532→	if err := os.Setenv("HOME", tempHome); err != nil {
   533→		t.Fatalf("Failed to set HOME: %v", err)
   534→	}
   535→	if err := os.Chdir(tempProject); err != nil {
   536→		t.Fatalf("Failed to chdir: %v", err)
   537→	}
   538→
   539→	cfg, err := Load(nil)
   540→	if err != nil {
   541→		t.Fatalf("Load() returned error: %v", err)
   542→	}
   543→
   544→	// Test default values
   545→	tests := []struct {
   546→		name     string
   547→		got      bool
   548→		expected bool
   549→	}{
   550→		{"IsVersionCheckEnabled default", cfg.IsVersionCheckEnabled(), true},
   551→		{"IsCloudSyncEnabled default", cfg.IsCloudSyncEnabled(), true},
   552→		{"IsLocalSyncEnabled default", cfg.IsLocalSyncEnabled(), true},
   553→		{"IsAnalyticsEnabled default", cfg.IsAnalyticsEnabled(), true},
   554→		{"IsConsoleEnabled default", cfg.IsConsoleEnabled(), false},
   555→		{"IsLogEnabled default", cfg.IsLogEnabled(), false},
   556→		{"IsDebugEnabled default", cfg.IsDebugEnabled(), false},
   557→		{"IsSilentEnabled default", cfg.IsSilentEnabled(), false},
   558→	}
   559→
   560→	for _, tt := range tests {
   561→		t.Run(tt.name, func(t *testing.T) {
   562→			if tt.got != tt.expected {
   563→				t.Errorf("%s = %v, want %v", tt.name, tt.got, tt.expected)
   564→			}
   565→		})
   566→	}
   567→
   568→	// OutputDir should be empty string (no default path)
   569→	if cfg.GetOutputDir() != "" {
   570→		t.Errorf("GetOutputDir() = %q, want empty string", cfg.GetOutputDir())
   571→	}
   572→}
   573→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:54Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `os\.MkdirAll`

```text
<persisted-output>
Output too large (31.8KB). Full output saved to: /Users/sean/.claude/projects/-Users-sean-Source-SpecStory-getspecstory-specstory-cli/ca840fc9-f560-413f-acd5-249e54d818a6/tool-results/toolu_01Uo7Qhj1tcjQEzRjnYpsmu1.txt

Preview (first 2KB):
docs/PROVIDER-SPI.md:285:        os.MkdirAll(debugDir, 0755)
pkg/log/logger.go:86:		if err := os.MkdirAll(dir, 0755); err != nil {
.specstory/history/2026-01-29_15-58-30Z-the-droid-provider-uses.md:2243:   426→	if err := os.MkdirAll(dir, 0o755); err != nil {
.specstory/history/2026-01-29_15-58-30Z-the-droid-provider-uses.md:4361:   426→	if err := os.MkdirAll(dir, 0o755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:2846:   240→	if err := os.MkdirAll(debugDir, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:2947:    70→				if err := os.MkdirAll(nested, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:2964:    87→				if err := os.MkdirAll(special, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:2981:   104→				if err := os.MkdirAll(unicode, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:3051:   174→				if err := os.MkdirAll(realDir, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:3080:   203→				if err := os.MkdirAll(realDir, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:5795:    70→				if err := os.MkdirAll(nested, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:5812:    87→				if err := os.MkdirAll(special, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:5829:   104→				if err := os.MkdirAll(unicode, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:5899:   174→				if err := os.MkdirAll(realDir, 0755); err != nil {
.specstory/history/2026-02-08_22-24-43Z-command-message-pr-review.md:5928:   203→				if err := os.MkdirAll(realDir, 0755); err != nil {
...
</persisted-output>
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:55Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `os\.WriteFile`

```text
<persisted-output>
Output too large (51.7KB). Full output saved to: /Users/sean/.claude/projects/-Users-sean-Source-SpecStory-getspecstory-specstory-cli/ca840fc9-f560-413f-acd5-249e54d818a6/tool-results/toolu_013b2RBCMMg86DkPxSgKbnVJ.txt

Preview (first 2KB):
pkg/session/session.go:119:			err := os.WriteFile(fileFullPath, []byte(markdownContent), 0644)
pkg/analytics/shared_id.go:94:	if err := os.WriteFile(filePath, data, 0644); err != nil {
pkg/cloud/auth.go:784:	if err := os.WriteFile(authPath, jsonData, 0600); err != nil {
pkg/cloud/auth_test.go:63:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:86:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:100:				if err := os.WriteFile(authPath, []byte("invalid json"), 0644); err != nil {
pkg/cloud/auth_test.go:118:				if err := os.WriteFile(authPath, jsonData, 0644); err != nil {
pkg/cloud/auth_test.go:138:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:158:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:178:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:208:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:232:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:275:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:406:	if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/provenance/fswatcher_test.go:79:	if err := os.WriteFile(filepath.Join(tmpDir, ".gitignore"), []byte(gitignoreContent), 0o644); err != nil {
pkg/provenance/fswatcher_test.go:122:	if err := os.WriteFile(filepath.Join(tmpDir, ".intentignore"), []byte(intentignoreContent), 0o644); err != nil {
pkg/provenance/fswatcher_test.go:183:	if err := os.WriteFile(testFile, []byte("package main"), 0o644); err != nil {
pkg/provenance/fswatcher_test.go:241:	if err := os.WriteFile(excludedFile, []byte(`{}`), 0o644); err != nil {
pkg/provenance/fswatcher_test.go:284:	if err := os.WriteFile(testFile, []byte("first"), 0o644); err != nil {
...
</persisted-output>
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:20:59Z)**_

Good, I now have a thorough understanding of the config package. Let me also look at a few more things: how the `~/.specstory` directory is used elsewhere (to understand if it already exists in common scenarios), and what the main.go / cmd entrypoint looks like.

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:00Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./main.go`

```text
     1→package main
     2→
     3→import (
     4→	"context"
     5→	"fmt"
     6→	"log/slog"
     7→	"os"
     8→	"os/signal"
     9→	"strings"
    10→	"syscall"
    11→	"time"
    12→
    13→	"github.com/charmbracelet/fang"
    14→	"github.com/spf13/cobra"
    15→
    16→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/analytics"
    17→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/cloud"
    18→	cmdpkg "github.com/specstoryai/getspecstory/specstory-cli/pkg/cmd" // Aliased to avoid shadowing cobra's `cmd` parameter
    19→
    20→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/config"
    21→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/log"
    22→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/provenance"
    23→	sessionpkg "github.com/specstoryai/getspecstory/specstory-cli/pkg/session"
    24→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
    25→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/factory"
    26→	"github.com/specstoryai/getspecstory/specstory-cli/pkg/utils"
    27→)
    28→
    29→// The current version of the CLI
    30→var version = "dev" // Replaced with actual version in the production build process
    31→
    32→// Flags / Modes / Options
    33→
    34→// General Options
    35→var noAnalytics bool    // flag to disable usage analytics
    36→var noVersionCheck bool // flag to skip checking for newer versions
    37→var outputDir string    // custom output directory for markdown and debug files
    38→// Sync Options
    39→var noCloudSync bool   // flag to disable cloud sync
    40→var onlyCloudSync bool // flag to skip local markdown writes and only sync to cloud
    41→var printToStdout bool // flag to output markdown to stdout instead of saving (only with -s flag)
    42→var cloudURL string    // custom cloud API URL (hidden flag)
    43→// Authentication Options
    44→var cloudToken string // cloud refresh token for this session only (used by VSC VSIX, bypasses normal login)
    45→// Logging and Debugging Options
    46→var console bool // flag to enable logging to the console
    47→var logFile bool // flag to enable logging to the log file
    48→var debug bool   // flag to enable debug level logging
    49→var silent bool  // flag to enable silent output (no user messages)
    50→// Provenance Options
    51→var provenanceEnabled bool // flag to enable AI provenance tracking
    52→
    53→// Run Mode State
    54→var lastRunSessionID string // tracks the session ID from the most recent run command for deep linking
    55→
    56→// pluralSession returns "session" or "sessions" based on count for proper grammar
    57→func pluralSession(count int) string {
    58→	if count == 1 {
    59→		return "session"
    60→	}
    61→	return "sessions"
    62→}
    63→
    64→// SyncStats tracks the results of a sync operation
    65→type SyncStats struct {
    66→	TotalSessions   int
    67→	SessionsSkipped int // Already up to date
    68→	SessionsUpdated int // Existed but needed update
    69→	SessionsCreated int // Newly created markdown files
    70→}
    71→
    72→// validateFlags checks for mutually exclusive flag combinations
    73→func validateFlags() error {
    74→	if console && silent {
    75→		return utils.ValidationError{Message: "cannot use --console and --silent together. These flags are mutually exclusive"}
    76→	}
    77→	if debug && !console && !logFile {
    78→		return utils.ValidationError{Message: "--debug requires either --console or --log to be specified"}
    79→	}
    80→	if onlyCloudSync && noCloudSync {
    81→		return utils.ValidationError{Message: "cannot use --only-cloud-sync and --no-cloud-sync together. These flags are mutually exclusive"}
    82→	}
    83→	if printToStdout && onlyCloudSync {
    84→		return utils.ValidationError{Message: "cannot use --print and --only-cloud-sync together. These flags are mutually exclusive"}
    85→	}
    86→	if printToStdout && console {
    87→		return utils.ValidationError{Message: "cannot use --print and --console together. Console debug output would interleave with markdown on stdout"}
    88→	}
    89→	return nil
    90→}
    91→
    92→// createRootCommand dynamically creates the root command with provider information
    93→func createRootCommand() *cobra.Command {
    94→	registry := factory.GetRegistry()
    95→	ids := registry.ListIDs()
    96→	providerList := registry.GetProviderList()
    97→
    98→	// Build dynamic examples based on registered providers
    99→	examples := `
   100→# Check terminal coding agents installation
   101→specstory check
   102→
   103→# Run the default agent with auto-saving
   104→specstory run`
   105→
   106→	// Add provider-specific examples if we have providers
   107→	if len(ids) > 0 {
   108→		examples += "\n\n# Run a specific agent with auto-saving"
   109→		for _, id := range ids {
   110→			if provider, _ := registry.Get(id); provider != nil {
   111→				examples += fmt.Sprintf("\nspecstory run %s", id)
   112→			}
   113→		}
   114→
   115→		// Use first provider for custom command example
   116→		examples += fmt.Sprintf("\n\n# Run with custom command\nspecstory run %s -c \"/custom/path/to/agent\"", ids[0])
   117→	}
   118→
   119→	examples += `
   120→
   121→# Generate markdown files for all agent sessions associated with the current directory
   122→specstory sync
   123→
   124→# Generate markdown files for specific agent sessions
   125→specstory sync -s <session-id>
   126→specstory sync -s <session-id-1> -s <session-id-2>
   127→
   128→# Watch for any agent activity in the current directory and generate markdown files
   129→specstory watch`
   130→
   131→	longDesc := `SpecStory is a wrapper for terminal coding agents that auto-saves markdown files of all your chat interactions.`
   132→	if providerList != "No providers registered" {
   133→		longDesc += "\n\nSupported agents: " + providerList + "."
   134→	}
   135→
   136→	return &cobra.Command{
   137→		Use:               "specstory [command]",
   138→		Short:             "SpecStory auto-saves terminal coding agent chat interactions",
   139→		Long:              longDesc,
   140→		Example:           examples,
   141→		SilenceUsage:      true,
   142→		SilenceErrors:     true,
   143→		DisableAutoGenTag: true,
   144→		CompletionOptions: cobra.CompletionOptions{DisableDefaultCmd: true},
   145→		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
   146→			// Validate flags before any other setup
   147→			if err := validateFlags(); err != nil {
   148→				fmt.Println() // Add visual separation before error message for better CLI readability
   149→				return err
   150→			}
   151→
   152→			// Configure logging based on flags
   153→			if console || logFile {
   154→				// Create output config to get proper log path if needed
   155→				var logPath string
   156→				if logFile {
   157→					config, err := utils.SetupOutputConfig(outputDir)
   158→					if err != nil {
   159→						return err
   160→					}
   161→					logPath = config.GetLogPath()
   162→				}
   163→
   164→				// Set up logger
   165→				if err := log.SetupLogger(console, logFile, debug, logPath); err != nil {
   166→					return fmt.Errorf("failed to set up logger: %v", err)
   167→				}
   168→
   169→				// Log startup information
   170→				slog.Info("=== SpecStory Starting ===")
   171→				slog.Info("Version", "version", version)
   172→				slog.Info("Command line", "args", strings.Join(os.Args, " "))
   173→				if cwd, err := os.Getwd(); err == nil {
   174→					slog.Info("Current working directory", "cwd", cwd)
   175→				}
   176→				slog.Info("========================")
   177→			} else {
   178→				// No logging - set up discard logger
   179→				if err := log.SetupLogger(false, false, false, ""); err != nil {
   180→					return err
   181→				}
   182→			}
   183→
   184→			// Set silent mode for user messages
   185→			log.SetSilent(silent)
   186→
   187→			// Initialize cloud sync manager
   188→			cloud.InitSyncManager(!noCloudSync)
   189→			cloud.SetSilent(silent)
   190→			cloud.SetClientVersion(version)
   191→			// Set custom cloud URL if provided (otherwise cloud package uses its default)
   192→			if cloudURL != "" {
   193→				cloud.SetAPIBaseURL(cloudURL)
   194→			}
   195→
   196→			// If --cloud-token flag was provided, verify the refresh token works
   197→			// This bypasses normal authentication and uses the token for this session only
   198→			if cloudToken != "" {
   199→				slog.Info("Using session-only refresh token from --cloud-token flag")
   200→				if err := cloud.SetSessionRefreshToken(cloudToken); err != nil {
   201→					fmt.Fprintln(os.Stderr) // Visual separation
   202→					fmt.Fprintln(os.Stderr, "❌ Failed to authenticate with the provided token:")
   203→					fmt.Fprintf(os.Stderr, "   %v\n", err)
   204→					fmt.Fprintln(os.Stderr)
   205→					fmt.Fprintln(os.Stderr, "💡 The token may be invalid, expired, or revoked.")
   206→					fmt.Fprintln(os.Stderr, "   Please check your token and try again, or use 'specstory login' for interactive authentication.")
   207→					fmt.Fprintln(os.Stderr)
   208→					return fmt.Errorf("authentication failed with provided token")
   209→				}
   210→				if !silent {
   211→					fmt.Println()
   212→					fmt.Println("🔑 Authenticated using provided refresh token (session-only)")
   213→					fmt.Println()
   214→				}
   215→			}
   216→
   217→			// Validate that --only-cloud-sync requires authentication
   218→			if onlyCloudSync && !cloud.IsAuthenticated() {
   219→				return utils.ValidationError{Message: "--only-cloud-sync requires authentication. Please run 'specstory login' first"}
   220→			}
   221→
   222→			return nil
   223→		},
   224→		Run: func(c *cobra.Command, args []string) {
   225→			// Track help command usage (when no command is specified)
   226→			analytics.TrackEvent(analytics.EventHelpCommand, analytics.Properties{
   227→				"help_topic":  "general",
   228→				"help_reason": "requested",
   229→			})
   230→			// If no command is specified, show logo then help
   231→			cmdpkg.DisplayLogoAndHelp(c)
   232→		},
   233→	}
   234→}
   235→
   236→var rootCmd *cobra.Command
   237→
   238→// createRunCommand dynamically creates the run command with provider information
   239→func createRunCommand() *cobra.Command {
   240→	registry := factory.GetRegistry()
   241→	ids := registry.ListIDs()
   242→	providerList := registry.GetProviderList()
   243→
   244→	// Build dynamic examples
   245→	examples := `
   246→# Run default agent with auto-saving
   247→specstory run`
   248→
   249→	if len(ids) > 0 {
   250→		examples += "\n\n# Run specific agent"
   251→		for _, id := range ids {
   252→			examples += fmt.Sprintf("\nspecstory run %s", id)
   253→		}
   254→
   255→		// Use first provider for custom command example
   256→		examples += fmt.Sprintf("\n\n# Run with custom command\nspecstory run %s -c \"/custom/path/to/agent\"", ids[0])
   257→	}
   258→
   259→	examples += `
   260→
   261→# Resume a specific session
   262→specstory run --resume 5c5c2876-febd-4c87-b80c-d0655f1cd3fd
   263→
   264→# Run with custom output directory
   265→specstory run --output-dir ~/my-sessions`
   266→
   267→	// Determine default agent name
   268→	defaultAgent := "the default agent"
   269→	if len(ids) > 0 {
   270→		if provider, err := registry.Get(ids[0]); err == nil {
   271→			defaultAgent = provider.Name()
   272→		}
   273→	}
   274→
   275→	longDesc := fmt.Sprintf(`Launch terminal coding agents in interactive mode with auto-save markdown file generation.
   276→
   277→By default, launches %s. Specify a specific agent ID to use a different agent.`, defaultAgent)
   278→	if providerList != "No providers registered" {
   279→		longDesc += "\n\nAvailable provider IDs: " + providerList + "."
   280→	}
   281→
   282→	return &cobra.Command{
   283→		Use:     "run [provider-id]",
   284→		Aliases: []string{"r"},
   285→		Short:   "Launch terminal coding agents in interactive mode with auto-save",
   286→		Long:    longDesc,
   287→		Example: examples,
   288→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument (provider ID)
   289→		PreRunE: func(cmd *cobra.Command, args []string) error {
   290→			// Get custom command if provided via flag
   291→			customCmd, _ := cmd.Flags().GetString("command")
   292→
   293→			// Validate that -c flag requires a provider
   294→			if customCmd != "" && len(args) == 0 {
   295→				registry := factory.GetRegistry()
   296→				ids := registry.ListIDs()
   297→				example := "specstory run <provider> -c \"/custom/path/to/agent\""
   298→				if len(ids) > 0 {
   299→					example = fmt.Sprintf("specstory run %s -c \"/custom/path/to/agent\"", ids[0])
   300→				}
   301→				return utils.ValidationError{
   302→					Message: "The -c/--command flag requires a provider to be specified.\n" +
   303→						"Example: " + example,
   304→				}
   305→			}
   306→			return nil
   307→		},
   308→		RunE: func(cmd *cobra.Command, args []string) error {
   309→			slog.Info("Running in interactive mode")
   310→
   311→			// Get custom command if provided via flag
   312→			customCmd, _ := cmd.Flags().GetString("command")
   313→
   314→			// Get the provider
   315→			registry := factory.GetRegistry()
   316→			var providerID string
   317→			if len(args) == 0 {
   318→				// Default to first registered provider
   319→				ids := registry.ListIDs()
   320→				if len(ids) > 0 {
   321→					providerID = ids[0]
   322→				} else {
   323→					return fmt.Errorf("no providers registered")
   324→				}
   325→			} else {
   326→				providerID = args[0]
   327→			}
   328→
   329→			provider, err := registry.Get(providerID)
   330→			if err != nil {
   331→				// Provider not found - show helpful error
   332→				fmt.Printf("❌ Provider '%s' is not a valid provider implementation\n\n", providerID)
   333→
   334→				ids := registry.ListIDs()
   335→				if len(ids) > 0 {
   336→					fmt.Println("The registered providers are:")
   337→					for _, id := range ids {
   338→						if p, _ := registry.Get(id); p != nil {
   339→							fmt.Printf("  • %s - %s\n", id, p.Name())
   340→						}
   341→					}
   342→					fmt.Println("\nExample: specstory run " + ids[0])
   343→				}
   344→				return err
   345→			}
   346→
   347→			slog.Info("Launching agent", "provider", provider.Name())
   348→
   349→			// Set the agent provider for analytics
   350→			analytics.SetAgentProviders([]string{provider.Name()})
   351→
   352→			// Setup output configuration
   353→			config, err := utils.SetupOutputConfig(outputDir)
   354→			if err != nil {
   355→				return err
   356→			}
   357→			// Ensure history directory exists for interactive mode
   358→			if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   359→				return err
   360→			}
   361→
   362→			// Initialize project identity
   363→			cwd, err := os.Getwd()
   364→			if err != nil {
   365→				slog.Error("Failed to get current working directory", "error", err)
   366→				return err
   367→			}
   368→			identityManager := utils.NewProjectIdentityManager(cwd)
   369→			if _, err := identityManager.EnsureProjectIdentity(); err != nil {
   370→				// Log error but don't fail the command
   371→				slog.Error("Failed to ensure project identity", "error", err)
   372→			}
   373→
   374→			// Create context for graceful cancellation (Ctrl+C handling)
   375→			ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
   376→			defer cancel()
   377→
   378→			// Start provenance infrastructure before the agent so all file changes are captured
   379→			provenanceEngine, provenanceCleanup, err := provenance.StartEngine(provenanceEnabled)
   380→			if err != nil {
   381→				return err
   382→			}
   383→			defer provenanceCleanup()
   384→
   385→			fsCleanup, err := provenance.StartFSWatcher(ctx, provenanceEngine, cwd)
   386→			if err != nil {
   387→				return err
   388→			}
   389→			defer fsCleanup()
   390→
   391→			// Check authentication for cloud sync
   392→			cmdpkg.CheckAndWarnAuthentication(noCloudSync)
   393→			// Track extension activation
   394→			analytics.TrackEvent(analytics.EventExtensionActivated, nil)
   395→
   396→			// Get resume session ID if provided
   397→			resumeSessionID, _ := cmd.Flags().GetString("resume")
   398→			if resumeSessionID != "" {
   399→				resumeSessionID = strings.TrimSpace(resumeSessionID)
   400→				// Note: Different providers may have different session ID formats
   401→				// Let the provider validate its own format
   402→				slog.Info("Resuming session", "sessionId", resumeSessionID)
   403→			}
   404→
   405→			// Get debug-raw flag value (must be before callback to capture in closure)
   406→			debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   407→			useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   408→			useUTC := !useLocalTimezone
   409→
   410→			// This callback pattern enables real-time processing of agent sessions
   411→			// without blocking the agent's execution. As the agent writes updates to its
   412→			// data files, the provider's watcher detects changes and invokes this callback,
   413→			// allowing immediate markdown generation and cloud sync. Errors are logged but
   414→			// don't stop execution because transient failures (e.g., network issues) shouldn't
   415→			// interrupt the user's coding session.
   416→			sessionCallback := func(session *spi.AgentChatSession) {
   417→				if session == nil {
   418→					return
   419→				}
   420→
   421→				// Track the session ID for deep linking on exit
   422→				lastRunSessionID = session.SessionID
   423→
   424→				// Process the session (write markdown and sync to cloud)
   425→				// Don't show output during interactive run mode
   426→				// This is autosave mode (true)
   427→				_, err := sessionpkg.ProcessSingleSession(session, config, onlyCloudSync, false, true, debugRaw, useUTC)
   428→				if err != nil {
   429→					// Log error but continue - don't fail the whole run
   430→					// In interactive mode, we prioritize keeping the agent running.
   431→					// Failed markdown writes or cloud syncs can be retried later via
   432→					// the sync command, so we just log and continue.
   433→					slog.Error("Failed to process session update",
   434→						"sessionId", session.SessionID,
   435→						"error", err)
   436→				}
   437→
   438→				// Push agent events to provenance engine for correlation
   439→				provenance.ProcessEvents(ctx, provenanceEngine, session)
   440→			}
   441→
   442→			// Execute the agent and watch for updates
   443→			slog.Info("Starting agent execution and monitoring", "provider", provider.Name())
   444→			err = provider.ExecAgentAndWatch(cwd, customCmd, resumeSessionID, debugRaw, sessionCallback)
   445→
   446→			if err != nil {
   447→				slog.Error("Agent execution failed", "provider", provider.Name(), "error", err)
   448→			}
   449→
   450→			return err
   451→		},
   452→	}
   453→}
   454→
   455→var runCmd *cobra.Command
   456→
   457→// createSyncCommand dynamically creates the sync command with provider information
   458→func createSyncCommand() *cobra.Command {
   459→	registry := factory.GetRegistry()
   460→	ids := registry.ListIDs()
   461→	providerList := registry.GetProviderList()
   462→
   463→	// Build dynamic examples
   464→	examples := `
   465→# Sync all agents with activity
   466→specstory sync`
   467→
   468→	if len(ids) > 0 {
   469→		examples += "\n\n# Sync specific agent"
   470→		for _, id := range ids {
   471→			examples += fmt.Sprintf("\nspecstory sync %s", id)
   472→		}
   473→	}
   474→
   475→	examples += `
   476→
   477→# Sync a specific session by UUID
   478→specstory sync -s <session-id>
   479→
   480→# Sync multiple sessions
   481→specstory sync -s <session-id-1> -s <session-id-2> -s <session-id-3>
   482→
   483→# Output session markdown to stdout without saving
   484→specstory sync -s <session-id> --print
   485→
   486→# Output multiple sessions to stdout
   487→specstory sync -s <session-id-1> -s <session-id-2> --print
   488→
   489→# Sync all sessions for the current directory, with console output
   490→specstory sync --console
   491→
   492→# Sync all sessions for the current directory, with a log file
   493→specstory sync --log`
   494→
   495→	longDesc := `Create or update markdown files for the agent sessions in the current working directory.
   496→
   497→By default, syncs all registered providers that have activity.
   498→Provide a specific agent ID to sync a specific provider.`
   499→	if providerList != "No providers registered" {
   500→		longDesc += "\n\nAvailable provider IDs: " + providerList + "."
   501→	}
   502→
   503→	return &cobra.Command{
   504→		Use:     "sync [provider-id]",
   505→		Aliases: []string{"s"},
   506→		Short:   "Sync markdown files for terminal coding agent sessions",
   507→		Long:    longDesc,
   508→		Example: examples,
   509→		Args:    cobra.MaximumNArgs(1), // Accept 0 or 1 argument (provider ID)
   510→		PreRunE: func(cmd *cobra.Command, args []string) error {
   511→			// Validate that --print requires -s flag
   512→			sessionIDs, _ := cmd.Flags().GetStringSlice("session")
   513→			if printToStdout && len(sessionIDs) == 0 {
   514→				return utils.ValidationError{Message: "--print requires the -s/--session flag to specify which sessions to output"}
   515→			}
   516→			return nil
   517→		},
   518→		RunE: func(cmd *cobra.Command, args []string) error {
   519→			// Get session IDs if provided via flag
   520→			sessionIDs, _ := cmd.Flags().GetStringSlice("session")
   521→
   522→			// Handle specific session sync if -s flag is provided
   523→			if len(sessionIDs) > 0 {
   524→				return syncSpecificSessions(cmd, args, sessionIDs)
   525→			}
   526→
   527→			slog.Info("Running sync command")
   528→			registry := factory.GetRegistry()
   529→
   530→			// Check if user specified a provider
   531→			if len(args) > 0 {
   532→				// Sync specific provider
   533→				return syncSingleProvider(registry, args[0], cmd)
   534→			} else {
   535→				// Sync all providers with activity
   536→				return syncAllProviders(registry, cmd)
   537→			}
   538→		},
   539→	}
   540→}
   541→
   542→// syncSpecificSessions syncs one or more sessions by their IDs
   543→// When printToStdout is set, outputs markdown to stdout instead of saving to files.
   544→// args[0] is the optional provider ID
   545→func syncSpecificSessions(cmd *cobra.Command, args []string, sessionIDs []string) error {
   546→	if len(sessionIDs) == 1 {
   547→		slog.Info("Running single session sync", "sessionId", sessionIDs[0])
   548→	} else {
   549→		slog.Info("Running multiple session sync", "sessionCount", len(sessionIDs))
   550→	}
   551→
   552→	// Get debug-raw flag value
   553→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   554→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   555→	useUTC := !useLocalTimezone
   556→
   557→	cwd, err := os.Getwd()
   558→	if err != nil {
   559→		slog.Error("Failed to get current working directory", "error", err)
   560→		return err
   561→	}
   562→
   563→	// Setup file output and cloud sync (not needed for --print mode)
   564→	var config utils.OutputConfig
   565→	if !printToStdout {
   566→		config, err = utils.SetupOutputConfig(outputDir)
   567→		if err != nil {
   568→			return err
   569→		}
   570→
   571→		identityManager := utils.NewProjectIdentityManager(cwd)
   572→		if _, err := identityManager.EnsureProjectIdentity(); err != nil {
   573→			slog.Error("Failed to ensure project identity", "error", err)
   574→		}
   575→
   576→		cmdpkg.CheckAndWarnAuthentication(noCloudSync)
   577→
   578→		if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   579→			return err
   580→		}
   581→	}
   582→
   583→	registry := factory.GetRegistry()
   584→
   585→	// Track statistics for summary output
   586→	var successCount, notFoundCount, errorCount int
   587→	var lastError error
   588→
   589→	// Resolve provider once if specified (fail fast if provider not found)
   590→	var specifiedProvider spi.Provider
   591→	if len(args) > 0 {
   592→		providerID := args[0]
   593→		provider, err := registry.Get(providerID)
   594→		if err != nil {
   595→			if !printToStdout {
   596→				fmt.Printf("❌ Provider '%s' not found\n", providerID)
   597→			}
   598→			return fmt.Errorf("provider '%s' not found: %w", providerID, err)
   599→		}
   600→		specifiedProvider = provider
   601→	}
   602→
   603→	// Process each session ID
   604→	var printedSessions int // tracks sessions printed to stdout for separator logic
   605→	for _, sessionID := range sessionIDs {
   606→		sessionID = strings.TrimSpace(sessionID)
   607→		if sessionID == "" {
   608→			continue // Skip empty session IDs
   609→		}
   610→
   611→		// Find session across providers
   612→		var session *spi.AgentChatSession
   613→
   614→		// Case A: Provider was specified - use it directly
   615→		if specifiedProvider != nil {
   616→			session, err = specifiedProvider.GetAgentChatSession(cwd, sessionID, debugRaw)
   617→			if err != nil {
   618→				if !printToStdout {
   619→					fmt.Printf("❌ Error getting session '%s' from %s: %v\n", sessionID, specifiedProvider.Name(), err)
   620→				}
   621→				slog.Error("Error getting session from provider", "sessionId", sessionID, "provider", specifiedProvider.Name(), "error", err)
   622→				errorCount++
   623→				lastError = err
   624→				continue
   625→			}
   626→			if session == nil {
   627→				if !printToStdout {
   628→					fmt.Printf("❌ Session '%s' not found in %s\n", sessionID, specifiedProvider.Name())
   629→				}
   630→				slog.Warn("Session not found in provider", "sessionId", sessionID, "provider", specifiedProvider.Name())
   631→				notFoundCount++
   632→				continue
   633→			}
   634→		} else {
   635→			// Case B: No provider specified - try all providers
   636→			providerIDs := registry.ListIDs()
   637→			for _, id := range providerIDs {
   638→				provider, err := registry.Get(id)
   639→				if err != nil {
   640→					continue
   641→				}
   642→
   643→				session, err = provider.GetAgentChatSession(cwd, sessionID, debugRaw)
   644→				if err != nil {
   645→					slog.Debug("Error checking provider for session", "provider", id, "sessionId", sessionID, "error", err)
   646→					continue
   647→				}
   648→				if session != nil {
   649→					if !silent && !printToStdout {
   650→						fmt.Printf("✅ Found session '%s' for %s\n", sessionID, provider.Name())
   651→					}
   652→					break // Found it, don't check other providers
   653→				}
   654→			}
   655→
   656→			if session == nil {
   657→				if !printToStdout {
   658→					fmt.Printf("❌ Session '%s' not found in any provider\n", sessionID)
   659→				}
   660→				slog.Warn("Session not found in any provider", "sessionId", sessionID)
   661→				notFoundCount++
   662→				continue
   663→			}
   664→		}
   665→
   666→		// Process the found session
   667→		if printToStdout {
   668→			sessionpkg.ValidateSessionData(session, debugRaw)
   669→			sessionpkg.WriteDebugSessionData(session, debugRaw)
   670→
   671→			markdownContent, err := sessionpkg.GenerateMarkdownFromAgentSession(session.SessionData, false, useUTC)
   672→			if err != nil {
   673→				slog.Error("Failed to generate markdown", "sessionId", session.SessionID, "error", err)
   674→				analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   675→					"session_id": session.SessionID,
   676→					"error":      err.Error(),
   677→					"mode":       "print",
   678→				})
   679→				errorCount++
   680→				lastError = err
   681→				continue
   682→			}
   683→
   684→			// Separate multiple sessions with a horizontal rule
   685→			if printedSessions > 0 {
   686→				fmt.Print("\n---\n\n")
   687→			}
   688→			fmt.Print(markdownContent)
   689→			printedSessions++
   690→			successCount++
   691→			analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
   692→				"session_id": session.SessionID,
   693→				"mode":       "print",
   694→			})
   695→		} else {
   696→			// Normal sync: write to file and optionally cloud sync
   697→			if _, err := sessionpkg.ProcessSingleSession(session, config, onlyCloudSync, true, false, debugRaw, useUTC); err != nil {
   698→				errorCount++
   699→				lastError = err
   700→			} else {
   701→				successCount++
   702→			}
   703→		}
   704→	}
   705→
   706→	// Print summary if multiple sessions were processed (not for --print mode)
   707→	if !printToStdout && len(sessionIDs) > 1 && !silent {
   708→		fmt.Println()
   709→		fmt.Println("📊 Session sync summary:")
   710→		fmt.Printf("  ✅ %d %s successfully synced\n", successCount, pluralSession(successCount))
   711→		if notFoundCount > 0 {
   712→			fmt.Printf("  ❌ %d %s not found\n", notFoundCount, pluralSession(notFoundCount))
   713→		}
   714→		if errorCount > 0 {
   715→			fmt.Printf("  ❌ %d %s failed with errors\n", errorCount, pluralSession(errorCount))
   716→		}
   717→		fmt.Println()
   718→	}
   719→
   720→	// Return error if any sessions failed
   721→	if errorCount > 0 || (notFoundCount > 0 && successCount == 0) {
   722→		if lastError != nil {
   723→			return lastError
   724→		}
   725→		return fmt.Errorf("%d %s not found", notFoundCount, pluralSession(notFoundCount))
   726→	}
   727→
   728→	return nil
   729→}
   730→
   731→// preloadBulkSessionSizesIfNeeded optimizes bulk syncs by fetching all session sizes upfront.
   732→// This avoids making individual HEAD requests for each session during sync operations.
   733→//
   734→// The function only performs the preload if:
   735→//   - Cloud sync is enabled (noCloudSync flag is false)
   736→//   - User is authenticated with SpecStory Cloud
   737→//   - A valid projectID can be determined from the identity manager
   738→//
   739→// Parameters:
   740→//   - identityManager: Provides project identity (git_id or workspace_id) for the current project
   741→//
   742→// The preloaded sizes are cached in the SyncManager and shared across all providers since they
   743→// use the same projectID. If the bulk fetch fails or if projectID cannot be determined, individual
   744→// sessions will gracefully fall back to HEAD requests during sync.
   745→//
   746→// This function is safe to call multiple times but should typically be called once before processing
   747→// multiple sessions in batch sync operations.
   748→func preloadBulkSessionSizesIfNeeded(identityManager *utils.ProjectIdentityManager) {
   749→	// Skip if cloud sync is disabled or user is not authenticated
   750→	if noCloudSync || !cloud.IsAuthenticated() {
   751→		return
   752→	}
   753→
   754→	// Get projectID from identity manager - required for cloud sync
   755→	projectID, err := identityManager.GetProjectID()
   756→	if err != nil {
   757→		slog.Warn("Cannot preload session sizes: failed to get project ID", "error", err)
   758→		return
   759→	}
   760→
   761→	// Preload bulk sizes once - shared across all providers since they use same projectID
   762→	if syncMgr := cloud.GetSyncManager(); syncMgr != nil {
   763→		syncMgr.PreloadSessionSizes(projectID)
   764→	} else {
   765→		slog.Warn("Cannot preload session sizes: sync manager is nil despite authentication")
   766→	}
   767→}
   768→
   769→// syncProvider performs the actual sync for a single provider
   770→// Returns (sessionCount, error) for analytics tracking
   771→func syncProvider(provider spi.Provider, providerID string, config utils.OutputConfig, debugRaw bool, useUTC bool) (int, error) {
   772→	cwd, err := os.Getwd()
   773→	if err != nil {
   774→		slog.Error("Failed to get current working directory", "error", err)
   775→		return 0, err
   776→	}
   777→
   778→	// Create progress callback for parsing phase
   779→	// The callback updates the "Parsing..." line in place with [n/m] progress
   780→	var parseProgress spi.ProgressCallback
   781→	if !silent {
   782→		providerName := provider.Name()
   783→		parseProgress = func(current, total int) {
   784→			fmt.Printf("\rParsing %s sessions [%d/%d]", providerName, current, total)
   785→			_ = os.Stdout.Sync()
   786→		}
   787→	}
   788→
   789→	// Get all sessions from the provider
   790→	sessions, err := provider.GetAgentChatSessions(cwd, debugRaw, parseProgress)
   791→	if err != nil {
   792→		return 0, fmt.Errorf("failed to get sessions: %w", err)
   793→	}
   794→
   795→	sessionCount := len(sessions)
   796→
   797→	if sessionCount == 0 && !silent {
   798→		// This comes after "Parsing..." message, on the same line
   799→		fmt.Printf(", no non-empty sessions found for %s\n", provider.Name())
   800→		fmt.Println()
   801→		return 0, nil
   802→	}
   803→
   804→	if !silent {
   805→		fmt.Printf("\nSyncing markdown files for %s", provider.Name())
   806→	}
   807→
   808→	// Initialize statistics
   809→	stats := &SyncStats{
   810→		TotalSessions: sessionCount,
   811→	}
   812→
   813→	historyPath := config.GetHistoryDir()
   814→
   815→	// Process each session
   816→	for i := range sessions {
   817→		session := &sessions[i]
   818→		sessionpkg.ValidateSessionData(session, debugRaw)
   819→		sessionpkg.WriteDebugSessionData(session, debugRaw)
   820→
   821→		// Generate markdown from SessionData
   822→		markdownContent, err := sessionpkg.GenerateMarkdownFromAgentSession(session.SessionData, false, useUTC)
   823→		if err != nil {
   824→			slog.Error("Failed to generate markdown from SessionData",
   825→				"sessionId", session.SessionID,
   826→				"error", err)
   827→			// Track sync error
   828→			analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   829→				"session_id": session.SessionID,
   830→				"error":      err.Error(),
   831→			})
   832→			continue
   833→		}
   834→
   835→		// Generate filename from timestamp and slug
   836→		fileFullPath := sessionpkg.BuildSessionFilePath(session, historyPath, useUTC)
   837→
   838→		// Check if file already exists with same content
   839→		identicalContent := false
   840→		fileExists := false
   841→		if existingContent, err := os.ReadFile(fileFullPath); err == nil {
   842→			fileExists = true
   843→			if string(existingContent) == markdownContent {
   844→				identicalContent = true
   845→				slog.Info("Markdown file already exists with same content, skipping write",
   846→					"sessionId", session.SessionID,
   847→					"path", fileFullPath)
   848→			}
   849→		}
   850→
   851→		// Write file if needed (skip if only-cloud-sync is enabled)
   852→		if !onlyCloudSync {
   853→			if !identicalContent {
   854→				// Ensure history directory exists (handles deletion during long-running sync)
   855→				if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
   856→					slog.Error("Failed to ensure history directory", "error", err)
   857→					continue
   858→				}
   859→				err := os.WriteFile(fileFullPath, []byte(markdownContent), 0644)
   860→				if err != nil {
   861→					slog.Error("Error writing markdown file",
   862→						"sessionId", session.SessionID,
   863→						"error", err)
   864→					// Track sync error
   865→					analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
   866→						"session_id":      session.SessionID,
   867→						"error":           err.Error(),
   868→						"only_cloud_sync": onlyCloudSync,
   869→					})
   870→					continue
   871→				}
   872→				slog.Info("Successfully wrote file",
   873→					"sessionId", session.SessionID,
   874→					"path", fileFullPath)
   875→
   876→				// Track successful sync
   877→				if !fileExists {
   878→					analytics.TrackEvent(analytics.EventSyncMarkdownNew, analytics.Properties{
   879→						"session_id":      session.SessionID,
   880→						"only_cloud_sync": onlyCloudSync,
   881→					})
   882→				} else {
   883→					analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
   884→						"session_id":      session.SessionID,
   885→						"only_cloud_sync": onlyCloudSync,
   886→					})
   887→				}
   888→			}
   889→
   890→			// Update statistics for normal mode
   891→			if identicalContent {
   892→				stats.SessionsSkipped++
   893→			} else if fileExists {
   894→				stats.SessionsUpdated++
   895→			} else {
   896→				stats.SessionsCreated++
   897→			}
   898→		} else {
   899→			// In cloud-only mode, count as skipped since no local file operation occurred
   900→			stats.SessionsSkipped++
   901→			slog.Info("Skipping local file write (only-cloud-sync mode)",
   902→				"sessionId", session.SessionID)
   903→		}
   904→
   905→		// Trigger cloud sync with provider-specific data
   906→		// Manual sync command: perform immediate sync with HEAD check (not autosave mode)
   907→		// In only-cloud-sync mode: always sync
   908→		cloud.SyncSessionToCloud(session.SessionID, fileFullPath, markdownContent, []byte(session.RawData), provider.Name(), false)
   909→
   910→		// Print progress with [n/m] format
   911→		if !silent {
   912→			fmt.Printf("\rSyncing markdown files for %s [%d/%d]", provider.Name(), i+1, sessionCount)
   913→			_ = os.Stdout.Sync()
   914→		}
   915→	}
   916→
   917→	// Print newline after progress
   918→	if !silent && sessionCount > 0 && !onlyCloudSync {
   919→		fmt.Println()
   920→
   921→		// Calculate actual total of processed sessions
   922→		actualTotal := stats.SessionsSkipped + stats.SessionsUpdated + stats.SessionsCreated
   923→
   924→		// Print summary message with proper pluralization
   925→		fmt.Printf("\n%s✅ %s sync complete!%s 📊 %s%d%s %s processed\n",
   926→			log.ColorBoldGreen, provider.Name(), log.ColorReset,
   927→			log.ColorBoldCyan, actualTotal, log.ColorReset, pluralSession(actualTotal))
   928→		fmt.Println()
   929→
   930→		fmt.Printf("  ⏭️ %s%d %s up to date (skipped)%s\n",
   931→			log.ColorCyan, stats.SessionsSkipped, pluralSession(stats.SessionsSkipped), log.ColorReset)
   932→		fmt.Printf("  ♻️ %s%d %s updated%s\n",
   933→			log.ColorYellow, stats.SessionsUpdated, pluralSession(stats.SessionsUpdated), log.ColorReset)
   934→		fmt.Printf("  ✨ %s%d new %s created%s\n",
   935→			log.ColorGreen, stats.SessionsCreated, pluralSession(stats.SessionsCreated), log.ColorReset)
   936→		fmt.Println()
   937→	}
   938→
   939→	return sessionCount, nil
   940→}
   941→
   942→// syncAllProviders syncs all providers that have activity in the current directory
   943→func syncAllProviders(registry *factory.Registry, cmd *cobra.Command) error {
   944→	// Get debug-raw flag value
   945→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
   946→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
   947→	useUTC := !useLocalTimezone
   948→
   949→	cwd, err := os.Getwd()
   950→	if err != nil {
   951→		slog.Error("Failed to get current working directory", "error", err)
   952→		return err
   953→	}
   954→
   955→	providerIDs := registry.ListIDs()
   956→	providersWithActivity := []string{}
   957→
   958→	// Check each provider for activity
   959→	for _, id := range providerIDs {
   960→		provider, err := registry.Get(id)
   961→		if err != nil {
   962→			slog.Warn("Failed to get provider", "id", id, "error", err)
   963→			continue
   964→		}
   965→
   966→		if provider.DetectAgent(cwd, false) {
   967→			providersWithActivity = append(providersWithActivity, id)
   968→		}
   969→	}
   970→
   971→	// If no providers have activity, show helpful message
   972→	if len(providersWithActivity) == 0 {
   973→		if !silent {
   974→			fmt.Println() // Add visual separation
   975→			log.UserWarn("No coding agent activity found for this project directory.\n\n")
   976→
   977→			log.UserMessage("We checked for activity in '%s' from the following agents:\n", cwd)
   978→			for _, id := range providerIDs {
   979→				if provider, err := registry.Get(id); err == nil {
   980→					log.UserMessage("- %s\n", provider.Name())
   981→				}
   982→			}
   983→			log.UserMessage("\nBut didn't find any activity.\n\n")
   984→
   985→			log.UserMessage("To fix this:\n")
   986→			log.UserMessage("  1. Run 'specstory run' to start the default agent in this directory\n")
   987→			log.UserMessage("  2. Run 'specstory run <agent>' to start a specific agent in this directory\n")
   988→			log.UserMessage("  3. Or run the agent directly first, then try syncing again\n")
   989→			fmt.Println() // Add trailing newline
   990→		}
   991→		return nil
   992→	}
   993→
   994→	// Collect provider names for analytics
   995→	var providerNames []string
   996→	for _, id := range providersWithActivity {
   997→		if provider, err := registry.Get(id); err == nil {
   998→			providerNames = append(providerNames, provider.Name())
   999→		}
  1000→	}
  1001→	analytics.SetAgentProviders(providerNames)
  1002→
  1003→	// Setup output configuration (once for all providers)
  1004→	config, err := utils.SetupOutputConfig(outputDir)
  1005→	if err != nil {
  1006→		return err
  1007→	}
  1008→
  1009→	// Initialize project identity (once for all providers)
  1010→	identityManager := utils.NewProjectIdentityManager(cwd)
  1011→	if _, err := identityManager.EnsureProjectIdentity(); err != nil {
  1012→		slog.Error("Failed to ensure project identity", "error", err)
  1013→	}
  1014→
  1015→	// Check authentication for cloud sync (once)
  1016→	cmdpkg.CheckAndWarnAuthentication(noCloudSync)
  1017→
  1018→	// Ensure history directory exists (once)
  1019→	if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
  1020→		return err
  1021→	}
  1022→
  1023→	// Preload session sizes for batch sync optimization (ONCE for all providers)
  1024→	preloadBulkSessionSizesIfNeeded(identityManager)
  1025→
  1026→	// Sync each provider with activity
  1027→	totalSessionCount := 0
  1028→	var lastError error
  1029→
  1030→	for _, id := range providersWithActivity {
  1031→		provider, err := registry.Get(id)
  1032→		if err != nil {
  1033→			continue
  1034→		}
  1035→
  1036→		if !silent {
  1037→			fmt.Printf("\nParsing %s sessions", provider.Name())
  1038→		}
  1039→
  1040→		sessionCount, err := syncProvider(provider, id, config, debugRaw, useUTC)
  1041→		totalSessionCount += sessionCount
  1042→
  1043→		if err != nil {
  1044→			lastError = err
  1045→			slog.Error("Error syncing provider", "provider", id, "error", err)
  1046→		}
  1047→	}
  1048→
  1049→	// Track overall analytics
  1050→	if lastError != nil {
  1051→		analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
  1052→			"provider":      "all",
  1053→			"error":         lastError.Error(),
  1054→			"session_count": totalSessionCount,
  1055→		})
  1056→		// Brief delay to ensure error event is sent before exit
  1057→		// TODO: This is a workaround for async analytics - should be fixed properly
  1058→		time.Sleep(500 * time.Millisecond)
  1059→	} else {
  1060→		analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
  1061→			"provider":      "all",
  1062→			"session_count": totalSessionCount,
  1063→		})
  1064→	}
  1065→
  1066→	return lastError
  1067→}
  1068→
  1069→// syncSingleProvider syncs a specific provider
  1070→func syncSingleProvider(registry *factory.Registry, providerID string, cmd *cobra.Command) error {
  1071→	// Get debug-raw flag value
  1072→	debugRaw, _ := cmd.Flags().GetBool("debug-raw")
  1073→	useLocalTimezone, _ := cmd.Flags().GetBool("local-time-zone")
  1074→	useUTC := !useLocalTimezone
  1075→
  1076→	provider, err := registry.Get(providerID)
  1077→	if err != nil {
  1078→		// Provider not found - show helpful error
  1079→		fmt.Printf("❌ Provider '%s' is not a valid provider implementation\n\n", providerID)
  1080→
  1081→		ids := registry.ListIDs()
  1082→		if len(ids) > 0 {
  1083→			fmt.Println("The registered providers are:")
  1084→			for _, id := range ids {
  1085→				if p, _ := registry.Get(id); p != nil {
  1086→					fmt.Printf("  • %s - %s\n", id, p.Name())
  1087→				}
  1088→			}
  1089→			fmt.Println("\nExample: specstory sync " + ids[0])
  1090→		}
  1091→		return err
  1092→	}
  1093→
  1094→	// Set the agent provider for analytics
  1095→	analytics.SetAgentProviders([]string{provider.Name()})
  1096→
  1097→	cwd, err := os.Getwd()
  1098→	if err != nil {
  1099→		slog.Error("Failed to get current working directory", "error", err)
  1100→		return err
  1101→	}
  1102→
  1103→	// Check if provider has activity, with helpful output if not
  1104→	if !provider.DetectAgent(cwd, true) {
  1105→		// Provider already output helpful message
  1106→		return nil
  1107→	}
  1108→
  1109→	// Setup output configuration
  1110→	config, err := utils.SetupOutputConfig(outputDir)
  1111→	if err != nil {
  1112→		return err
  1113→	}
  1114→
  1115→	// Initialize project identity
  1116→	identityManager := utils.NewProjectIdentityManager(cwd)
  1117→	if _, err := identityManager.EnsureProjectIdentity(); err != nil {
  1118→		slog.Error("Failed to ensure project identity", "error", err)
  1119→	}
  1120→
  1121→	// Check authentication for cloud sync
  1122→	cmdpkg.CheckAndWarnAuthentication(noCloudSync)
  1123→
  1124→	// Ensure history directory exists
  1125→	if err := utils.EnsureHistoryDirectoryExists(config); err != nil {
  1126→		return err
  1127→	}
  1128→
  1129→	// Preload session sizes for batch sync optimization
  1130→	preloadBulkSessionSizesIfNeeded(identityManager)
  1131→
  1132→	if !silent {
  1133→		fmt.Printf("\nParsing %s sessions", provider.Name())
  1134→	}
  1135→
  1136→	// Perform the sync
  1137→	sessionCount, syncErr := syncProvider(provider, providerID, config, debugRaw, useUTC)
  1138→
  1139→	// Track analytics
  1140→	if syncErr != nil {
  1141→		analytics.TrackEvent(analytics.EventSyncMarkdownError, analytics.Properties{
  1142→			"provider":      providerID,
  1143→			"error":         syncErr.Error(),
  1144→			"session_count": sessionCount,
  1145→		})
  1146→		// Brief delay to ensure error event is sent before exit
  1147→		// TODO: This is a workaround for async analytics - should be fixed properly
  1148→		time.Sleep(500 * time.Millisecond)
  1149→	} else {
  1150→		analytics.TrackEvent(analytics.EventSyncMarkdownSuccess, analytics.Properties{
  1151→			"provider":      providerID,
  1152→			"session_count": sessionCount,
  1153→		})
  1154→	}
  1155→
  1156→	return syncErr
  1157→}
  1158→
  1159→var syncCmd *cobra.Command
  1160→
  1161→// Main entry point for the CLI
  1162→func main() {
  1163→	// Parse critical flags early by manually checking os.Args
  1164→	// This is necessary because cobra's ParseFlags doesn't work correctly before subcommands are added
  1165→	args := os.Args[1:]
  1166→	for i := 0; i < len(args); i++ {
  1167→		arg := args[i]
  1168→		switch arg {
  1169→		case "--no-usage-analytics":
  1170→			noAnalytics = true
  1171→		case "--console":
  1172→			console = true
  1173→		case "--log":
  1174→			logFile = true
  1175→		case "--debug":
  1176→			debug = true
  1177→		case "--silent":
  1178→			silent = true
  1179→		case "--no-version-check":
  1180→			noVersionCheck = true
  1181→		case "--output-dir":
  1182→			// Handle --output-dir <value> format (space-separated)
  1183→			if i+1 < len(args) && !strings.HasPrefix(args[i+1], "-") {
  1184→				outputDir = args[i+1]
  1185→				i++ // Skip the value in next iteration
  1186→			}
  1187→		}
  1188→		// Handle --output-dir=value format
  1189→		if strings.HasPrefix(arg, "--output-dir=") {
  1190→			outputDir = strings.TrimPrefix(arg, "--output-dir=")
  1191→		}
  1192→	}
  1193→
  1194→	// Load configuration early (before logging setup) so TOML settings can affect logging
  1195→	// Priority: CLI flags > local project config > user-level config
  1196→	cfg, cfgErr := config.Load(&config.CLIOverrides{
  1197→		OutputDir:      outputDir,
  1198→		NoVersionCheck: noVersionCheck,
  1199→		NoCloudSync:    noCloudSync,
  1200→		OnlyCloudSync:  onlyCloudSync,
  1201→		Console:        console,
  1202→		Log:            logFile,
  1203→		Debug:          debug,
  1204→		Silent:         silent,
  1205→		NoAnalytics:    noAnalytics,
  1206→	})
  1207→	if cfgErr != nil {
  1208→		// Use fallback empty config if load fails - will log error after logging is set up
  1209→		cfg = &config.Config{}
  1210→	}
  1211→
  1212→	// Apply config values to flag variables so the rest of the code can use them unchanged.
  1213→	// This merges TOML config with CLI flags (CLI flags take precedence via config.Load).
  1214→	if cfg.GetOutputDir() != "" {
  1215→		outputDir = cfg.GetOutputDir()
  1216→	}
  1217→	noVersionCheck = !cfg.IsVersionCheckEnabled()
  1218→	noCloudSync = !cfg.IsCloudSyncEnabled()
  1219→	onlyCloudSync = !cfg.IsLocalSyncEnabled()
  1220→	noAnalytics = !cfg.IsAnalyticsEnabled()
  1221→	console = cfg.IsConsoleEnabled()
  1222→	logFile = cfg.IsLogEnabled()
  1223→	debug = cfg.IsDebugEnabled()
  1224→	silent = cfg.IsSilentEnabled()
  1225→
  1226→	// Set up logging early before creating commands (which access the registry)
  1227→	if console || logFile {
  1228→		var logPath string
  1229→		if logFile {
  1230→			config, _ := utils.SetupOutputConfig(outputDir)
  1231→			logPath = config.GetLogPath()
  1232→		}
  1233→		_ = log.SetupLogger(console, logFile, debug, logPath)
  1234→	} else {
  1235→		// Set up discard logger to prevent default slog output
  1236→		_ = log.SetupLogger(false, false, false, "")
  1237→	}
  1238→
  1239→	// NOW create the commands - after logging is configured
  1240→	rootCmd = createRootCommand()
  1241→	runCmd = createRunCommand()
  1242→	watchCmd := cmdpkg.CreateWatchCommand(&cloudURL)
  1243→	syncCmd = createSyncCommand()
  1244→	listCmd := cmdpkg.CreateListCommand()
  1245→	checkCmd := cmdpkg.CreateCheckCommand()
  1246→	versionCmd := cmdpkg.CreateVersionCommand(version)
  1247→	loginCmd := cmdpkg.CreateLoginCommand(&cloudURL)
  1248→	logoutCmd := cmdpkg.CreateLogoutCommand(&cloudURL)
  1249→
  1250→	// Set version for the automatic version flag
  1251→	rootCmd.Version = version
  1252→
  1253→	// Override the default version template to match our version command output
  1254→	rootCmd.SetVersionTemplate("{{.Version}} (SpecStory)")
  1255→
  1256→	// Set our custom help command (for "specstory help")
  1257→	helpCmd := cmdpkg.CreateHelpCommand(rootCmd)
  1258→	rootCmd.SetHelpCommand(helpCmd)
  1259→
  1260→	// Add the subcommands
  1261→	rootCmd.AddCommand(runCmd)
  1262→	rootCmd.AddCommand(watchCmd)
  1263→	rootCmd.AddCommand(syncCmd)
  1264→	rootCmd.AddCommand(listCmd)
  1265→	rootCmd.AddCommand(versionCmd)
  1266→	rootCmd.AddCommand(checkCmd)
  1267→	rootCmd.AddCommand(loginCmd)
  1268→	rootCmd.AddCommand(logoutCmd)
  1269→
  1270→	// Global flags available on all commands
  1271→	// Use current variable values as defaults so config file values are preserved
  1272→	rootCmd.PersistentFlags().BoolVar(&console, "console", console, "enable error/warn/info output to stdout")
  1273→	rootCmd.PersistentFlags().BoolVar(&logFile, "log", logFile, "write error/warn/info output to ./.specstory/debug/debug.log")
  1274→	rootCmd.PersistentFlags().BoolVar(&debug, "debug", debug, "enable debug-level output (requires --console or --log)")
  1275→	rootCmd.PersistentFlags().BoolVar(&noAnalytics, "no-usage-analytics", noAnalytics, "disable usage analytics")
  1276→	rootCmd.PersistentFlags().BoolVar(&silent, "silent", silent, "suppress all non-error output")
  1277→	rootCmd.PersistentFlags().BoolVar(&noVersionCheck, "no-version-check", noVersionCheck, "skip checking for newer versions")
  1278→	rootCmd.PersistentFlags().StringVar(&cloudToken, "cloud-token", "", "use a SpecStory Cloud refresh token for this session (bypasses login)")
  1279→	_ = rootCmd.PersistentFlags().MarkHidden("cloud-token") // Hidden flag
  1280→
  1281→	// Command-specific flags
  1282→	syncCmd.Flags().StringSliceP("session", "s", []string{}, "optional session IDs to sync (can be specified multiple times, provider-specific format)")
  1283→	syncCmd.Flags().BoolVar(&printToStdout, "print", printToStdout, "output session markdown to stdout instead of saving (requires -s flag)")
  1284→	syncCmd.Flags().StringVar(&outputDir, "output-dir", outputDir, "custom output directory for markdown and debug files (default: ./.specstory/history)")
  1285→	syncCmd.Flags().BoolVar(&noCloudSync, "no-cloud-sync", noCloudSync, "disable cloud sync functionality")
  1286→	syncCmd.Flags().BoolVar(&onlyCloudSync, "only-cloud-sync", onlyCloudSync, "skip local markdown file saves, only upload to cloud (requires authentication)")
  1287→	syncCmd.Flags().StringVar(&cloudURL, "cloud-url", "", "override the default cloud API base URL")
  1288→	_ = syncCmd.Flags().MarkHidden("cloud-url") // Hidden flag
  1289→	syncCmd.Flags().Bool("debug-raw", false, "debug mode to output pretty-printed raw data files")
  1290→	_ = syncCmd.Flags().MarkHidden("debug-raw") // Hidden flag
  1291→	syncCmd.Flags().BoolP("local-time-zone", "", false, "use local timezone for file name and content timestamps (when not present: UTC)")
  1292→
  1293→	runCmd.Flags().BoolVar(&provenanceEnabled, "provenance", false, "enable AI provenance tracking (correlate file changes to agent activity)")
  1294→	_ = runCmd.Flags().MarkHidden("provenance") // Hidden flag
  1295→	runCmd.Flags().StringP("command", "c", "", "custom agent execution command for the provider")
  1296→	runCmd.Flags().String("resume", "", "resume a specific session by ID")
  1297→	runCmd.Flags().StringVar(&outputDir, "output-dir", outputDir, "custom output directory for markdown and debug files (default: ./.specstory/history)")
  1298→	runCmd.Flags().BoolVar(&noCloudSync, "no-cloud-sync", noCloudSync, "disable cloud sync functionality")
  1299→	runCmd.Flags().BoolVar(&onlyCloudSync, "only-cloud-sync", onlyCloudSync, "skip local markdown file saves, only upload to cloud (requires authentication)")
  1300→	runCmd.Flags().StringVar(&cloudURL, "cloud-url", "", "override the default cloud API base URL")
  1301→	_ = runCmd.Flags().MarkHidden("cloud-url") // Hidden flag
  1302→	runCmd.Flags().Bool("debug-raw", false, "debug mode to output pretty-printed raw data files")
  1303→	_ = runCmd.Flags().MarkHidden("debug-raw") // Hidden flag
  1304→	runCmd.Flags().BoolP("local-time-zone", "", false, "use local timezone for file name and content timestamps (when not present: UTC)")
  1305→
  1306→	// Initialize analytics with the full CLI command (unless disabled)
  1307→	slog.Debug("Analytics initialization check", "noAnalytics", noAnalytics, "flag_should_disable", noAnalytics)
  1308→	if !noAnalytics {
  1309→		slog.Debug("Initializing analytics")
  1310→		fullCommand := strings.Join(os.Args, " ")
  1311→		if err := analytics.Init(fullCommand, version); err != nil {
  1312→			// Log error but don't fail - analytics should not break the app
  1313→			slog.Warn("Failed to initialize analytics", "error", err)
  1314→		}
  1315→		defer func() { _ = analytics.Close() }() // Analytics errors shouldn't break the app
  1316→	} else {
  1317→		slog.Debug("Analytics disabled by --no-usage-analytics flag")
  1318→	}
  1319→
  1320→	// Log config load error after logging is set up
  1321→	if cfgErr != nil {
  1322→		slog.Warn("Failed to load config file, using defaults", "error", cfgErr)
  1323→	}
  1324→
  1325→	// Check for updates (blocking)
  1326→	utils.CheckForUpdates(version, noVersionCheck, silent)
  1327→
  1328→	// Ensure proper cleanup and logging on exit
  1329→	defer func() {
  1330→		if r := recover(); r != nil {
  1331→			slog.Error("=== SpecStory PANIC ===", "panic", r)
  1332→			// Still try to wait for cloud sync even on panic
  1333→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1334→			log.CloseLogger()
  1335→			panic(r) // Re-panic after logging
  1336→		}
  1337→		// Wait for cloud sync operations to complete before exiting
  1338→		cloudStats := cloud.Shutdown(cloud.CloudSyncTimeout)
  1339→
  1340→		// Track cloud sync analytics if we have stats
  1341→		if cloudStats != nil {
  1342→			// Calculate total attempted (all sessions that started sync)
  1343→			totalCloudSessions := cloudStats.SessionsAttempted
  1344→
  1345→			// Track cloud sync completion event
  1346→			if cloudStats.SessionsUpdated > 0 || cloudStats.SessionsCreated > 0 || cloudStats.SessionsErrored > 0 || cloudStats.SessionsTimedOut > 0 {
  1347→				analytics.TrackEvent(analytics.EventCloudSyncComplete, analytics.Properties{
  1348→					"sessions_created":   cloudStats.SessionsCreated,
  1349→					"sessions_updated":   cloudStats.SessionsUpdated,
  1350→					"sessions_skipped":   cloudStats.SessionsSkipped,
  1351→					"sessions_errored":   cloudStats.SessionsErrored,
  1352→					"sessions_timed_out": cloudStats.SessionsTimedOut,
  1353→					"total":              totalCloudSessions,
  1354→				})
  1355→			}
  1356→
  1357→			// Display cloud sync stats if not in silent mode
  1358→			if !silent && totalCloudSessions > 0 {
  1359→				fmt.Println() // Visual separation from provider sync output
  1360→
  1361→				// Determine if sync was complete or incomplete based on errors/timeouts
  1362→				if cloudStats.SessionsErrored > 0 || cloudStats.SessionsTimedOut > 0 {
  1363→					fmt.Printf("❌ Cloud sync incomplete! 📊 %s%d%s %s processed\n",
  1364→						log.ColorBoldCyan, totalCloudSessions, log.ColorReset, pluralSession(int(totalCloudSessions)))
  1365→				} else {
  1366→					fmt.Printf("☁️  Cloud sync complete! 📊 %s%d%s %s processed\n",
  1367→						log.ColorBoldCyan, totalCloudSessions, log.ColorReset, pluralSession(int(totalCloudSessions)))
  1368→				}
  1369→				fmt.Println()
  1370→
  1371→				fmt.Printf("  ⏭️ %s%d %s up to date (skipped)%s\n",
  1372→					log.ColorCyan, cloudStats.SessionsSkipped, pluralSession(int(cloudStats.SessionsSkipped)), log.ColorReset)
  1373→				fmt.Printf("  ♻️ %s%d %s updated%s\n",
  1374→					log.ColorYellow, cloudStats.SessionsUpdated, pluralSession(int(cloudStats.SessionsUpdated)), log.ColorReset)
  1375→				fmt.Printf("  ✨ %s%d new %s created%s\n",
  1376→					log.ColorGreen, cloudStats.SessionsCreated, pluralSession(int(cloudStats.SessionsCreated)), log.ColorReset)
  1377→
  1378→				// Only show errors if there were any
  1379→				if cloudStats.SessionsErrored > 0 {
  1380→					fmt.Printf("  ❌ %s%d %s errored%s\n",
  1381→						log.ColorRed, cloudStats.SessionsErrored, pluralSession(int(cloudStats.SessionsErrored)), log.ColorReset)
  1382→				}
  1383→
  1384→				// Only show timed out sessions if there were any
  1385→				if cloudStats.SessionsTimedOut > 0 {
  1386→					fmt.Printf("  ⏱️  %s%d %s timed out%s\n",
  1387→						log.ColorRed, cloudStats.SessionsTimedOut, pluralSession(int(cloudStats.SessionsTimedOut)), log.ColorReset)
  1388→				}
  1389→				fmt.Println()
  1390→
  1391→				// Display link to SpecStory Cloud (deep link to session if from run command)
  1392→				cwd, cwdErr := os.Getwd()
  1393→				if cwdErr == nil {
  1394→					identityManager := utils.NewProjectIdentityManager(cwd)
  1395→					if projectID, err := identityManager.GetProjectID(); err == nil {
  1396→						fmt.Printf("💡 Search and chat with your AI conversation history at:\n")
  1397→						if lastRunSessionID != "" {
  1398→							// Deep link to the specific session from run command
  1399→							fmt.Printf("   %shttps://cloud.specstory.com/projects/%s/sessions/%s%s\n\n",
  1400→								log.ColorBoldCyan, projectID, lastRunSessionID, log.ColorReset)
  1401→						} else {
  1402→							// Link to project overview for sync command
  1403→							fmt.Printf("   %shttps://cloud.specstory.com/projects/%s%s\n\n",
  1404→								log.ColorBoldCyan, projectID, log.ColorReset)
  1405→						}
  1406→					}
  1407→				}
  1408→			}
  1409→		}
  1410→
  1411→		if console || logFile {
  1412→			slog.Info("=== SpecStory Exiting ===", "code", 0, "status", "normal termination")
  1413→		}
  1414→		log.CloseLogger()
  1415→	}()
  1416→
  1417→	if err := fang.Execute(context.Background(), rootCmd, fang.WithVersion(version)); err != nil {
  1418→		// Check if we're running the check command by looking at the executed command
  1419→		executedCmd, _, _ := rootCmd.Find(os.Args[1:])
  1420→		if executedCmd == checkCmd {
  1421→			if console || logFile {
  1422→				slog.Error("=== SpecStory Exiting ===", "code", 2, "status", "agent execution failure")
  1423→				slog.Error("Error", "error", err)
  1424→			}
  1425→			// For check command, the error details are handled by checkSingleProvider/checkAllProviders
  1426→			// So we just exit silently here
  1427→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1428→			os.Exit(2)
  1429→		} else {
  1430→			if console || logFile {
  1431→				slog.Error("=== SpecStory Exiting ===", "code", 1, "status", "error")
  1432→				slog.Error("Error", "error", err)
  1433→			}
  1434→			fmt.Fprintln(os.Stderr) // Visual separation makes error output more noticeable
  1435→
  1436→			// Only show usage for actual command/flag errors from Cobra
  1437→			// These are errors like "unknown command", "unknown flag", "invalid argument", etc.
  1438→			// For all other errors (authentication, network, file system, etc.), we should NOT show usage
  1439→			errMsg := err.Error()
  1440→			isCommandError := strings.Contains(errMsg, "unknown command") ||
  1441→				strings.Contains(errMsg, "unknown flag") ||
  1442→				strings.Contains(errMsg, "invalid argument") ||
  1443→				strings.Contains(errMsg, "required flag") ||
  1444→				strings.Contains(errMsg, "accepts") || // e.g., "accepts 1 arg(s), received 2"
  1445→				strings.Contains(errMsg, "no such flag") ||
  1446→				strings.Contains(errMsg, "flag needs an argument")
  1447→
  1448→			if isCommandError {
  1449→				_ = rootCmd.Usage() // Ignore error; we're exiting anyway
  1450→				fmt.Println()       // Add visual separation after usage for better CLI readability
  1451→			}
  1452→			_ = cloud.Shutdown(cloud.CloudSyncTimeout)
  1453→			os.Exit(1)
  1454→		}
  1455→	}
  1456→}
  1457→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:01Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg/analytics` pattern `\.specstory`

```text
No matches found
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:02Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg` pattern `getUserConfigPath\|userConfigPath\|~/.specstory`

```text
No matches found
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:05Z)**_

Now let me look at how the analytics `shared_id.go` handles a similar pattern of creating a file in `~/.specstory/`, since it appears to do something similar.

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:06Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./pkg/analytics/shared_id.go`

```text
     1→package analytics
     2→
     3→import (
     4→	"encoding/json"
     5→	"fmt"
     6→	"os"
     7→	"path/filepath"
     8→	"runtime"
     9→	"time"
    10→
    11→	"github.com/google/uuid"
    12→)
    13→
    14→// SharedAnalyticsID represents the shared analytics configuration
    15→type SharedAnalyticsID struct {
    16→	AnalyticsID string    `json:"analytics_id"`
    17→	CreatedAt   time.Time `json:"created_at"`
    18→	Source      string    `json:"source"`
    19→}
    20→
    21→// getSharedAnalyticsPath returns the path to the shared analytics file (macOS only)
    22→func getSharedAnalyticsPath() (string, error) {
    23→	if runtime.GOOS != "darwin" {
    24→		return "", fmt.Errorf("shared analytics path only available on macOS")
    25→	}
    26→
    27→	homeDir, err := os.UserHomeDir()
    28→	if err != nil {
    29→		return "", fmt.Errorf("failed to get user home directory: %w", err)
    30→	}
    31→
    32→	// macOS-specific path
    33→	return filepath.Join(homeDir, "Library", "Application Support", "SpecStory", "analytics-id.json"), nil
    34→}
    35→
    36→// loadOrCreateSharedAnalyticsID loads the shared analytics ID or creates a new one
    37→func loadOrCreateSharedAnalyticsID() (string, error) {
    38→	// Only use shared ID on macOS
    39→	if runtime.GOOS != "darwin" {
    40→		return "", fmt.Errorf("shared analytics ID only supported on macOS")
    41→	}
    42→
    43→	filePath, err := getSharedAnalyticsPath()
    44→	if err != nil {
    45→		return "", err
    46→	}
    47→
    48→	// Try to read existing file
    49→	data, err := os.ReadFile(filePath)
    50→	if err == nil {
    51→		// File exists, parse it
    52→		var shared SharedAnalyticsID
    53→		if err := json.Unmarshal(data, &shared); err != nil {
    54→			return "", fmt.Errorf("failed to parse analytics file: %w", err)
    55→		}
    56→
    57→		return shared.AnalyticsID, nil
    58→	}
    59→
    60→	// File doesn't exist, create new one
    61→	if !os.IsNotExist(err) {
    62→		return "", fmt.Errorf("failed to read analytics file: %w", err)
    63→	}
    64→
    65→	// Create directory if it doesn't exist
    66→	dir := filepath.Dir(filePath)
    67→	if err := os.MkdirAll(dir, 0755); err != nil {
    68→		return "", fmt.Errorf("failed to create directory: %w", err)
    69→	}
    70→
    71→	// Generate new analytics ID
    72→	newID := uuid.New().String()
    73→
    74→	shared := &SharedAnalyticsID{
    75→		AnalyticsID: newID,
    76→		CreatedAt:   time.Now().UTC(),
    77→		Source:      "specstory-cli",
    78→	}
    79→
    80→	if err := saveSharedAnalyticsID(filePath, shared); err != nil {
    81→		return "", err
    82→	}
    83→
    84→	return newID, nil
    85→}
    86→
    87→// saveSharedAnalyticsID saves the shared analytics configuration to file
    88→func saveSharedAnalyticsID(filePath string, shared *SharedAnalyticsID) error {
    89→	data, err := json.MarshalIndent(shared, "", "  ")
    90→	if err != nil {
    91→		return fmt.Errorf("failed to marshal analytics data: %w", err)
    92→	}
    93→
    94→	if err := os.WriteFile(filePath, data, 0644); err != nil {
    95→		return fmt.Errorf("failed to write analytics file: %w", err)
    96→	}
    97→
    98→	return nil
    99→}
   100→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:08Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg` pattern `0644|0755|0o644|0o755`

```text
pkg/session/session.go:119:			err := os.WriteFile(fileFullPath, []byte(markdownContent), 0644)
pkg/analytics/shared_id.go:67:	if err := os.MkdirAll(dir, 0755); err != nil {
pkg/analytics/shared_id.go:94:	if err := os.WriteFile(filePath, data, 0644); err != nil {
pkg/log/logger.go:86:		if err := os.MkdirAll(dir, 0755); err != nil {
pkg/log/logger.go:91:		file, err := os.OpenFile(logPath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
pkg/cloud/auth_test.go:51:				if err := os.MkdirAll(authDir, 0755); err != nil {
pkg/cloud/auth_test.go:63:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:74:				if err := os.MkdirAll(authDir, 0755); err != nil {
pkg/cloud/auth_test.go:86:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:97:				if err := os.MkdirAll(authDir, 0755); err != nil {
pkg/cloud/auth_test.go:100:				if err := os.WriteFile(authPath, []byte("invalid json"), 0644); err != nil {
pkg/cloud/auth_test.go:111:				if err := os.MkdirAll(authDir, 0755); err != nil {
pkg/cloud/auth_test.go:118:				if err := os.WriteFile(authPath, jsonData, 0644); err != nil {
pkg/cloud/auth_test.go:129:				if err := os.MkdirAll(authDir, 0755); err != nil {
pkg/cloud/auth_test.go:138:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:149:				if err := os.MkdirAll(authDir, 0755); err != nil {
pkg/cloud/auth_test.go:158:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:169:				if err := os.MkdirAll(authDir, 0755); err != nil {
pkg/cloud/auth_test.go:178:				if err := os.WriteFile(authPath, data, 0644); err != nil {
pkg/cloud/auth_test.go:189:				if err := os.MkdirAll(authDir, 0755); err != nil {

[Showing results with pagination = limit: 20, offset: 0]
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:11Z)**_

Now I have a thorough understanding of the codebase. Let me also check the existing test patterns to see if there are any tests that verify file creation behavior.

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:21:12Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg/config/config_test.go` pattern `t\.TempDir`

```text
84:			tempHome := t.TempDir()
85:			tempProject := t.TempDir()
286:			tempHome := t.TempDir()
287:			tempProject := t.TempDir()
362:			tempHome := t.TempDir()
363:			tempProject := t.TempDir()
462:			tempHome := t.TempDir()
463:			tempProject := t.TempDir()
529:	tempHome := t.TempDir()
530:	tempProject := t.TempDir()
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-6 2026-02-22 15:22:38Z)**_

I now have a complete understanding of the codebase. Here is the implementation plan.

---

## Implementation Plan: Auto-Create Default `~/.specstory/cli-config.toml`

### Overview

When the `Load()` function detects that `~/.specstory/cli-config.toml` does not exist, it should create a default file with all options commented out. This serves as a discoverability mechanism so users know the config file exists and what options are available.

### 1. Changes to `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go`

#### 1a. Add a const string for the default config template

Add a new constant `defaultConfigTemplate` right after the existing `const` block (after line 25). Using a const string (rather than generating from the struct) is the right approach because:

- It allows rich, human-readable comments explaining each option and its default
- It is trivial to maintain -- when a new config option is added, the developer adds a line to the template
- Generating from struct tags would require reflection and would not produce nice comments

The template content should be:

```go
// defaultConfigTemplate is the commented-out TOML template written to
// ~/.specstory/cli-config.toml when no user-level config file exists.
// This helps users discover available configuration options.
const defaultConfigTemplate = `# SpecStory CLI Configuration
#
# This is the user-level config file for SpecStory CLI.
# All settings here apply to every project unless overridden by a
# project-level config at ./.specstory/cli-config.toml or CLI flags.
#
# Uncomment and edit any setting below to change the default behavior.
# For more information, see: https://github.com/specstoryai/specstory

# Custom output directory for markdown and debug files.
# Default: .specstory (relative to the project directory)
# output_dir = ""

# [version_check]
# Check for newer versions of the CLI on startup.
# Default: true
# enabled = true

# [cloud_sync]
# Sync session data to SpecStory Cloud.
# Default: true
# enabled = true

# [local_sync]
# Write markdown files locally.
# When false, only cloud sync is performed (equivalent to --only-cloud-sync).
# Default: true
# enabled = true

# [logging]
# Console enables error/warn/info output to stdout.
# Default: false
# console = false
#
# Log enables writing error/warn/info output to .specstory/debug/debug.log.
# Default: false
# log = false
#
# Debug enables debug-level output (requires console or log to be enabled).
# Default: false
# debug = false
#
# Silent suppresses all non-error output.
# Default: false
# silent = false

# [analytics]
# Send anonymous usage analytics to help improve SpecStory.
# Default: true
# enabled = true
`
```

Key design decisions for the template:

- Every option is commented out with `#`, so the file has zero effect when first created
- Section headers like `[version_check]` are also commented out -- this is important because an uncommented section header in TOML would be valid even with all keys commented, but it reads more clearly when everything is uniformly commented
- Each option has a comment explaining what it does and what its default is
- A link to the GitHub repo is included for documentation
- The file ends with a trailing newline (Go convention for text files)

#### 1b. Add the `ensureDefaultUserConfig` function

Add a new unexported function after `getUserConfigPath()` (after line 154). This function:

1. Takes the config path as a parameter (for testability -- avoids calling `getUserConfigPath()` internally)
2. Creates the `~/.specstory/` directory if it does not exist
3. Writes the default template to the file
4. Logs success or failure, but never returns an error (failures are non-fatal)

```go
// ensureDefaultUserConfig creates a default user-level config file if one
// does not exist. The file contains all options commented out so users can
// discover and enable them. Failures are logged but not returned because
// the config file is optional -- the CLI works fine without it.
func ensureDefaultUserConfig(path string) {
	// Create the directory (~/.specstory/) if it doesn't exist
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		slog.Debug("Could not create config directory, skipping default config creation",
			"path", dir, "error", err)
		return
	}

	// Write the default template
	if err := os.WriteFile(path, []byte(defaultConfigTemplate), 0644); err != nil {
		slog.Debug("Could not write default config file, skipping",
			"path", path, "error", err)
		return
	}

	slog.Debug("Created default user-level config file", "path", path)
}
```

Design notes:

- Uses `0755` for the directory (matching existing patterns in `pkg/analytics/shared_id.go` line 67 and `pkg/log/logger.go` line 86)
- Uses `0644` for the file (matching existing file write patterns throughout the codebase)
- Only uses `slog.Debug` for logging -- this is consistent with the existing config loading debug messages on lines 113, 119, 128, 133
- Does not return an error -- the caller should not care if this fails
- Takes `path` as a parameter rather than calling `getUserConfigPath()` internally -- this avoids double-computing the path and makes the function testable with temp directories

#### 1c. Modify `Load()` to call `ensureDefaultUserConfig`

In the `Load()` function, modify the `os.IsNotExist` branch (line 112-113) to call the new function. The change is minimal:

Current code (lines 111-114):

```go
if err := loadTOMLFile(userConfigPath, cfg); err != nil {
    if os.IsNotExist(err) {
        slog.Debug("No user-level config file found", "path", userConfigPath)
    } else {
```

New code:

```go
if err := loadTOMLFile(userConfigPath, cfg); err != nil {
    if os.IsNotExist(err) {
        slog.Debug("No user-level config file found", "path", userConfigPath)
        ensureDefaultUserConfig(userConfigPath)
    } else {
```

This is exactly one line added. The function is called in the right place because:

- We already know the file does not exist (we just checked with `os.IsNotExist`)
- We already have the computed path (`userConfigPath`)
- It happens before the local project config is loaded, so there is no ordering concern
- Failure is non-fatal (the function logs and returns silently)

### 2. Test Plan for `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go`

Add a new test function `TestEnsureDefaultUserConfig` with table-driven subtests.

#### Test cases

1. **Creates file when directory and file do not exist** -- Set HOME to an empty temp dir. Call `Load(nil)`. Verify `~/.specstory/cli-config.toml` now exists. Verify the content matches `defaultConfigTemplate`. Verify the returned config is still a zero-value config (since everything is commented out).

2. **Does not overwrite existing file** -- Create a temp HOME with an existing `~/.specstory/cli-config.toml` containing `output_dir = "/custom"`. Call `Load(nil)`. Verify the file still contains the original content. Verify `cfg.GetOutputDir()` returns `/custom`.

3. **Handles read-only directory gracefully** -- Create a temp HOME. Create `~/.specstory/` with permissions `0555` (read-only). Call `Load(nil)`. Verify no error is returned from `Load()`. Verify the config file was NOT created (because write permission denied).

4. **Template parses as valid TOML when uncommented** -- Take `defaultConfigTemplate`, strip the leading `#` and space from each line, feed it through `toml.Decode` into a `Config` struct. Verify it parses without error. This is a guard against template syntax errors that could break the user experience when they uncomment options.

5. **Created file is parseable by Load** -- After `Load(nil)` creates the default file, call `Load(nil)` again. Verify the second call succeeds without error and returns the same default config values.

Here is the test structure:

```go
// TestEnsureDefaultUserConfig tests that a default config file is created
// when no user-level config exists
func TestEnsureDefaultUserConfig(t *testing.T) {
	origWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get working directory: %v", err)
	}
	defer func() { _ = os.Chdir(origWd) }()

	origHome := os.Getenv("HOME")
	defer func() { _ = os.Setenv("HOME", origHome) }()

	t.Run("creates default config when file does not exist", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		cfg, err := Load(nil)
		if err != nil {
			t.Fatalf("Load() returned error: %v", err)
		}

		// Verify default config values (everything should be defaults)
		if cfg.GetOutputDir() != "" {
			t.Errorf("GetOutputDir() = %q, want empty", cfg.GetOutputDir())
		}

		// Verify file was created
		configPath := filepath.Join(tempHome, SpecStoryDir, ConfigFileName)
		content, err := os.ReadFile(configPath)
		if err != nil {
			t.Fatalf("Default config file was not created: %v", err)
		}

		if string(content) != defaultConfigTemplate {
			t.Errorf("Default config content does not match template")
		}
	})

	t.Run("does not overwrite existing config", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		// Create existing config
		existingContent := `output_dir = "/custom"`
		createTempConfigFile(t, tempHome, existingContent)

		cfg, err := Load(nil)
		if err != nil {
			t.Fatalf("Load() returned error: %v", err)
		}

		// Verify existing config was loaded, not overwritten
		if cfg.GetOutputDir() != "/custom" {
			t.Errorf("GetOutputDir() = %q, want %q", cfg.GetOutputDir(), "/custom")
		}
	})

	t.Run("handles unwritable directory gracefully", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		// Create .specstory dir as read-only
		specDir := filepath.Join(tempHome, SpecStoryDir)
		if err := os.MkdirAll(specDir, 0555); err != nil {
			t.Fatalf("Failed to create dir: %v", err)
		}
		// Cleanup: restore write permissions so t.TempDir() can remove it
		defer func() { _ = os.Chmod(specDir, 0755) }()

		// Load should succeed (failure to create default config is non-fatal)
		_, err := Load(nil)
		if err != nil {
			t.Fatalf("Load() returned error: %v", err)
		}

		// Verify file was NOT created (permission denied)
		configPath := filepath.Join(specDir, ConfigFileName)
		if _, err := os.Stat(configPath); !os.IsNotExist(err) {
			t.Errorf("Config file should not have been created in read-only dir")
		}
	})

	t.Run("created file is loadable on subsequent calls", func(t *testing.T) {
		tempHome := t.TempDir()
		tempProject := t.TempDir()

		if err := os.Setenv("HOME", tempHome); err != nil {
			t.Fatalf("Failed to set HOME: %v", err)
		}
		if err := os.Chdir(tempProject); err != nil {
			t.Fatalf("Failed to chdir: %v", err)
		}

		// First call creates the file
		_, err := Load(nil)
		if err != nil {
			t.Fatalf("First Load() returned error: %v", err)
		}

		// Second call should load the created file without error
		cfg, err := Load(nil)
		if err != nil {
			t.Fatalf("Second Load() returned error: %v", err)
		}

		// All values should still be defaults (everything commented out)
		if cfg.IsVersionCheckEnabled() != true {
			t.Errorf("IsVersionCheckEnabled() should be true")
		}
		if cfg.IsCloudSyncEnabled() != true {
			t.Errorf("IsCloudSyncEnabled() should be true")
		}
	})
}

// TestDefaultConfigTemplateParsesWhenUncommented verifies the template
// is valid TOML when all comment markers are removed
func TestDefaultConfigTemplateParsesWhenUncommented(t *testing.T) {
	// Strip "# " prefix from each line to simulate a fully-uncommented config
	lines := strings.Split(defaultConfigTemplate, "\n")
	var uncommented []string
	for _, line := range lines {
		if strings.HasPrefix(line, "# ") {
			uncommented = append(uncommented, strings.TrimPrefix(line, "# "))
		} else if line == "#" {
			uncommented = append(uncommented, "")
		} else {
			uncommented = append(uncommented, line)
		}
	}

	tomlContent := strings.Join(uncommented, "\n")

	var cfg Config
	if _, err := toml.Decode(tomlContent, &cfg); err != nil {
		t.Fatalf("Uncommented default config template is not valid TOML: %v\nContent:\n%s", err, tomlContent)
	}
}
```

Note: The `TestDefaultConfigTemplateParsesWhenUncommented` test will need `"github.com/BurntSushi/toml"` added to the test file imports. The test file currently only imports `"os"`, `"path/filepath"`, `"strings"`, and `"testing"`.

### 3. Impact on Existing Tests

The existing `TestDefaultValues` and `TestMissingFileHandling` tests currently set HOME to an empty temp directory and expect `Load()` to succeed. After this change, `Load()` will also create the default config file in those temp directories. This is fine because:

- The created file has all options commented out, so it behaves identically to no config file
- The tests verify config values, not file existence
- The `TestMissingFileHandling` test with the case `"no config files - no error"` will now have a side effect of creating the file, but the test assertion (no error returned) still passes

However, there is one subtle concern: `TestLoadPrecedence` test case `"empty when no config files"` will now have the file created after the first Load call. If that test calls Load multiple times within the same subtest, subsequent calls would find the file. But looking at the test code, each subtest only calls `Load(nil)` once, so this is not an issue.

### 4. Edge Cases

1. **HOME environment variable not set**: `getUserConfigPath()` returns `""` when `os.UserHomeDir()` fails. In that case, `userConfigPath` is `""`, and the outer `if userConfigPath != ""` guard on line 110 prevents any config loading or file creation. No change needed here.

2. **Race condition on concurrent CLI invocations**: Two specstory processes could start simultaneously and both detect the file is missing. Both would try to create it. Since `os.WriteFile` is atomic at the OS level for small files, one will win and the other will overwrite with identical content. This is harmless.

3. **Disk full or other I/O errors**: `ensureDefaultUserConfig` catches all errors from `os.MkdirAll` and `os.WriteFile` and logs them at Debug level. The CLI continues normally.

4. **`~/.specstory/` directory exists but config file does not**: `os.MkdirAll` is a no-op when the directory already exists. The file will be created. This is the expected behavior.

5. **Idempotency**: The function is only called inside the `os.IsNotExist` branch of `loadTOMLFile`. If the file exists (even if it was just created on a previous run), `loadTOMLFile` succeeds and the `os.IsNotExist` branch is never entered. So the function is never called when the file already exists. This is inherently idempotent.

6. **Template maintenance**: When new config options are added to the `Config` struct, the developer must also update `defaultConfigTemplate`. This is a manual step. The `TestDefaultConfigTemplateParsesWhenUncommented` test helps catch syntax errors in the template, but it does not enforce that all struct fields are represented. A comment above the const should note this responsibility.

### 5. Summary of Changes

| File | Change |
|------|--------|
| `pkg/config/config.go` | Add `defaultConfigTemplate` const (~45 lines) |
| `pkg/config/config.go` | Add `ensureDefaultUserConfig()` function (~18 lines) |
| `pkg/config/config.go` | Add one line to `Load()` calling `ensureDefaultUserConfig` |
| `pkg/config/config_test.go` | Add `TestEnsureDefaultUserConfig` (~100 lines) |
| `pkg/config/config_test.go` | Add `TestDefaultConfigTemplateParsesWhenUncommented` (~25 lines) |
| `pkg/config/config_test.go` | Add `toml` import |

Total: approximately 190 lines of new code (including comments and tests).

No new files are needed. No new dependencies are needed (the `toml` import in the test file uses the already-imported `github.com/BurntSushi/toml` package).

### Critical Files for Implementation

- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config.go` - Primary file to modify: add template const, creation function, and one-line call in Load()
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/config/config_test.go` - Add tests for the new behavior including creation, idempotency, graceful failure, and template validity
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/pkg/analytics/shared_id.go` - Reference pattern for creating files in user home directory with proper error handling
- `/Users/sean/Source/SpecStory/getspecstory/specstory-cli/main.go` - Context for understanding where Load() is called and how config flows through the application (no changes needed here)

_**Agent (claude-opus-4-6 2026-02-22 15:22:41Z)**_



Excellent analysis. Let me write the final plan.

_**Agent (claude-opus-4-6 2026-02-22 15:23:06Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# Plan: Auto-Create Default User Config File

## Context

The CLI has an optional TOML config file (`~/.specstory/cli-config.toml`) but nobody discovers it exists. To fix this, when `Load()` detects the user-level config is missing, it creates a default file with all options commented out — a self-documenting reference that users can find and edit.

## Changes

All changes are in `pkg/config/config.go` and `pkg/config/config_test.go`. No new files.

### 1. Add `defaultConfigTemplate` const (config.go, after line 25)

A const string containing the full commented-out TOML template. Every option is prefixed with `#` so the file has zero effect when created. Each option includes a description and its default value.

\```toml
# SpecStory CLI Configuration
#
# This is the user-level config file for SpecStory CLI.
# All settings here apply to every project unless overridden by a
# project-level config at ./.specstory/cli-config.toml or CLI flags.
#
# Uncomment and edit any setting below to change the default behavior.
# For more information, see: https://github.com/specstoryai/specstory

# Custom output directory for markdown and debug files.
# Default: .specstory (relative to the project directory)
# output_dir = ""

# [version_check]
# Check for newer versions of the CLI on startup.
# Default: true
# enabled = true

# [cloud_sync]
# Sync session data to SpecStory Cloud.
# Default: true
# enabled = true

# [local_sync]
# Write markdown files locally.
# When false, only cloud sync is performed (equivalent to --only-cloud-sync).
# Default: true
# enabled = true

# [logging]
# console = false    # Error/warn/info output to stdout (default: false)
# log = false        # Write logs to .specstory/debug/debug.log (default: false)
# debug = false      # Debug-level output, requires console or log (default: false)
# silent = false     # Suppress all non-error output (default: false)

# [analytics]
# Send anonymous usage analytics to help improve SpecStory.
# Default: true
# enabled = true
\```

### 2. Add `ensureDefaultUserConfig(path string)` function (config.go, after `getUserConfigPath`)

- Creates `~/.specstory/` directory with `os.MkdirAll` if needed
- Writes `defaultConfigTemplate` to the path with `os.WriteFile`
- All failures logged at `slog.Debug` level and silently ignored — the CLI works fine without the file

### 3. One-line change in `Load()` (config.go, line 113)

In the existing `os.IsNotExist` branch for the user config, add a call to `ensureDefaultUserConfig(userConfigPath)` right after the existing debug log line. This is the natural place — we already know the file doesn't exist and have the path.

\```go
if os.IsNotExist(err) {
    slog.Debug("No user-level config file found", "path", userConfigPath)
    ensureDefaultUserConfig(userConfigPath)  // <-- new line
} else {
\```

### 4. Tests (config_test.go)

- **Creates file when none exists** — verify file is created at `~/.specstory/cli-config.toml` with content matching the template, and config values are all defaults
- **Does not overwrite existing file** — create a config with custom values, call Load, verify original content preserved
- **Handles unwritable directory gracefully** — read-only `~/.specstory/` dir, verify Load succeeds without error
- **Created file is loadable on subsequent calls** — first Load creates it, second Load reads it without error, all defaults still correct
- **Template is valid TOML when uncommented** — strip `#` prefixes, parse with `toml.Decode`, verify no syntax errors (guards against template rot)

Add `"github.com/BurntSushi/toml"` to test imports for the template validity test.

### Why existing tests are unaffected

The created file has everything commented out, so it behaves identically to no file. Existing tests that use empty temp HOME directories will now have the file created as a side effect, but their assertions (on config values, not file existence) remain valid.

## Verification

1. `go test -v ./pkg/config` — all existing + new tests pass
2. `golangci-lint run` — no lint issues
3. Manual: delete `~/.specstory/cli-config.toml`, run `./specstory sync`, verify the file is created with commented-out content
4. Manual: run `./specstory sync` again, verify the file is not overwritten

```

```text
File created successfully at: /Users/sean/.claude/plans/goofy-conjuring-wombat.md
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:23:10Z)**_

Minimal, surgical change — two additions to `config.go` (a const template + a small helper function) and one new line in `Load()`. No new files, no new dependencies, no changes to `main.go`.

_**Agent (claude-opus-4-6 2026-02-22 15:44:59Z)**_

<tool-use data-tool-type="generic" data-tool-name="ExitPlanMode"><details>
<summary>Tool use: **ExitPlanMode**</summary>

```text
The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.
```
</details></tool-use>

---

_**User (2026-02-22 15:44:59Z)**_

[Request interrupted by user for tool use]

_**User (2026-02-22 15:46:04Z)**_

so... config file was supposed to be in `~/.specstory/cli/config.toml`, not `~/.specstory/cli-config.toml`

If this is not the case, we need to update that.

Same thing at the project level.

---

_**Agent (claude-opus-4-6 2026-02-22 15:46:07Z)**_



Let me check what the code actually has.

_**Agent (claude-opus-4-6 2026-02-22 15:46:08Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./pkg/config` pattern `ConfigFileName|SpecStoryDir|cli-config|config\.toml`

```text
pkg/config/config.go:4://  2. Local project config: .specstory/cli-config.toml
pkg/config/config.go:5://  3. User-level config: ~/.specstory/cli-config.toml
pkg/config/config.go:21:	// ConfigFileName is the name of the configuration file
pkg/config/config.go:22:	ConfigFileName = "cli-config.toml"
pkg/config/config.go:23:	// SpecStoryDir is the directory name for SpecStory files
pkg/config/config.go:24:	SpecStoryDir = ".specstory"
pkg/config/config.go:146:// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
pkg/config/config.go:153:	return filepath.Join(home, SpecStoryDir, ConfigFileName)
pkg/config/config.go:156:// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
pkg/config/config.go:163:	return filepath.Join(cwd, SpecStoryDir, ConfigFileName)
pkg/config/config_test.go:13:	specstoryDir := filepath.Join(dir, SpecStoryDir)
pkg/config/config_test.go:17:	configPath := filepath.Join(specstoryDir, ConfigFileName)
pkg/config/config_test.go:477:				userSpecstoryDir := filepath.Join(tempHome, SpecStoryDir)
pkg/config/config_test.go:482:					configPath := filepath.Join(userSpecstoryDir, ConfigFileName)
pkg/config/config_test.go:490:				projSpecstoryDir := filepath.Join(tempProject, SpecStoryDir)
pkg/config/config_test.go:495:					configPath := filepath.Join(projSpecstoryDir, ConfigFileName)
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:46:09Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `cli-config|config\.toml|\.specstory/cli`

```text
<persisted-output>
Output too large (20.4KB). Full output saved to: /Users/sean/.claude/projects/-Users-sean-Source-SpecStory-getspecstory-specstory-cli/ca840fc9-f560-413f-acd5-249e54d818a6/tool-results/toolu_01WhJW2c1q3ikyxF92RmEzRm.txt

Preview (first 2KB):
README.md:86:1. **User-level config**: `~/.specstory/cli-config.toml` - applies to all projects
README.md:87:2. **Project-level config**: `.specstory/cli-config.toml` - applies only to the current project
README.md:91:2. Project-level config (`.specstory/cli-config.toml`)
README.md:92:3. User-level config (`~/.specstory/cli-config.toml`)
docs/CLOUD-AUTH.md:78:The cloud auth file is stored in `~/.specstory/cli/auth.json` with 0600 permissions, and is used to store the cloud refresh and access tokens.
.specstory/history/2026-02-20_21-04-48Z-recent-cursor-cli-session.md:2769:    30→time=2026-02-20T16:00:29.909-05:00 level=INFO msg="Checking authentication" path=/Users/sean/.specstory/cli/auth.json
.specstory/history/2026-02-20_21-04-48Z-recent-cursor-cli-session.md:3078:   263→time=2026-02-20T16:01:05.718-05:00 level=DEBUG msg="Updated auth.json" path=/Users/sean/.specstory/cli/auth.json
.specstory/history/2026-02-20_21-04-48Z-recent-cursor-cli-session.md:3155:   340→time=2026-02-20T16:01:09.921-05:00 level=INFO msg="Checking authentication" path=/Users/sean/.specstory/cli/auth.json
.specstory/history/2026-02-20_21-04-48Z-recent-cursor-cli-session.md:10383:    31→time=2026-02-20T16:00:29.909-05:00 level=INFO msg="Checking authentication" path=/Users/sean/.specstory/cli/auth.json
.specstory/history/2026-02-20_21-04-48Z-recent-cursor-cli-session.md:10786:   263→time=2026-02-20T16:01:05.718-05:00 level=DEBUG msg="Updated auth.json" path=/Users/sean/.specstory/cli/auth.json
.specstory/history/2026-02-20_21-04-48Z-recent-cursor-cli-session.md:10863:   340→time=2026-02-20T16:01:09.921-05:00 level=INFO msg="Checking authentication" path=/Users/sean/.specstory/cli/auth.json
.specstory/history/2026-01-28_13-36-04Z-command-name-pr-review.md:13903:[Omitted long matching line]
.specstory/history/2026-01-28_13-36-04Z-command-name-pr-review.md:14090:- Authentication persistence to ~/.specstory/cli/auth.json
...
</persisted-output>
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:46:14Z)**_

<think><details><summary>Thought Process</summary>
So the current code has:
- `~/.specstory/cli-config.toml` (user-level)
- `.specstory/cli-config.toml` (project-level)

But the user wants:
- `~/.specstory/cli/config.toml` (user-level)
- `.specstory/cli/config.toml` (project-level)

I notice that `auth.json` is already at `~/.specstory/cli/auth.json` — so there's a `cli` subdirectory pattern already in use. The config file should follow the same pattern.


Let me check what other files are currently stored in the `~/.specstory/cli/` directory to understand the full structure.
</details></think>

_**Agent (claude-opus-4-6 2026-02-22 15:46:16Z)**_

You're right — the auth file already lives at `~/.specstory/cli/auth.json`, so the convention is a `cli` subdirectory. But the config code currently uses `~/.specstory/cli-config.toml` (flat, no subdirectory).

Current code:
- User-level: `~/.specstory/cli-config.toml`
- Project-level: `.specstory/cli-config.toml`

Your intent:
- User-level: `~/.specstory/cli/config.toml`
- Project-level: `.specstory/cli/config.toml`

Let me check what else lives under `~/.specstory/cli/` to confirm the pattern.

_**Agent (claude-opus-4-6 2026-02-22 15:46:18Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `\.specstory/cli/`

```text
No matches found
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:46:21Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `specstory/cli|CLIDir|auth\.json`

```text
pkg/cloud/auth.go:39:// CloudRefreshData represents the refresh token portion of auth.json
pkg/cloud/auth.go:48:// CloudAccessData represents the access token portion of auth.json
pkg/cloud/auth.go:55:// AuthData represents the structure of the auth.json file
pkg/cloud/auth.go:659:// Logout removes the authentication by deleting the auth.json file
pkg/cloud/auth.go:756:// readAuthData reads and parses the auth.json file
pkg/cloud/auth.go:771:// writeAuthData writes the auth data to auth.json
pkg/cloud/auth.go:791:	slog.Debug("Updated auth.json", "path", authPath)
pkg/cloud/auth_test.go:26:	// Create the .specstory/cli directory structure
pkg/cloud/auth_test.go:28:	authPath := filepath.Join(authDir, "auth.json")
pkg/cloud/auth_test.go:45:			description:    "Should return false when auth.json doesn't exist",
pkg/cloud/auth_test.go:68:			description:    "Should return true when auth.json exists with valid cloud token",
pkg/cloud/auth_test.go:105:			description:    "Should return false when auth.json is not valid JSON",
pkg/cloud/auth_test.go:255:			description:    "Should return false when auth.json is a directory",
pkg/cloud/auth_test.go:283:			description:    "Should return false when auth.json cannot be read",
pkg/cloud/auth_test.go:380:	// Create the .specstory/cli directory structure
pkg/cloud/auth_test.go:382:	authPath := filepath.Join(authDir, "auth.json")
pkg/config/config.go:4://  2. Local project config: .specstory/cli-config.toml
pkg/config/config.go:5://  3. User-level config: ~/.specstory/cli-config.toml
pkg/config/config.go:146:// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
pkg/config/config.go:156:// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
pkg/utils/path_utils.go:142:// GetAuthPath returns the path to the auth.json file
pkg/utils/path_utils.go:148:	return filepath.Join(homeDir, ".specstory", "cli", "auth.json"), nil
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:46:25Z)**_

Confirmed. `path_utils.go:148` already uses `~/.specstory/cli/auth.json` — so the `cli` subdirectory convention exists.

The config file paths need to be updated to match:
- `~/.specstory/cli-config.toml` → `~/.specstory/cli/config.toml`
- `.specstory/cli-config.toml` → `.specstory/cli/config.toml`

_**Agent (claude-opus-4-6 2026-02-22 15:57:01Z)**_

<tool-use data-tool-type="generic" data-tool-name="AskUserQuestion"><details>
<summary>Tool use: **AskUserQuestion**</summary>
**Should I fold the config path fix into the same plan as the auto-create feature, or would you prefer it as a separate step?**

Options:
- **Combined** - Fix the paths and add auto-create in one plan — they're tightly related
- **Separate steps** - Fix paths first, then add auto-create as a follow-up


**Answer:** Combined
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:57:03Z)**_

Let me check all the places that reference the old config path so the plan covers everything.

_**Agent (claude-opus-4-6 2026-02-22 15:57:05Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `cli-config\.toml`

```text
README.md:86:1. **User-level config**: `~/.specstory/cli-config.toml` - applies to all projects
README.md:87:2. **Project-level config**: `.specstory/cli-config.toml` - applies only to the current project
README.md:91:2. Project-level config (`.specstory/cli-config.toml`)
README.md:92:3. User-level config (`~/.specstory/cli-config.toml`)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:77:2. **Local project config** - `.specstory/cli-config.toml` (in current working directory)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:78:3. **User-level config** - `~/.specstory/cli-config.toml` (in home directory)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:99:- `ConfigFileName = "cli-config.toml"` (line 22)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:101:So the full path becomes: `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:103:The local project config path (from `getLocalConfigPath()`, lines 156-164) is: `.specstory/cli-config.toml` in the current working directory.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:281:  1. User-level: `~/.specstory/cli-config.toml` (lowest priority)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:282:  2. Local project: `.specstory/cli-config.toml` (overwrites user config)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:317:    userConfigPath := getUserConfigPath()  // ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:320:    localConfigPath := getLocalConfigPath()  // .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:400:- User-level: `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:401:- Project-level: `.specstory/cli-config.toml` (relative to current working directory)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:417:- Check if `.specstory/cli-config.toml` exists after loading attempts
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:457:     4→//  2. Local project config: .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:458:     5→//  3. User-level config: ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:475:    22→	ConfigFileName = "cli-config.toml"
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:599:   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:609:   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:2885:     4→//  2. Local project config: .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:2886:     5→//  3. User-level config: ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:2903:    22→	ConfigFileName = "cli-config.toml"
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:3027:   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:3037:   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5353:    86→1. **User-level config**: `~/.specstory/cli-config.toml` - applies to all projects
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5354:    87→2. **Project-level config**: `.specstory/cli-config.toml` - applies only to the current project
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5358:    91→2. Project-level config (`.specstory/cli-config.toml`)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5359:    92→3. User-level config (`~/.specstory/cli-config.toml`)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5739:  1. User-level: `~/.specstory/cli-config.toml` (lowest priority)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5740:  2. Local project: `.specstory/cli-config.toml` (overwrites user config)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5775:    userConfigPath := getUserConfigPath()  // ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5778:    localConfigPath := getLocalConfigPath()  // .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5858:- User-level: `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5859:- Project-level: `.specstory/cli-config.toml` (relative to current working directory)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5875:- Check if `.specstory/cli-config.toml` exists after loading attempts
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5939:2. **Local project config** - `.specstory/cli-config.toml` (in current working directory)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5940:3. **User-level config** - `~/.specstory/cli-config.toml` (in home directory)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5961:- `ConfigFileName = "cli-config.toml"` (line 22)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5963:So the full path becomes: `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:5965:The local project config path (from `getLocalConfigPath()`, lines 156-164) is: `.specstory/cli-config.toml` in the current working directory.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:6074:     4→//  2. Local project config: .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:6075:     5→//  3. User-level config: ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:6092:    22→	ConfigFileName = "cli-config.toml"
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:6216:   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:6226:   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7024:1. At startup (any command), check if the `~/.specstory/cli-config.toml` file exists
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7052:## Implementation Plan: Auto-Create Default `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7056:When the `Load()` function detects that `~/.specstory/cli-config.toml` does not exist, it should create a default file with all options commented out. This serves as a discoverability mechanism so users know the config file exists and what options are available.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7072:// ~/.specstory/cli-config.toml when no user-level config file exists.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7078:# project-level config at ./.specstory/cli-config.toml or CLI flags.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7213:1. **Creates file when directory and file do not exist** -- Set HOME to an empty temp dir. Call `Load(nil)`. Verify `~/.specstory/cli-config.toml` now exists. Verify the content matches `defaultConfigTemplate`. Verify the returned config is still a zero-value config (since everything is commented out).
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7215:2. **Does not overwrite existing file** -- Create a temp HOME with an existing `~/.specstory/cli-config.toml` containing `output_dir = "/custom"`. Call `Load(nil)`. Verify the file still contains the original content. Verify `cfg.GetOutputDir()` returns `/custom`.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7443:Design an implementation plan for auto-creating a default `~/.specstory/cli-config.toml` config file when one doesn't exist.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7447:The SpecStory CLI has a TOML config system in `pkg/config/config.go`. Config is loaded with priority: CLI flags > local project config (`./specstory/cli-config.toml`) > user-level config (`~/.specstory/cli-config.toml`). All config files are optional.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7495:1. When `~/.specstory/cli-config.toml` doesn't exist, create it with all options present but commented out
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7530:     4→//  2. Local project config: .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7531:     5→//  3. User-level config: ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7548:    22→	ConfigFileName = "cli-config.toml"
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7672:   146→// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:7682:   156→// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10178:## Implementation Plan: Auto-Create Default `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10182:When the `Load()` function detects that `~/.specstory/cli-config.toml` does not exist, it should create a default file with all options commented out. This serves as a discoverability mechanism so users know the config file exists and what options are available.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10198:// ~/.specstory/cli-config.toml when no user-level config file exists.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10204:# project-level config at ./.specstory/cli-config.toml or CLI flags.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10339:1. **Creates file when directory and file do not exist** -- Set HOME to an empty temp dir. Call `Load(nil)`. Verify `~/.specstory/cli-config.toml` now exists. Verify the content matches `defaultConfigTemplate`. Verify the returned config is still a zero-value config (since everything is commented out).
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10341:2. **Does not overwrite existing file** -- Create a temp HOME with an existing `~/.specstory/cli-config.toml` containing `output_dir = "/custom"`. Call `Load(nil)`. Verify the file still contains the original content. Verify `cfg.GetOutputDir()` returns `/custom`.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10577:The CLI has an optional TOML config file (`~/.specstory/cli-config.toml`) but nobody discovers it exists. To fix this, when `Load()` detects the user-level config is missing, it creates a default file with all options commented out — a self-documenting reference that users can find and edit.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10592:# project-level config at ./.specstory/cli-config.toml or CLI flags.
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10648:- **Creates file when none exists** — verify file is created at `~/.specstory/cli-config.toml` with content matching the template, and config values are all defaults
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10664:3. Manual: delete `~/.specstory/cli-config.toml`, run `./specstory sync`, verify the file is created with commented-out content
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10696:so... config file was supposed to be in `~/.specstory/cli/config.toml`, not `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10717:pkg/config/config.go:4://  2. Local project config: .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10718:pkg/config/config.go:5://  3. User-level config: ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10720:pkg/config/config.go:22:	ConfigFileName = "cli-config.toml"
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10723:pkg/config/config.go:146:// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10725:pkg/config/config.go:156:// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10747:README.md:86:1. **User-level config**: `~/.specstory/cli-config.toml` - applies to all projects
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10748:README.md:87:2. **Project-level config**: `.specstory/cli-config.toml` - applies only to the current project
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10749:README.md:91:2. Project-level config (`.specstory/cli-config.toml`)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10750:README.md:92:3. User-level config (`~/.specstory/cli-config.toml`)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10769:- `~/.specstory/cli-config.toml` (user-level)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10770:- `.specstory/cli-config.toml` (project-level)
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10784:You're right — the auth file already lives at `~/.specstory/cli/auth.json`, so the convention is a `cli` subdirectory. But the config code currently uses `~/.specstory/cli-config.toml` (flat, no subdirectory).
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10787:- User-level: `~/.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10788:- Project-level: `.specstory/cli-config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10830:pkg/config/config.go:4://  2. Local project config: .specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10831:pkg/config/config.go:5://  3. User-level config: ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10832:pkg/config/config.go:146:// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10833:pkg/config/config.go:156:// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10844:- `~/.specstory/cli-config.toml` → `~/.specstory/cli/config.toml`
.specstory/history/2026-02-22_15-19-19Z-this-branch-adds-an.md:10845:- `.specstory/cli-config.toml` → `.specstory/cli/config.toml`
pkg/config/config.go:4://  2. Local project config: .specstory/cli-config.toml
pkg/config/config.go:5://  3. User-level config: ~/.specstory/cli-config.toml
pkg/config/config.go:22:	ConfigFileName = "cli-config.toml"
pkg/config/config.go:146:// getUserConfigPath returns the path to ~/.specstory/cli-config.toml
pkg/config/config.go:156:// getLocalConfigPath returns the path to .specstory/cli-config.toml in the current directory
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:57:17Z)**_

<think><details><summary>Thought Process</summary>
Good. So the files that need updating (excluding .specstory/history) are:

1. `pkg/config/config.go` — constants and path functions
2. `README.md` — documentation references
3. `pkg/config/config_test.go` — test helper creates files at old paths

The config_test.go helper `createTempConfigFile` uses `SpecStoryDir` and `ConfigFileName` constants, so it will automatically adapt when we change those constants. But the directory structure needs to change — currently it's `dir/.specstory/cli-config.toml`, but it needs to be `dir/.specstory/cli/config.toml`.
 
I'm looking at how the paths are currently constructed versus what they need to be. The user and local config paths both need to shift from having the filename at the root of `.specstory/` to being nested under a `cli/` subdirectory. I could either embed the subdirectory into the `ConfigFileName` constant itself, or adjust how the paths are joined together.

The cleaner approach is to introduce a `CLIDir` constant set to `"cli"` and update the path joins to include it as a separate component, keeping `ConfigFileName` as just `"config.toml"`. This means I'll also need to update the test helper that creates temporary config files to account for this new directory level in the path structure.
</details></think>

_**Agent (claude-opus-4-6 2026-02-22 15:57:17Z)**_

Good — the files that need path updates (excluding `.specstory/history/`) are:

1. **`pkg/config/config.go`** — constants, path functions, comments
2. **`pkg/config/config_test.go`** — `createTempConfigFile` helper builds paths from the constants
3. **`README.md`** — documentation references (4 occurrences)

Now let me update the plan to include both changes.

_**Agent (claude-opus-4-6 2026-02-22 15:57:49Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# Plan: Fix Config Paths + Auto-Create Default User Config

## Context

Two related issues:

1. **Path mismatch**: The config file lives at `~/.specstory/cli-config.toml` but should be at `~/.specstory/cli/config.toml` to match the existing convention (`~/.specstory/cli/auth.json` in `pkg/utils/path_utils.go:148`). Same fix needed at the project level: `.specstory/cli-config.toml` → `.specstory/cli/config.toml`.

2. **Discoverability**: Nobody discovers the config file. When the user-level config doesn't exist, auto-create a default with everything commented out.

## Part 1: Fix Config File Paths

### `pkg/config/config.go`

Change the constants (lines 20-25):

\```go
// Before
ConfigFileName = "cli-config.toml"
SpecStoryDir   = ".specstory"

// After
ConfigFileName = "config.toml"
SpecStoryDir   = ".specstory"
CLIDir         = "cli"
\```

Update `getUserConfigPath()` (line 153):
\```go
// Before
return filepath.Join(home, SpecStoryDir, ConfigFileName)
// After
return filepath.Join(home, SpecStoryDir, CLIDir, ConfigFileName)
\```

Update `getLocalConfigPath()` (line 163):
\```go
// Before
return filepath.Join(cwd, SpecStoryDir, ConfigFileName)
// After
return filepath.Join(cwd, SpecStoryDir, CLIDir, ConfigFileName)
\```

Update comments at top of file (lines 4-5) and on the two path functions (lines 146, 156).

### `pkg/config/config_test.go`

Update `createTempConfigFile` helper — the dir structure changes from `dir/.specstory/cli-config.toml` to `dir/.specstory/cli/config.toml`:

\```go
func createTempConfigFile(t *testing.T, dir, content string) string {
    t.Helper()
    configDir := filepath.Join(dir, SpecStoryDir, CLIDir)
    if err := os.MkdirAll(configDir, 0755); err != nil {
        t.Fatalf("Failed to create config dir: %v", err)
    }
    configPath := filepath.Join(configDir, ConfigFileName)
    // ...
}
\```

Also update `TestMissingFileHandling` which manually constructs paths using `SpecStoryDir` — add `CLIDir` to those joins.

### `README.md`

Update the 4 references (lines 86, 87, 91, 92):
- `~/.specstory/cli-config.toml` → `~/.specstory/cli/config.toml`
- `.specstory/cli-config.toml` → `.specstory/cli/config.toml`

## Part 2: Auto-Create Default Config

### Add `defaultConfigTemplate` const (`config.go`, after the constants block)

All options commented out with descriptions and defaults:

\```toml
# SpecStory CLI Configuration
#
# This is the user-level config file for SpecStory CLI.
# All settings here apply to every project unless overridden by a
# project-level config at .specstory/cli/config.toml or CLI flags.
#
# Uncomment and edit any setting below to change the default behavior.
# For more information, see: https://github.com/specstoryai/specstory

# Custom output directory for markdown and debug files.
# Default: .specstory (relative to the project directory)
# output_dir = ""

# [version_check]
# Check for newer versions of the CLI on startup.
# Default: true
# enabled = true

# [cloud_sync]
# Sync session data to SpecStory Cloud.
# Default: true
# enabled = true

# [local_sync]
# Write markdown files locally.
# When false, only cloud sync is performed (equivalent to --only-cloud-sync).
# Default: true
# enabled = true

# [logging]
# console = false    # Error/warn/info output to stdout (default: false)
# log = false        # Write logs to .specstory/debug/debug.log (default: false)
# debug = false      # Debug-level output, requires console or log (default: false)
# silent = false     # Suppress all non-error output (default: false)

# [analytics]
# Send anonymous usage analytics to help improve SpecStory.
# Default: true
# enabled = true
\```

### Add `ensureDefaultUserConfig(path string)` function (`config.go`)

- Creates directory with `os.MkdirAll` (handles `~/.specstory/cli/` not existing)
- Writes the template with `os.WriteFile`
- All failures logged at `slog.Debug` and silently ignored — non-fatal

### One-line addition in `Load()` (line 113, the `os.IsNotExist` branch)

\```go
if os.IsNotExist(err) {
    slog.Debug("No user-level config file found", "path", userConfigPath)
    ensureDefaultUserConfig(userConfigPath)  // new line
} else {
\```

## Tests (`config_test.go`)

### New: `TestEnsureDefaultUserConfig`

- **Creates file when none exists** — verify file created at correct path, content matches template, config values all defaults
- **Does not overwrite existing file** — existing config preserved, values loaded correctly
- **Handles unwritable directory gracefully** — Load succeeds, no file created
- **Created file is loadable on subsequent calls** — second Load succeeds, defaults unchanged

### New: `TestDefaultConfigTemplateParsesWhenUncommented`

Strip `#` prefixes, parse with `toml.Decode`, verify valid TOML. Guards against template syntax rot. Requires adding `"github.com/BurntSushi/toml"` to test imports.

### Existing tests

Unaffected — they use the constants (`SpecStoryDir`, `ConfigFileName`) which will now resolve to the new paths. The `createTempConfigFile` helper update handles the directory structure change.

## Files Modified

| File | What changes |
|------|-------------|
| `pkg/config/config.go` | Fix constants, path functions, add template const, add `ensureDefaultUserConfig`, one-line call in `Load()` |
| `pkg/config/config_test.go` | Fix `createTempConfigFile` helper, fix `TestMissingFileHandling` path construction, add new tests, add toml import |
| `README.md` | Update 4 config path references |

## Verification

1. `go test -v ./pkg/config` — all existing + new tests pass
2. `golangci-lint run` — no lint issues
3. Manual: delete `~/.specstory/cli/config.toml`, run `./specstory sync`, verify file created with commented-out content
4. Manual: run again, verify file not overwritten

```

```text
The file /Users/sean/.claude/plans/goofy-conjuring-wombat.md has been overwritten successfully.
```
</details></tool-use>

_**Agent (claude-opus-4-6 2026-02-22 15:59:39Z)**_

<tool-use data-tool-type="generic" data-tool-name="ExitPlanMode"><details>
<summary>Tool use: **ExitPlanMode**</summary>

```text
The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.
```
</details></tool-use>

---

_**User (2026-02-22 15:59:39Z)**_

[Request interrupted by user for tool use]
