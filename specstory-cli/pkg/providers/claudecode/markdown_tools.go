package claudecode

import (
	"fmt"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
)

// Todo status constants
const (
	TodoStatusPending    = "pending"
	TodoStatusInProgress = "in_progress"
	TodoStatusCompleted  = "completed"
)

// Todo priority constants
const (
	TodoPriorityHigh   = "high"
	TodoPriorityMedium = "medium"
	TodoPriorityLow    = "low"
)

// Todo priority emojis
const (
	TodoPriorityHighEmoji   = "üî•"
	TodoPriorityMediumEmoji = "üå°Ô∏è"
	TodoPriorityLowEmoji    = "‚ùÑÔ∏è"
)

// Tool name constants
const (
	ToolNameTodoWrite = "TodoWrite"
)

// Special content markers
const (
	AgentTaskListMarker     = "Agent task list:"
	TodoWriteSuccessMessage = "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
)

// File header comment
const GeneratedBySpecStory = "<!-- Generated by SpecStory, Markdown v2.1.0 -->"

// toolFormatter is a function that formats tool use content for markdown
type toolFormatter func(toolName string, input map[string]interface{}, description string) string

// toolFormatters is a registry of tool-specific formatters
var toolFormatters = map[string]toolFormatter{
	"Bash":            formatBashTool,
	"Write":           formatWriteTool,
	"Read":            formatReadTool,
	"Grep":            formatGrepTool,
	"Glob":            formatGrepTool,
	"MultiEdit":       formatMultiEditTool,
	"TodoWrite":       formatTodoWriteTool,
	"AskUserQuestion": formatAskUserQuestionTool,
}

// Pre-compiled regular expressions for performance
var (
	// ansiRegex matches ANSI escape sequences like [0m, [31m, [1;31m, etc.
	ansiRegex = regexp.MustCompile(`\x1b\[[0-9;]*m`)

	// systemReminderRegex matches <system-reminder>...</system-reminder> tags with content
	systemReminderRegex = regexp.MustCompile(`(?s)<system-reminder>.*?</system-reminder>`)
)

// makeRelativePath converts an absolute path to relative if it's within the cwd
func makeRelativePath(absolutePath, cwd string) string {
	if cwd == "" {
		return absolutePath
	}

	// Normalize paths
	normalizedPath := filepath.Clean(absolutePath)
	normalizedCwd := filepath.Clean(cwd)

	// On macOS, filesystem is case-insensitive by default, so use case-insensitive comparison
	// On Linux and other OSes, use case-sensitive comparison
	var hasPrefix bool
	if runtime.GOOS == "darwin" {
		// Case-insensitive comparison for macOS
		hasPrefix = strings.HasPrefix(strings.ToLower(normalizedPath), strings.ToLower(normalizedCwd))
	} else {
		// Case-sensitive comparison for other OSes
		hasPrefix = strings.HasPrefix(normalizedPath, normalizedCwd)
	}

	if hasPrefix {
		// Use the original normalized path lengths to trim (preserving original case)
		relativePath := normalizedPath[len(normalizedCwd):]
		if !strings.HasPrefix(relativePath, "/") {
			relativePath = "/" + relativePath
		}
		return "." + relativePath
	}

	return absolutePath
}

// getLanguageFromExtension returns the language identifier for syntax highlighting based on file extension
func getLanguageFromExtension(filePath string) string {
	if filePath == "" {
		return ""
	}

	ext := strings.TrimPrefix(filepath.Ext(filePath), ".")

	// Map common extensions to language identifiers
	switch ext {
	case "js":
		return "javascript"
	case "ts":
		return "typescript"
	case "py":
		return "python"
	case "rb":
		return "ruby"
	case "yml":
		return "yaml"
	default:
		// Common extensions that don't need mapping: go, java, c, cpp, json, xml, sh, etc.
		return ext
	}
}

// formatBashTool formats Bash tool usage with command on a new line in backticks
func formatBashTool(toolName string, input map[string]interface{}, description string) string {
	var result strings.Builder

	// Add description with blank line separator if provided
	if description != "" {
		result.WriteString(description)
		result.WriteString("\n")
	}

	// Add command on new line in backticks
	if input != nil {
		if command, ok := input["command"].(string); ok && command != "" {
			// If command includes \n we wrap it in a code block
			if strings.Contains(command, "\n") {
				escapedCommand := strings.ReplaceAll(command, "```", "\\```")
				result.WriteString(fmt.Sprintf("\n```bash\n%s\n```", escapedCommand))
			} else {
				result.WriteString(fmt.Sprintf("\n`%s`", command))
			}
		}
	}

	return result.String()
}

// formatWriteTool formats Write tool usage with file content in triple backticks
func formatWriteTool(toolName string, input map[string]interface{}, description string) string {
	var result strings.Builder

	// Add description with blank line separator if provided
	if description != "" {
		result.WriteString(description)
		result.WriteString("\n")
	}

	// Add file content in triple backticks with language hint
	if input != nil {
		if content, ok := input["content"].(string); ok {
			filePath, _ := input["file_path"].(string)

			// Get language for syntax highlighting
			lang := getLanguageFromExtension(filePath)

			// Escape triple backticks in content
			escapedContent := strings.ReplaceAll(content, "```", "\\```")

			result.WriteString(fmt.Sprintf("\n```%s\n%s\n```", lang, escapedContent))
		}
	}

	return result.String()
}

// formatReadTool formats Read tool usage with file path in backticks
func formatReadTool(toolName string, input map[string]interface{}, description string) string {
	var content string

	// Add file path in backticks
	if input != nil {
		if filePath, ok := input["file_path"].(string); ok && filePath != "" {
			// Check if we have cwd for relative path conversion
			cwd, _ := input["_cwd"].(string)
			relativePath := makeRelativePath(filePath, cwd)
			content += fmt.Sprintf(" `%s`", relativePath)
		}
	}

	// Add description if provided
	if description != "" {
		content += fmt.Sprintf(" %s", description)
	}

	return content
}

// formatGrepTool formats Grep tool usage with path and include parameters
func formatGrepTool(toolName string, input map[string]interface{}, description string) string {
	var content string

	// Add path with relative conversion if applicable
	if input != nil {
		if path, ok := input["path"].(string); ok && path != "" {
			// Check if we have cwd for relative path conversion
			cwd, _ := input["_cwd"].(string)
			relativePath := makeRelativePath(path, cwd)
			content += fmt.Sprintf(" path `%s`", relativePath)
		}

		// Sometimes the input is in pattern key instead of path key
		if pattern, ok := input["pattern"].(string); ok && pattern != "" {
			content += fmt.Sprintf(" pattern `%s`", pattern)
		}

		// Add include parameter
		if include, ok := input["include"].(string); ok && include != "" {
			content += fmt.Sprintf(" include `%s`", include)
		}
	}

	// Add description if provided
	if description != "" {
		content += fmt.Sprintf(" %s", description)
	}

	return content
}

// formatMultiEditTool formats MultiEdit tool usage with file path in backticks
func formatMultiEditTool(toolName string, input map[string]interface{}, description string) string {
	var content string

	// Add file path in backticks
	if input != nil {
		if filePath, ok := input["file_path"].(string); ok && filePath != "" {
			// Check if we have cwd for relative path conversion
			cwd, _ := input["_cwd"].(string)
			relativePath := makeRelativePath(filePath, cwd)
			content += fmt.Sprintf(" `%s`", relativePath)
		}
	}

	// Add description if provided
	if description != "" {
		content += fmt.Sprintf(" %s", description)
	}

	return content
}

// formatDefaultTool formats tools without specific formatting needs
func formatDefaultTool(toolName string, input map[string]interface{}, description string) string {
	// Return description if provided, otherwise empty string
	return description
}

// formatTodoWriteTool formats TodoWrite tool usage as a task list with checkboxes
func formatTodoWriteTool(toolName string, input map[string]interface{}, description string) string {
	if input == nil {
		return ""
	}

	todos, ok := input["todos"].([]interface{})
	if !ok || len(todos) == 0 {
		return ""
	}

	return formatTodoList(todos)
}

// formatTodoList formats a list of todos as markdown checkboxes
// Expected input: []interface{} containing maps with keys: "status", "priority", "content"
// status: "pending", "in_progress", "completed"
// priority: "high", "medium", "low"
// content: string description of the todo item
func formatTodoList(todos []interface{}) string {
	var result strings.Builder
	result.WriteString("**Agent task list:**\n")

	for _, todo := range todos {
		if todoMap, ok := todo.(map[string]interface{}); ok {
			status, ok := todoMap["status"].(string)
			if !ok {
				status = TodoStatusPending // default to pending if status is missing or invalid
			}
			priority, ok := todoMap["priority"].(string)
			if !ok {
				priority = TodoPriorityMedium // default to medium if priority is missing or invalid
			}
			content, ok := todoMap["content"].(string)
			if !ok {
				content = "" // default to empty if content is missing or invalid
			}

			// Determine checkbox state
			var checkbox string
			switch status {
			case TodoStatusPending:
				checkbox = "- [ ]"
			case TodoStatusInProgress:
				checkbox = "- [‚ö°]"
			case TodoStatusCompleted:
				checkbox = "- [X]"
			default:
				checkbox = "- [ ]"
			}

			// Determine priority emoji
			var priorityEmoji string
			switch priority {
			case TodoPriorityHigh:
				priorityEmoji = TodoPriorityHighEmoji
			case TodoPriorityMedium:
				priorityEmoji = TodoPriorityMediumEmoji
			case TodoPriorityLow:
				priorityEmoji = TodoPriorityLowEmoji
			default:
				priorityEmoji = ""
			}

			// Format the todo line
			result.WriteString(fmt.Sprintf("%s %s %s\n", checkbox, priorityEmoji, content))
		}
	}

	return result.String()
}

// formatAskUserQuestionTool formats AskUserQuestion tool usage showing the question and options
func formatAskUserQuestionTool(toolName string, input map[string]interface{}, description string) string {
	if input == nil {
		return ""
	}

	questions, ok := input["questions"].([]interface{})
	if !ok || len(questions) == 0 {
		return ""
	}

	var result strings.Builder

	for i, q := range questions {
		questionMap, ok := q.(map[string]interface{})
		if !ok {
			continue
		}

		// Extract question text
		questionText, _ := questionMap["question"].(string)
		if questionText == "" {
			continue
		}

		// Add separator between multiple questions
		if i > 0 {
			result.WriteString("\n")
		}

		// Write question with multi-select indicator if applicable
		multiSelect, _ := questionMap["multiSelect"].(bool)
		if multiSelect {
			result.WriteString(fmt.Sprintf("**%s** _(select multiple)_\n", questionText))
		} else {
			result.WriteString(fmt.Sprintf("**%s**\n", questionText))
		}

		// Extract and format options
		options, ok := questionMap["options"].([]interface{})
		if ok && len(options) > 0 {
			result.WriteString("\nOptions:\n")
			for _, opt := range options {
				optMap, ok := opt.(map[string]interface{})
				if !ok {
					continue
				}

				label, _ := optMap["label"].(string)
				desc, _ := optMap["description"].(string)

				if label != "" {
					if desc != "" {
						result.WriteString(fmt.Sprintf("- **%s** - %s\n", label, desc))
					} else {
						result.WriteString(fmt.Sprintf("- **%s**\n", label))
					}
				}
			}
		}
	}

	return result.String()
}

// parseAskUserQuestionAnswer extracts the answer(s) from the AskUserQuestion output content
// The format is: User has answered your questions: "Question"="Answer". You can now continue...
func parseAskUserQuestionAnswer(content string) string {
	// Find the answers portion between the colon and the final period sentence
	start := strings.Index(content, ": \"")
	if start == -1 {
		return ""
	}

	// Find the end - look for ". You can now continue"
	end := strings.Index(content, ". You can now continue")
	if end == -1 {
		end = len(content)
	}

	answerPart := content[start+2 : end]

	// Parse the Q="A" pairs
	// Format: "Question1"="Answer1", "Question2"="Answer2"
	var answers []string
	pairs := strings.Split(answerPart, ", \"")
	for _, pair := range pairs {
		pair = strings.TrimPrefix(pair, "\"")
		// Split on "="
		parts := strings.SplitN(pair, "\"=\"", 2)
		if len(parts) == 2 {
			answer := strings.TrimSuffix(parts[1], "\"")
			answers = append(answers, answer)
		}
	}

	if len(answers) == 0 {
		return ""
	}

	return strings.Join(answers, ", ")
}

// stripANSIEscapeSequences converts ANSI escape sequences to markdown formatting
func stripANSIEscapeSequences(s string) string {
	// First, replace bold sequences with markdown bold
	// [1m starts bold, [22m ends bold
	s = strings.ReplaceAll(s, "\x1b[1m", "**")
	s = strings.ReplaceAll(s, "\x1b[22m", "**")

	// Then remove any remaining ANSI escape sequences using pre-compiled regex
	return ansiRegex.ReplaceAllString(s, "")
}

// stripSystemReminders removes <system-reminder>...</system-reminder> tags and their content
func stripSystemReminders(s string) string {
	// Replace with empty string to remove the tags and content using pre-compiled regex
	result := systemReminderRegex.ReplaceAllString(s, "")
	// Trim only trailing whitespace to preserve leading spaces in formatted content
	return strings.TrimRight(result, " \t\n")
}
