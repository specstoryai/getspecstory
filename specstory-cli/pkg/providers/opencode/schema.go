package opencode

import (
	"fmt"
	"log/slog"
	"path/filepath"
	"strings"
	"time"

	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi"
	"github.com/specstoryai/getspecstory/specstory-cli/pkg/spi/schema"
)

// unixMillisToISO8601 converts Unix milliseconds (int64) to ISO 8601 string format.
// Returns empty string if millis is 0.
func unixMillisToISO8601(millis int64) string {
	if millis == 0 {
		return ""
	}
	t := time.UnixMilli(millis).UTC()
	return t.Format(time.RFC3339)
}

// Type aliases for convenience - use the shared schema types.
type (
	SessionData   = schema.SessionData
	ProviderInfo  = schema.ProviderInfo
	Exchange      = schema.Exchange
	SchemaMessage = schema.Message
	ContentPart   = schema.ContentPart
	ToolInfo      = schema.ToolInfo
)

// ConvertToSessionData converts an OpenCode FullSession to SpecStory's unified SessionData format.
// The providerVersion is the OpenCode version string from the Check command.
// If the session has a parent (branching/subagent), the parentID is included in SessionData.Metadata.
func ConvertToSessionData(fullSession *FullSession, providerVersion string) (*SessionData, error) {
	if fullSession == nil {
		return nil, fmt.Errorf("fullSession is nil")
	}

	if fullSession.Session == nil {
		return nil, fmt.Errorf("fullSession.Session is nil")
	}

	session := fullSession.Session

	slog.Info("ConvertToSessionData: Starting conversion",
		"sessionID", session.ID,
		"messageCount", len(fullSession.Messages),
		"hasParent", session.ParentID != nil)

	// Determine workspace root from session or project
	workspaceRoot := session.Directory
	if workspaceRoot == "" && fullSession.Project != nil {
		workspaceRoot = fullSession.Project.Worktree
	}

	// Build exchanges from messages
	exchanges, err := buildExchangesFromMessages(fullSession.Messages, workspaceRoot)
	if err != nil {
		return nil, fmt.Errorf("failed to build exchanges: %w", err)
	}

	// Assign exchangeId to each exchange (format: sessionId:index)
	for i := range exchanges {
		exchanges[i].ExchangeID = fmt.Sprintf("%s:%d", session.ID, i)
	}

	slog.Info("ConvertToSessionData: Built exchanges", "count", len(exchanges))

	// Generate slug from first user message if session doesn't have one,
	// or if the session slug is just the auto-generated ID format
	slug := session.Slug
	if slug == "" || isAutoGeneratedSlug(slug) {
		firstUserContent := GetFirstUserMessageContent(fullSession)
		if firstUserContent != "" {
			slug = spi.GenerateFilenameFromUserMessage(firstUserContent)
			slog.Debug("ConvertToSessionData: Generated slug from first user message",
				"slug", slug)
		}
	}

	// Build session metadata
	var metadata map[string]interface{}
	if session.ParentID != nil && *session.ParentID != "" {
		metadata = map[string]interface{}{
			"parentID": *session.ParentID,
		}
		slog.Debug("ConvertToSessionData: Session has parent",
			"parentID", *session.ParentID)
	}

	// Determine updatedAt from session time (use created if updated is 0)
	updatedAtMillis := session.Time.Updated
	if updatedAtMillis == 0 {
		updatedAtMillis = session.Time.Created
	}

	sessionData := &SessionData{
		SchemaVersion: "1.0",
		Provider: ProviderInfo{
			ID:      "opencode",
			Name:    "OpenCode",
			Version: providerVersion,
		},
		SessionID:     session.ID,
		CreatedAt:     unixMillisToISO8601(session.Time.Created),
		UpdatedAt:     unixMillisToISO8601(updatedAtMillis),
		Slug:          slug,
		WorkspaceRoot: workspaceRoot,
		Exchanges:     exchanges,
	}

	// Store parentID in the first exchange's metadata if we have a parent session.
	// Why: The unified SessionData schema does not have a root-level Metadata field,
	// so we preserve the parent session relationship by storing it in the first
	// exchange's metadata. This allows downstream consumers to detect branched or
	// subagent sessions by checking exchanges[0].Metadata["sessionParentID"].
	if metadata != nil && len(exchanges) > 0 {
		if exchanges[0].Metadata == nil {
			exchanges[0].Metadata = make(map[string]interface{})
		}
		exchanges[0].Metadata["sessionParentID"] = metadata["parentID"]
	}

	// Validate the converted session data and log any issues
	if !sessionData.Validate() {
		slog.Debug("ConvertToSessionData: Schema validation found issues",
			"sessionID", session.ID)
	}

	return sessionData, nil
}

// isAutoGeneratedSlug checks if a slug appears to be auto-generated (like a UUID prefix).
// OpenCode sometimes generates slugs like "ses_abc123" which aren't human-readable.
func isAutoGeneratedSlug(slug string) bool {
	// Check for common auto-generated prefixes
	if strings.HasPrefix(slug, "ses_") || strings.HasPrefix(slug, "session_") {
		return true
	}

	// Check if it looks like a hex string (common for auto-generated IDs)
	// Must be at least 8 characters and contain only hex digits
	if len(slug) >= 8 && isHexString(slug) {
		return true
	}

	// Check for UUID-like patterns (with or without dashes)
	// UUIDs are 32 hex chars (no dashes) or 36 chars (with dashes)
	if len(slug) == 32 && isHexString(slug) {
		return true
	}
	if len(slug) == 36 && isUUIDFormat(slug) {
		return true
	}

	return false
}

// isHexString checks if a string contains only hexadecimal characters (0-9, a-f, A-F).
func isHexString(s string) bool {
	for _, c := range s {
		if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) {
			return false
		}
	}
	return true
}

// isUUIDFormat checks if a string matches the UUID format: 8-4-4-4-12 hex characters.
func isUUIDFormat(s string) bool {
	if len(s) != 36 {
		return false
	}
	// Check dashes are in correct positions
	if s[8] != '-' || s[13] != '-' || s[18] != '-' || s[23] != '-' {
		return false
	}
	// Check all other characters are hex
	for i, c := range s {
		if i == 8 || i == 13 || i == 18 || i == 23 {
			continue // skip dash positions
		}
		if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) {
			return false
		}
	}
	return true
}

// buildExchangesFromMessages groups OpenCode messages into exchanges.
// An exchange starts with a user message and includes all subsequent assistant messages
// until the next user message.
func buildExchangesFromMessages(fullMessages []FullMessage, workspaceRoot string) ([]Exchange, error) {
	var exchanges []Exchange
	var currentExchange *Exchange

	for _, fullMsg := range fullMessages {
		msg := fullMsg.Message
		parts := fullMsg.Parts

		switch msg.Role {
		case RoleUser:
			// Start a new exchange with user message
			if currentExchange != nil && len(currentExchange.Messages) > 0 {
				exchanges = append(exchanges, *currentExchange)
			}

			currentExchange = &Exchange{
				StartTime: unixMillisToISO8601(msg.Time.Created),
				Messages:  []SchemaMessage{},
			}

			// Convert user message
			userMsg := ConvertMessage(msg, parts, workspaceRoot)
			currentExchange.Messages = append(currentExchange.Messages, userMsg...)

		case RoleAssistant:
			// Agent message - add to current exchange
			if currentExchange == nil {
				// Create exchange if we don't have one (shouldn't happen normally)
				currentExchange = &Exchange{
					StartTime: unixMillisToISO8601(msg.Time.Created),
					Messages:  []SchemaMessage{},
				}
			}

			// Convert assistant message (may produce multiple schema messages)
			agentMsgs := ConvertMessage(msg, parts, workspaceRoot)
			currentExchange.Messages = append(currentExchange.Messages, agentMsgs...)

			// Update end time
			if msg.Time.Completed != nil {
				currentExchange.EndTime = unixMillisToISO8601(*msg.Time.Completed)
			} else {
				currentExchange.EndTime = unixMillisToISO8601(msg.Time.Updated)
			}
		}
	}

	// Add the last exchange if exists
	if currentExchange != nil && len(currentExchange.Messages) > 0 {
		exchanges = append(exchanges, *currentExchange)
	}

	return exchanges, nil
}

// ConvertMessage converts an OpenCode message and its parts to SpecStory schema messages.
// Returns a slice because a single OpenCode message may produce multiple schema messages
// (e.g., separate messages for thinking, text, and each tool use).
func ConvertMessage(msg *Message, parts []Part, workspaceRoot string) []SchemaMessage {
	if msg == nil {
		return nil
	}

	var messages []SchemaMessage

	// Determine schema role from OpenCode role
	schemaRole := schema.RoleUser
	if msg.Role == RoleAssistant {
		schemaRole = schema.RoleAgent
	}

	// Get model info for agent messages
	model := ""
	if msg.ModelID != nil {
		model = *msg.ModelID
	}

	// Group parts by type for better organization
	var textParts []Part
	var reasoningParts []Part
	var toolParts []Part
	var compactionParts []Part
	var fileParts []Part

	for _, part := range parts {
		switch part.Type {
		case PartTypeText:
			textParts = append(textParts, part)
		case PartTypeReasoning:
			reasoningParts = append(reasoningParts, part)
		case PartTypeTool:
			toolParts = append(toolParts, part)
		case PartTypeCompaction:
			compactionParts = append(compactionParts, part)
		case PartTypeFile:
			fileParts = append(fileParts, part)
		case PartTypeStepStart, PartTypeStepFinish, PartTypePatch:
			// Skip internal markers
			continue
		}
	}

	// Convert reasoning parts first (thinking content)
	for _, part := range reasoningParts {
		schemaMsg := ConvertPart(&part, schemaRole, model, workspaceRoot)
		if schemaMsg != nil {
			messages = append(messages, *schemaMsg)
		}
	}

	// Convert text parts
	for _, part := range textParts {
		schemaMsg := ConvertPart(&part, schemaRole, model, workspaceRoot)
		if schemaMsg != nil {
			messages = append(messages, *schemaMsg)
		}
	}

	// Convert compaction parts (with [Compacted] prefix)
	for _, part := range compactionParts {
		schemaMsg := ConvertPart(&part, schemaRole, model, workspaceRoot)
		if schemaMsg != nil {
			messages = append(messages, *schemaMsg)
		}
	}

	// Convert file parts
	for _, part := range fileParts {
		schemaMsg := ConvertPart(&part, schemaRole, model, workspaceRoot)
		if schemaMsg != nil {
			messages = append(messages, *schemaMsg)
		}
	}

	// Convert tool parts (each becomes a separate message)
	for _, part := range toolParts {
		schemaMsg := ConvertPart(&part, schemaRole, model, workspaceRoot)
		if schemaMsg != nil {
			messages = append(messages, *schemaMsg)
		}
	}

	// If no parts produced messages but we have a message, create a basic one
	// This handles edge cases where a message exists but has no parts
	if len(messages) == 0 && len(parts) == 0 {
		messages = append(messages, SchemaMessage{
			ID:        msg.ID,
			Timestamp: unixMillisToISO8601(msg.Time.Created),
			Role:      schemaRole,
			Model:     model,
		})
	}

	return messages
}

// ConvertPart converts an OpenCode part to a SpecStory schema message.
// Returns nil for parts that should be skipped.
func ConvertPart(part *Part, role string, model string, workspaceRoot string) *SchemaMessage {
	if part == nil {
		return nil
	}

	// Get timestamp from part time if available
	timestamp := ""
	if part.Time != nil && part.Time.Start != nil {
		timestamp = unixMillisToISO8601(*part.Time.Start)
	}

	switch part.Type {
	case PartTypeText:
		// Regular text content
		if part.Text == nil || *part.Text == "" {
			return nil
		}
		return &SchemaMessage{
			ID:        part.ID,
			Timestamp: timestamp,
			Role:      role,
			Model:     model,
			Content: []ContentPart{
				{Type: schema.ContentTypeText, Text: *part.Text},
			},
		}

	case PartTypeReasoning:
		// Thinking/reasoning content
		if part.Text == nil || *part.Text == "" {
			return nil
		}
		return &SchemaMessage{
			ID:        part.ID,
			Timestamp: timestamp,
			Role:      role,
			Model:     model,
			Content: []ContentPart{
				{Type: schema.ContentTypeThinking, Text: *part.Text},
			},
		}

	case PartTypeTool:
		// Tool invocation
		return convertToolPart(part, role, model, timestamp, workspaceRoot)

	case PartTypeCompaction:
		// Compacted/summarized content - mark with [Compacted] prefix
		if part.Text == nil || *part.Text == "" {
			return nil
		}
		compactedText := fmt.Sprintf("[Compacted] %s", *part.Text)
		return &SchemaMessage{
			ID:        part.ID,
			Timestamp: timestamp,
			Role:      role,
			Model:     model,
			Content: []ContentPart{
				{Type: schema.ContentTypeText, Text: compactedText},
			},
		}

	case PartTypeFile:
		// File reference - convert metadata to a readable format
		return convertFilePart(part, role, model, timestamp)

	case PartTypeStepStart, PartTypeStepFinish, PartTypePatch:
		// Skip internal markers
		return nil

	default:
		// Unknown part type - log and skip
		slog.Debug("ConvertPart: Unknown part type", "type", part.Type, "partID", part.ID)
		return nil
	}
}

// convertToolPart converts an OpenCode tool part to a schema message with ToolInfo.
func convertToolPart(part *Part, role string, model string, timestamp string, workspaceRoot string) *SchemaMessage {
	if part.Tool == nil || *part.Tool == "" {
		return nil
	}

	toolName := *part.Tool
	toolType := MapToolType(toolName)

	// Build tool info
	toolInfo := &ToolInfo{
		Name: toolName,
		Type: toolType,
	}

	// Set tool use ID from CallID
	if part.CallID != nil {
		toolInfo.UseID = *part.CallID
	}

	// Extract input from tool state
	if part.State != nil {
		if part.State.Input != nil {
			toolInfo.Input = part.State.Input
		}

		// Extract output - can be various types
		if part.State.Output != nil {
			switch output := part.State.Output.(type) {
			case map[string]interface{}:
				toolInfo.Output = output
			case string:
				toolInfo.Output = map[string]interface{}{
					"content": output,
				}
			default:
				toolInfo.Output = map[string]interface{}{
					"raw": output,
				}
			}
		}

		// Add error info if present
		if part.State.Error != nil && *part.State.Error != "" {
			if toolInfo.Output == nil {
				toolInfo.Output = make(map[string]interface{})
			}
			toolInfo.Output["is_error"] = true
			toolInfo.Output["error"] = *part.State.Error
		}

		// Use title as summary if available
		if part.State.Title != nil && *part.State.Title != "" {
			title := *part.State.Title
			toolInfo.Summary = &title
		}
	}

	// Extract path hints from tool input
	pathHints := extractPathHintsFromTool(toolName, toolInfo.Input, workspaceRoot)

	return &SchemaMessage{
		ID:        part.ID,
		Timestamp: timestamp,
		Role:      role,
		Model:     model,
		Tool:      toolInfo,
		PathHints: pathHints,
	}
}

// convertFilePart converts an OpenCode file part to a schema message.
func convertFilePart(part *Part, role string, model string, timestamp string) *SchemaMessage {
	// Extract file info from metadata
	var content string
	if part.Metadata != nil {
		if path, ok := part.Metadata["path"].(string); ok {
			content = fmt.Sprintf("File: %s", path)
		}
		if name, ok := part.Metadata["name"].(string); ok {
			if content == "" {
				content = fmt.Sprintf("File: %s", name)
			}
		}
	}

	if content == "" {
		content = "File reference"
	}

	return &SchemaMessage{
		ID:        part.ID,
		Timestamp: timestamp,
		Role:      role,
		Model:     model,
		Content: []ContentPart{
			{Type: schema.ContentTypeText, Text: content},
		},
	}
}

// MapToolType maps OpenCode tool names to SpecStory's standard tool types.
// Valid types: write, read, search, shell, task, generic, unknown
func MapToolType(toolName string) string {
	// Normalize tool name to lowercase for matching
	toolLower := strings.ToLower(toolName)

	switch toolLower {
	// Read tools
	case "read", "read_file", "view_file", "cat", "webfetch", "web_fetch":
		return schema.ToolTypeRead

	// Write/Edit tools
	case "write", "edit", "write_file", "edit_file", "create_file", "append_to_file", "patch":
		return schema.ToolTypeWrite

	// Shell/Bash tools
	case "bash", "shell", "shell_command", "run", "exec", "execute":
		return schema.ToolTypeShell

	// Search tools
	case "glob", "grep", "find", "search", "ripgrep", "rg", "websearch", "web_search":
		return schema.ToolTypeSearch

	// Task management tools
	case "task", "todo", "todowrite", "todo_write", "update_plan", "plan":
		return schema.ToolTypeTask

	// Generic/known tools that don't fit other categories
	case "mcp", "lsp", "git", "agent", "delegate", "memory", "save_memory":
		return schema.ToolTypeGeneric

	default:
		// Unknown tool - check for common substrings as fallback
		if strings.Contains(toolLower, "read") {
			return schema.ToolTypeRead
		}
		if strings.Contains(toolLower, "write") || strings.Contains(toolLower, "edit") {
			return schema.ToolTypeWrite
		}
		if strings.Contains(toolLower, "bash") || strings.Contains(toolLower, "shell") {
			return schema.ToolTypeShell
		}
		if strings.Contains(toolLower, "search") || strings.Contains(toolLower, "grep") || strings.Contains(toolLower, "glob") {
			return schema.ToolTypeSearch
		}
		if strings.Contains(toolLower, "task") || strings.Contains(toolLower, "todo") {
			return schema.ToolTypeTask
		}

		return schema.ToolTypeUnknown
	}
}

// extractPathHintsFromTool extracts file paths from tool input for path hints.
func extractPathHintsFromTool(toolName string, input map[string]interface{}, workspaceRoot string) []string {
	if input == nil {
		return nil
	}

	var paths []string

	// Common path field names used by various tools
	pathFields := []string{"file_path", "path", "filename", "file", "target", "source", "destination"}
	arrayFields := []string{"paths", "files", "targets"}

	// Extract single path fields
	for _, field := range pathFields {
		if value, ok := input[field].(string); ok && value != "" {
			normalizedPath := normalizePath(value, workspaceRoot)
			if !containsString(paths, normalizedPath) {
				paths = append(paths, normalizedPath)
			}
		}
	}

	// Extract array path fields
	for _, field := range arrayFields {
		if arr, ok := input[field].([]interface{}); ok {
			for _, item := range arr {
				if path, ok := item.(string); ok && path != "" {
					normalizedPath := normalizePath(path, workspaceRoot)
					if !containsString(paths, normalizedPath) {
						paths = append(paths, normalizedPath)
					}
				}
			}
		}
	}

	return paths
}

// normalizePath converts absolute paths to workspace-relative paths when possible.
func normalizePath(path, workspaceRoot string) string {
	if workspaceRoot == "" {
		return path
	}

	// If path is absolute and starts with workspace root, make it relative
	if filepath.IsAbs(path) && strings.HasPrefix(path, workspaceRoot) {
		relPath, err := filepath.Rel(workspaceRoot, path)
		if err == nil {
			return relPath
		}
	}

	return path
}

// containsString checks if a string slice contains a value.
func containsString(slice []string, value string) bool {
	for _, item := range slice {
		if item == value {
			return true
		}
	}
	return false
}
