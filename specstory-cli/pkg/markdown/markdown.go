package markdown

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/specstoryai/SpecStoryCLI/pkg/spi/schema"
)

// Type aliases for convenience - use the shared schema types
type (
	SessionData  = schema.SessionData
	ProviderInfo = schema.ProviderInfo
	Exchange     = schema.Exchange
	Message      = schema.Message
	ContentPart  = schema.ContentPart
	ToolInfo     = schema.ToolInfo
)

// Markdown constants
const (
	GeneratedBySpecStory = "<!-- Generated by SpecStory, Markdown v2.1.0 -->"
	ToolUseOpenTag       = "<tool-use data-tool-type=\"%s\" data-tool-name=\"%s\"><details>"
	ToolUseCloseTag      = "</details></tool-use>"
)

// GenerateMarkdownFromAgentSession generates markdown from a SessionData
// This is provider-agnostic and works from the unified agent session JSON format
// If includeMessageIDs is true, message IDs will be included in the output
func GenerateMarkdownFromAgentSession(sessionData *SessionData, includeMessageIDs bool) (string, error) {
	if sessionData == nil {
		return "", fmt.Errorf("sessionData is nil")
	}

	var markdown strings.Builder

	// Add header comment
	markdown.WriteString(GeneratedBySpecStory + "\n\n")

	// Create title from session info
	title := generateTitle(sessionData)
	markdown.WriteString(fmt.Sprintf("# %s\n\n", title))

	// Add session metadata comment using the same timestamp format as the title
	var commentTimestamp string
	if len(sessionData.Exchanges) > 0 && sessionData.Exchanges[0].StartTime != "" {
		commentTimestamp = formatTimestamp(sessionData.Exchanges[0].StartTime)
	} else {
		commentTimestamp = formatTimestamp(sessionData.CreatedAt)
	}
	markdown.WriteString(fmt.Sprintf("<!-- %s Session %s (%s) -->\n\n",
		sessionData.Provider.Name,
		sessionData.SessionID,
		commentTimestamp))

	// Render each exchange, tracking role across exchanges for proper separators
	prevRole := ""
	for _, exchange := range sessionData.Exchanges {
		for _, msg := range exchange.Messages {
			markdown.WriteString(renderMessage(msg, prevRole, includeMessageIDs))
			prevRole = msg.Role
		}
	}

	// Ensure markdown ends with exactly one newline
	result := strings.TrimRight(markdown.String(), "\n") + "\n"
	return result, nil
}

// generateTitle creates a title for the session
func generateTitle(sessionData *SessionData) string {
	// Use first exchange start time for the title (matching existing markdown format)
	// This is the timestamp of the first user message
	if len(sessionData.Exchanges) > 0 && sessionData.Exchanges[0].StartTime != "" {
		return formatTimestamp(sessionData.Exchanges[0].StartTime)
	}
	// Fallback to session creation time if no exchanges or no start time
	return formatTimestamp(sessionData.CreatedAt)
}

// formatTimestamp formats an ISO 8601 timestamp for display in title
func formatTimestamp(timestamp string) string {
	t, err := time.Parse(time.RFC3339, timestamp)
	if err != nil {
		return timestamp
	}
	// Format to match existing markdown: "2025-11-13 21:12:14Z"
	return t.UTC().Format("2006-01-02 15:04:05") + "Z"
}

// renderMessage renders a single message with role header, content, and optional tool use
func renderMessage(msg Message, prevRole string, includeMessageIDs bool) string {
	var markdown strings.Builder

	// Add separator before this message if role changed from previous message
	if shouldAddSeparator(msg.Role, prevRole) {
		markdown.WriteString("---\n\n")
	}

	// Add role header
	roleHeader := renderRoleHeader(msg)
	if includeMessageIDs && msg.ID != "" {
		// Strip one trailing newline so the message ID comment appears on the next line
		roleHeader = strings.TrimSuffix(roleHeader, "\n")
		markdown.WriteString(roleHeader)
		markdown.WriteString(fmt.Sprintf("<!-- message-id: %s -->\n\n", msg.ID))
	} else {
		markdown.WriteString(roleHeader)
	}

	// Render content parts (already includes trailing newlines)
	if len(msg.Content) > 0 {
		markdown.WriteString(renderContentParts(msg.Content))
	}

	// Render tool use if present
	if msg.Tool != nil {
		markdown.WriteString(renderToolInfo(msg.Tool))
		markdown.WriteString("\n")
	}

	return markdown.String()
}

// renderRoleHeader creates the role header for a message
func renderRoleHeader(msg Message) string {
	// Check if this is a sidechain message (subagent conversation)
	sidechainMarker := ""
	if isSidechain, ok := msg.Metadata["isSidechain"].(bool); ok && isSidechain {
		sidechainMarker = " - sidechain"
	}

	if msg.Role == "user" {
		// User message - include timestamp if available
		if msg.Timestamp != "" {
			return fmt.Sprintf("_**User%s (%s)**_\n\n", sidechainMarker, msg.Timestamp)
		}
		return fmt.Sprintf("_**User%s**_\n\n", sidechainMarker)
	}

	// Agent message - include model and timestamp if available
	if msg.Model != "" && msg.Timestamp != "" {
		return fmt.Sprintf("_**Agent%s (%s %s)**_\n\n", sidechainMarker, msg.Model, msg.Timestamp)
	}
	if msg.Model != "" {
		return fmt.Sprintf("_**Agent%s (%s)**_\n\n", sidechainMarker, msg.Model)
	}
	if msg.Timestamp != "" {
		return fmt.Sprintf("_**Agent%s (%s)**_\n\n", sidechainMarker, msg.Timestamp)
	}

	return fmt.Sprintf("_**Agent%s**_\n\n", sidechainMarker)
}

// renderContentParts renders all content parts in a message
func renderContentParts(parts []ContentPart) string {
	var markdown strings.Builder

	for _, part := range parts {
		switch part.Type {
		case "text":
			// Regular text content
			markdown.WriteString(part.Text)
			markdown.WriteString("\n\n")

		case "thinking":
			// Thinking content in collapsible block
			markdown.WriteString("<think><details><summary>Thought Process</summary>\n")
			markdown.WriteString(part.Text)
			// Only add newline before closing tag if text doesn't already end with one
			if !strings.HasSuffix(part.Text, "\n") {
				markdown.WriteString("\n")
			}
			markdown.WriteString("</details></think>\n\n")
		}
	}

	return markdown.String()
}

// renderToolInfo renders tool use information
func renderToolInfo(tool *ToolInfo) string {
	var markdown strings.Builder

	// Get the tool type for the data attribute
	toolType := tool.Type
	if toolType == "" {
		toolType = "generic"
	}

	// Open tool-use tag
	markdown.WriteString(fmt.Sprintf(ToolUseOpenTag, toolType, tool.Name))
	markdown.WriteString("\n")

	// Generate summary tag
	if tool.Summary != nil && *tool.Summary != "" {
		// Provider provided custom summary content
		markdown.WriteString(fmt.Sprintf("<summary>%s</summary>\n", *tool.Summary))
	} else {
		// Generate default summary
		markdown.WriteString(fmt.Sprintf("<summary>Tool use: **%s**</summary>\n", tool.Name))
	}

	// Use pre-formatted markdown from provider if present
	if tool.FormattedMarkdown != nil && *tool.FormattedMarkdown != "" {
		markdown.WriteString(*tool.FormattedMarkdown)
		// Ensure there's a newline before the closing tag
		// Some providers include it, some don't - normalize here
		if !strings.HasSuffix(*tool.FormattedMarkdown, "\n") {
			markdown.WriteString("\n")
		}
	} else {
		// Fallback to generic formatting
		markdown.WriteString(renderGenericTool(tool))
	}

	// Close tool-use tag
	markdown.WriteString(ToolUseCloseTag)
	markdown.WriteString("\n")

	return markdown.String()
}

// renderGenericTool renders a tool without provider-specific formatting
// Displays all available information as key-value pairs
// Note: The <summary> tag is already written by the caller (renderToolMessage)
func renderGenericTool(tool *ToolInfo) string {
	var markdown strings.Builder
	markdown.WriteString("\n")

	// Display input as key-value pairs if present
	// Sort keys for deterministic output order
	if len(tool.Input) > 0 {
		markdown.WriteString("**Input:**\n\n")

		// Extract and sort keys for deterministic ordering
		keys := make([]string, 0, len(tool.Input))
		for key := range tool.Input {
			// Skip internal fields like _cwd
			if !strings.HasPrefix(key, "_") {
				keys = append(keys, key)
			}
		}
		sort.Strings(keys)

		for _, key := range keys {
			markdown.WriteString(fmt.Sprintf("- %s: `%v`\n", key, tool.Input[key]))
		}
		markdown.WriteString("\n")
	}

	// Display output if present
	if tool.Output != nil {
		if isError, ok := tool.Output["is_error"].(bool); ok && isError {
			markdown.WriteString("**Error:**\n\n")
		} else {
			markdown.WriteString("**Result:**\n\n")
		}

		if content, ok := tool.Output["content"].(string); ok {
			markdown.WriteString("```\n")
			markdown.WriteString(content)
			markdown.WriteString("\n```\n")
		}
	}

	return markdown.String()
}

// shouldAddSeparator determines if a separator should be added between messages
func shouldAddSeparator(currentRole, prevRole string) bool {
	// Add separator on role transitions
	if prevRole == "" {
		return false
	}
	return currentRole != prevRole
}
